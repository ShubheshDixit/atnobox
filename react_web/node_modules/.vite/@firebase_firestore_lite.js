import {
  Component,
  LogLevel,
  Logger,
  SDK_VERSION,
  _getProvider,
  _registerComponent,
  _removeServiceInstance,
  createMockUserToken,
  getApp,
  getModularInstance,
  registerVersion
} from "./chunk-52TUVP2Y.js";
import "./chunk-YDLDBZVM.js";
import "./chunk-HV27UI33.js";

// node_modules/@firebase/firestore/dist/lite/index.browser.esm2017.js
var h = class {
  constructor(t) {
    this.uid = t;
  }
  isAuthenticated() {
    return this.uid != null;
  }
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(t) {
    return t.uid === this.uid;
  }
};
h.UNAUTHENTICATED = new h(null), h.GOOGLE_CREDENTIALS = new h("google-credentials-uid"), h.FIRST_PARTY = new h("first-party-uid"), h.MOCK_USER = new h("mock-user");
var l = "9.0.2";
var f = new Logger("@firebase/firestore");
function d(t) {
  f.setLogLevel(t);
}
function w(t, ...n) {
  if (f.logLevel <= LogLevel.DEBUG) {
    const e = n.map(y);
    f.debug(`Firestore (${l}): ${t}`, ...e);
  }
}
function m(t, ...n) {
  if (f.logLevel <= LogLevel.ERROR) {
    const e = n.map(y);
    f.error(`Firestore (${l}): ${t}`, ...e);
  }
}
function p(t, ...n) {
  if (f.logLevel <= LogLevel.WARN) {
    const e = n.map(y);
    f.warn(`Firestore (${l}): ${t}`, ...e);
  }
}
function y(t) {
  if (typeof t == "string")
    return t;
  try {
    return n = t, JSON.stringify(n);
  } catch (n2) {
    return t;
  }
  var n;
}
function _(t = "Unexpected state") {
  const n = `FIRESTORE (${l}) INTERNAL ASSERTION FAILED: ` + t;
  throw m(n), new Error(n);
}
function g(t, n) {
  t || _();
}
function b(t, n) {
  return t;
}
var v = "ok";
var E = "cancelled";
var I = "unknown";
var T = "invalid-argument";
var A = "deadline-exceeded";
var P = "not-found";
var R = "already-exists";
var V = "permission-denied";
var N = "unauthenticated";
var D = "resource-exhausted";
var $ = "failed-precondition";
var F = "aborted";
var S = "out-of-range";
var q = "unimplemented";
var x = "internal";
var O = "unavailable";
var C = "data-loss";
var L = class extends Error {
  constructor(t, n) {
    super(n), this.code = t, this.message = n, this.name = "FirebaseError", this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
};
var U = class {
  constructor() {
    this.promise = new Promise((t, n) => {
      this.resolve = t, this.reject = n;
    });
  }
};
var j = class {
  constructor(t, n) {
    this.user = n, this.type = "OAuth", this.authHeaders = {}, this.authHeaders.Authorization = `Bearer ${t}`;
  }
};
var k = class {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(t, n) {
    t.enqueueRetryable(() => n(h.UNAUTHENTICATED));
  }
  shutdown() {
  }
};
var M = class {
  constructor(t) {
    this.token = t, this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(t, n) {
    this.changeListener = n, t.enqueueRetryable(() => n(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
};
var B = class {
  constructor(t) {
    this.auth = null, t.onInit((t2) => {
      this.auth = t2;
    });
  }
  getToken() {
    return this.auth ? this.auth.getToken().then((t) => t ? (g(typeof t.accessToken == "string"), new j(t.accessToken, new h(this.auth.getUid()))) : null) : Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(t, n) {
  }
  shutdown() {
  }
};
var Q = class {
  constructor(t, n, e) {
    this.t = t, this.i = n, this.o = e, this.type = "FirstParty", this.user = h.FIRST_PARTY;
  }
  get authHeaders() {
    const t = {
      "X-Goog-AuthUser": this.i
    }, n = this.t.auth.getAuthHeaderValueForFirstParty([]);
    return n && (t.Authorization = n), this.o && (t["X-Goog-Iam-Authorization-Token"] = this.o), t;
  }
};
var z = class {
  constructor(t, n, e) {
    this.t = t, this.i = n, this.o = e;
  }
  getToken() {
    return Promise.resolve(new Q(this.t, this.i, this.o));
  }
  start(t, n) {
    t.enqueueRetryable(() => n(h.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
};
var W = class {
  constructor(t, n, e, r, s, i, o, u) {
    this.databaseId = t, this.appId = n, this.persistenceKey = e, this.host = r, this.ssl = s, this.forceLongPolling = i, this.autoDetectLongPolling = o, this.useFetchStreams = u;
  }
};
var G = class {
  constructor(t, n) {
    this.projectId = t, this.database = n || "(default)";
  }
  get isDefaultDatabase() {
    return this.database === "(default)";
  }
  isEqual(t) {
    return t instanceof G && t.projectId === this.projectId && t.database === this.database;
  }
};
var H = class {
  constructor(t, n, e) {
    n === void 0 ? n = 0 : n > t.length && _(), e === void 0 ? e = t.length - n : e > t.length - n && _(), this.segments = t, this.offset = n, this.len = e;
  }
  get length() {
    return this.len;
  }
  isEqual(t) {
    return H.comparator(this, t) === 0;
  }
  child(t) {
    const n = this.segments.slice(this.offset, this.limit());
    return t instanceof H ? t.forEach((t2) => {
      n.push(t2);
    }) : n.push(t), this.construct(n);
  }
  limit() {
    return this.offset + this.length;
  }
  popFirst(t) {
    return t = t === void 0 ? 1 : t, this.construct(this.segments, this.offset + t, this.length - t);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(t) {
    return this.segments[this.offset + t];
  }
  isEmpty() {
    return this.length === 0;
  }
  isPrefixOf(t) {
    if (t.length < this.length)
      return false;
    for (let n = 0; n < this.length; n++)
      if (this.get(n) !== t.get(n))
        return false;
    return true;
  }
  isImmediateParentOf(t) {
    if (this.length + 1 !== t.length)
      return false;
    for (let n = 0; n < this.length; n++)
      if (this.get(n) !== t.get(n))
        return false;
    return true;
  }
  forEach(t) {
    for (let n = this.offset, e = this.limit(); n < e; n++)
      t(this.segments[n]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(t, n) {
    const e = Math.min(t.length, n.length);
    for (let r = 0; r < e; r++) {
      const e2 = t.get(r), s = n.get(r);
      if (e2 < s)
        return -1;
      if (e2 > s)
        return 1;
    }
    return t.length < n.length ? -1 : t.length > n.length ? 1 : 0;
  }
};
var Y = class extends H {
  construct(t, n, e) {
    return new Y(t, n, e);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  static fromString(...t) {
    const n = [];
    for (const e of t) {
      if (e.indexOf("//") >= 0)
        throw new L(T, `Invalid segment (${e}). Paths must not contain // in them.`);
      n.push(...e.split("/").filter((t2) => t2.length > 0));
    }
    return new Y(n);
  }
  static emptyPath() {
    return new Y([]);
  }
};
var K = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
var J = class extends H {
  construct(t, n, e) {
    return new J(t, n, e);
  }
  static isValidIdentifier(t) {
    return K.test(t);
  }
  canonicalString() {
    return this.toArray().map((t) => (t = t.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), J.isValidIdentifier(t) || (t = "`" + t + "`"), t)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  isKeyField() {
    return this.length === 1 && this.get(0) === "__name__";
  }
  static keyField() {
    return new J(["__name__"]);
  }
  static fromServerFormat(t) {
    const n = [];
    let e = "", r = 0;
    const s = () => {
      if (e.length === 0)
        throw new L(T, `Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      n.push(e), e = "";
    };
    let i = false;
    for (; r < t.length; ) {
      const n2 = t[r];
      if (n2 === "\\") {
        if (r + 1 === t.length)
          throw new L(T, "Path has trailing escape character: " + t);
        const n3 = t[r + 1];
        if (n3 !== "\\" && n3 !== "." && n3 !== "`")
          throw new L(T, "Path has invalid escape sequence: " + t);
        e += n3, r += 2;
      } else
        n2 === "`" ? (i = !i, r++) : n2 !== "." || i ? (e += n2, r++) : (s(), r++);
    }
    if (s(), i)
      throw new L(T, "Unterminated ` in path: " + t);
    return new J(n);
  }
  static emptyPath() {
    return new J([]);
  }
};
var Z = class {
  constructor(t) {
    this.path = t;
  }
  static fromPath(t) {
    return new Z(Y.fromString(t));
  }
  static fromName(t) {
    return new Z(Y.fromString(t).popFirst(5));
  }
  hasCollectionId(t) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === t;
  }
  isEqual(t) {
    return t !== null && Y.comparator(this.path, t.path) === 0;
  }
  toString() {
    return this.path.toString();
  }
  static comparator(t, n) {
    return Y.comparator(t.path, n.path);
  }
  static isDocumentKey(t) {
    return t.length % 2 == 0;
  }
  static fromSegments(t) {
    return new Z(new Y(t.slice()));
  }
};
function X(t, n, e) {
  if (!e)
    throw new L(T, `Function ${t}() cannot be called with an empty ${n}.`);
}
function tt(t) {
  if (!Z.isDocumentKey(t))
    throw new L(T, `Invalid document reference. Document references must have an even number of segments, but ${t} has ${t.length}.`);
}
function nt(t) {
  if (Z.isDocumentKey(t))
    throw new L(T, `Invalid collection reference. Collection references must have an odd number of segments, but ${t} has ${t.length}.`);
}
function et(t) {
  if (t === void 0)
    return "undefined";
  if (t === null)
    return "null";
  if (typeof t == "string")
    return t.length > 20 && (t = `${t.substring(0, 20)}...`), JSON.stringify(t);
  if (typeof t == "number" || typeof t == "boolean")
    return "" + t;
  if (typeof t == "object") {
    if (t instanceof Array)
      return "an array";
    {
      const n = function(t2) {
        if (t2.constructor) {
          const n2 = /function\s+([^\s(]+)\s*\(/.exec(t2.constructor.toString());
          if (n2 && n2.length > 1)
            return n2[1];
        }
        return null;
      }(t);
      return n ? `a custom ${n} object` : "an object";
    }
  }
  return typeof t == "function" ? "a function" : _();
}
function rt(t, n) {
  if ("_delegate" in t && (t = t._delegate), !(t instanceof n)) {
    if (n.name === t.constructor.name)
      throw new L(T, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const e = et(t);
      throw new L(T, `Expected type '${n.name}', but it was: ${e}`);
    }
  }
  return t;
}
function st(t, n) {
  if (n <= 0)
    throw new L(T, `Function ${t}() requires a positive number, but it was: ${n}.`);
}
function it(t) {
  return t == null;
}
function ot(t) {
  return t === 0 && 1 / t == -1 / 0;
}
var ut = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery"
};
var ct;
var at;
function ht(t) {
  if (t === void 0)
    return m("RPC_ERROR", "HTTP error has no status"), I;
  switch (t) {
    case 200:
      return v;
    case 400:
      return $;
    case 401:
      return N;
    case 403:
      return V;
    case 404:
      return P;
    case 409:
      return F;
    case 416:
      return S;
    case 429:
      return D;
    case 499:
      return E;
    case 500:
      return I;
    case 501:
      return q;
    case 503:
      return O;
    case 504:
      return A;
    default:
      return t >= 200 && t < 300 ? v : t >= 400 && t < 500 ? $ : t >= 500 && t < 600 ? x : I;
  }
}
(at = ct || (ct = {}))[at.OK = 0] = "OK", at[at.CANCELLED = 1] = "CANCELLED", at[at.UNKNOWN = 2] = "UNKNOWN", at[at.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", at[at.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", at[at.NOT_FOUND = 5] = "NOT_FOUND", at[at.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", at[at.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", at[at.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", at[at.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", at[at.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", at[at.ABORTED = 10] = "ABORTED", at[at.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", at[at.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", at[at.INTERNAL = 13] = "INTERNAL", at[at.UNAVAILABLE = 14] = "UNAVAILABLE", at[at.DATA_LOSS = 15] = "DATA_LOSS";
var lt = class extends class {
  constructor(t) {
    this.databaseInfo = t, this.databaseId = t.databaseId;
    const n = t.ssl ? "https" : "http";
    this.u = n + "://" + t.host, this.h = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
  }
  l(t, n, e, r) {
    const s = this.m(t, n);
    w("RestConnection", "Sending: ", s, e);
    const i = {};
    return this.p(i, r), this.g(t, s, i, e).then((t2) => (w("RestConnection", "Received: ", t2), t2), (n2) => {
      throw p("RestConnection", `${t} failed with error: `, n2, "url: ", s, "request:", e), n2;
    });
  }
  v(t, n, e, r) {
    return this.l(t, n, e, r);
  }
  p(t, n) {
    if (t["X-Goog-Api-Client"] = "gl-js/ fire/" + l, t["Content-Type"] = "text/plain", this.databaseInfo.appId && (t["X-Firebase-GMPID"] = this.databaseInfo.appId), n)
      for (const e in n.authHeaders)
        n.authHeaders.hasOwnProperty(e) && (t[e] = n.authHeaders[e]);
  }
  m(t, n) {
    const e = ut[t];
    return `${this.u}/v1/${n}:${e}`;
  }
} {
  constructor(t, n) {
    super(t), this.I = n;
  }
  T(t, n) {
    throw new Error("Not supported by FetchConnection");
  }
  async g(t, n, e, r) {
    const s = JSON.stringify(r);
    let i;
    try {
      i = await this.I(n, {
        method: "POST",
        headers: e,
        body: s
      });
    } catch (t2) {
      throw new L(ht(t2.status), "Request failed with error: " + t2.statusText);
    }
    if (!i.ok)
      throw new L(ht(i.status), "Request failed with error: " + i.statusText);
    return i.json();
  }
};
function ft(t) {
  const n = typeof self != "undefined" && (self.crypto || self.msCrypto), e = new Uint8Array(t);
  if (n && typeof n.getRandomValues == "function")
    n.getRandomValues(e);
  else
    for (let n2 = 0; n2 < t; n2++)
      e[n2] = Math.floor(256 * Math.random());
  return e;
}
var dt = class {
  static A() {
    const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", n = Math.floor(256 / t.length) * t.length;
    let e = "";
    for (; e.length < 20; ) {
      const r = ft(40);
      for (let s = 0; s < r.length; ++s)
        e.length < 20 && r[s] < n && (e += t.charAt(r[s] % t.length));
    }
    return e;
  }
};
function wt(t, n) {
  return t < n ? -1 : t > n ? 1 : 0;
}
function mt(t, n, e) {
  return t.length === n.length && t.every((t2, r) => e(t2, n[r]));
}
var pt = class {
  constructor(t, n) {
    if (this.seconds = t, this.nanoseconds = n, n < 0)
      throw new L(T, "Timestamp nanoseconds out of range: " + n);
    if (n >= 1e9)
      throw new L(T, "Timestamp nanoseconds out of range: " + n);
    if (t < -62135596800)
      throw new L(T, "Timestamp seconds out of range: " + t);
    if (t >= 253402300800)
      throw new L(T, "Timestamp seconds out of range: " + t);
  }
  static now() {
    return pt.fromMillis(Date.now());
  }
  static fromDate(t) {
    return pt.fromMillis(t.getTime());
  }
  static fromMillis(t) {
    const n = Math.floor(t / 1e3), e = Math.floor(1e6 * (t - 1e3 * n));
    return new pt(n, e);
  }
  toDate() {
    return new Date(this.toMillis());
  }
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(t) {
    return this.seconds === t.seconds ? wt(this.nanoseconds, t.nanoseconds) : wt(this.seconds, t.seconds);
  }
  isEqual(t) {
    return t.seconds === this.seconds && t.nanoseconds === this.nanoseconds;
  }
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  valueOf() {
    const t = this.seconds - -62135596800;
    return String(t).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
};
var yt = class {
  constructor(t) {
    this.timestamp = t;
  }
  static fromTimestamp(t) {
    return new yt(t);
  }
  static min() {
    return new yt(new pt(0, 0));
  }
  compareTo(t) {
    return this.timestamp._compareTo(t.timestamp);
  }
  isEqual(t) {
    return this.timestamp.isEqual(t.timestamp);
  }
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
};
function _t(t) {
  let n = 0;
  for (const e in t)
    Object.prototype.hasOwnProperty.call(t, e) && n++;
  return n;
}
function gt(t, n) {
  for (const e in t)
    Object.prototype.hasOwnProperty.call(t, e) && n(e, t[e]);
}
var bt = class {
  constructor(t) {
    this.fields = t, t.sort(J.comparator);
  }
  covers(t) {
    for (const n of this.fields)
      if (n.isPrefixOf(t))
        return true;
    return false;
  }
  isEqual(t) {
    return mt(this.fields, t.fields, (t2, n) => t2.isEqual(n));
  }
};
var vt = class {
  constructor(t) {
    this.binaryString = t;
  }
  static fromBase64String(t) {
    const n = atob(t);
    return new vt(n);
  }
  static fromUint8Array(t) {
    const n = function(t2) {
      let n2 = "";
      for (let e = 0; e < t2.length; ++e)
        n2 += String.fromCharCode(t2[e]);
      return n2;
    }(t);
    return new vt(n);
  }
  toBase64() {
    return t = this.binaryString, btoa(t);
    var t;
  }
  toUint8Array() {
    return function(t) {
      const n = new Uint8Array(t.length);
      for (let e = 0; e < t.length; e++)
        n[e] = t.charCodeAt(e);
      return n;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(t) {
    return wt(this.binaryString, t.binaryString);
  }
  isEqual(t) {
    return this.binaryString === t.binaryString;
  }
};
vt.EMPTY_BYTE_STRING = new vt("");
var Et = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function It(t) {
  if (g(!!t), typeof t == "string") {
    let n = 0;
    const e = Et.exec(t);
    if (g(!!e), e[1]) {
      let t2 = e[1];
      t2 = (t2 + "000000000").substr(0, 9), n = Number(t2);
    }
    const r = new Date(t);
    return {
      seconds: Math.floor(r.getTime() / 1e3),
      nanos: n
    };
  }
  return {
    seconds: Tt(t.seconds),
    nanos: Tt(t.nanos)
  };
}
function Tt(t) {
  return typeof t == "number" ? t : typeof t == "string" ? Number(t) : 0;
}
function At(t) {
  return typeof t == "string" ? vt.fromBase64String(t) : vt.fromUint8Array(t);
}
function Pt(t) {
  var n, e;
  return ((e = (((n = t == null ? void 0 : t.mapValue) === null || n === void 0 ? void 0 : n.fields) || {}).__type__) === null || e === void 0 ? void 0 : e.stringValue) === "server_timestamp";
}
function Rt(t) {
  const n = t.mapValue.fields.__previous_value__;
  return Pt(n) ? Rt(n) : n;
}
function Vt(t) {
  const n = It(t.mapValue.fields.__local_write_time__.timestampValue);
  return new pt(n.seconds, n.nanos);
}
function Nt(t) {
  return "nullValue" in t ? 0 : "booleanValue" in t ? 1 : "integerValue" in t || "doubleValue" in t ? 2 : "timestampValue" in t ? 3 : "stringValue" in t ? 5 : "bytesValue" in t ? 6 : "referenceValue" in t ? 7 : "geoPointValue" in t ? 8 : "arrayValue" in t ? 9 : "mapValue" in t ? Pt(t) ? 4 : 10 : _();
}
function Dt(t, n) {
  const e = Nt(t);
  if (e !== Nt(n))
    return false;
  switch (e) {
    case 0:
      return true;
    case 1:
      return t.booleanValue === n.booleanValue;
    case 4:
      return Vt(t).isEqual(Vt(n));
    case 3:
      return function(t2, n2) {
        if (typeof t2.timestampValue == "string" && typeof n2.timestampValue == "string" && t2.timestampValue.length === n2.timestampValue.length)
          return t2.timestampValue === n2.timestampValue;
        const e2 = It(t2.timestampValue), r = It(n2.timestampValue);
        return e2.seconds === r.seconds && e2.nanos === r.nanos;
      }(t, n);
    case 5:
      return t.stringValue === n.stringValue;
    case 6:
      return function(t2, n2) {
        return At(t2.bytesValue).isEqual(At(n2.bytesValue));
      }(t, n);
    case 7:
      return t.referenceValue === n.referenceValue;
    case 8:
      return function(t2, n2) {
        return Tt(t2.geoPointValue.latitude) === Tt(n2.geoPointValue.latitude) && Tt(t2.geoPointValue.longitude) === Tt(n2.geoPointValue.longitude);
      }(t, n);
    case 2:
      return function(t2, n2) {
        if ("integerValue" in t2 && "integerValue" in n2)
          return Tt(t2.integerValue) === Tt(n2.integerValue);
        if ("doubleValue" in t2 && "doubleValue" in n2) {
          const e2 = Tt(t2.doubleValue), r = Tt(n2.doubleValue);
          return e2 === r ? ot(e2) === ot(r) : isNaN(e2) && isNaN(r);
        }
        return false;
      }(t, n);
    case 9:
      return mt(t.arrayValue.values || [], n.arrayValue.values || [], Dt);
    case 10:
      return function(t2, n2) {
        const e2 = t2.mapValue.fields || {}, r = n2.mapValue.fields || {};
        if (_t(e2) !== _t(r))
          return false;
        for (const t3 in e2)
          if (e2.hasOwnProperty(t3) && (r[t3] === void 0 || !Dt(e2[t3], r[t3])))
            return false;
        return true;
      }(t, n);
    default:
      return _();
  }
}
function $t(t, n) {
  return (t.values || []).find((t2) => Dt(t2, n)) !== void 0;
}
function Ft(t, n) {
  const e = Nt(t), r = Nt(n);
  if (e !== r)
    return wt(e, r);
  switch (e) {
    case 0:
      return 0;
    case 1:
      return wt(t.booleanValue, n.booleanValue);
    case 2:
      return function(t2, n2) {
        const e2 = Tt(t2.integerValue || t2.doubleValue), r2 = Tt(n2.integerValue || n2.doubleValue);
        return e2 < r2 ? -1 : e2 > r2 ? 1 : e2 === r2 ? 0 : isNaN(e2) ? isNaN(r2) ? 0 : -1 : 1;
      }(t, n);
    case 3:
      return St(t.timestampValue, n.timestampValue);
    case 4:
      return St(Vt(t), Vt(n));
    case 5:
      return wt(t.stringValue, n.stringValue);
    case 6:
      return function(t2, n2) {
        const e2 = At(t2), r2 = At(n2);
        return e2.compareTo(r2);
      }(t.bytesValue, n.bytesValue);
    case 7:
      return function(t2, n2) {
        const e2 = t2.split("/"), r2 = n2.split("/");
        for (let t3 = 0; t3 < e2.length && t3 < r2.length; t3++) {
          const n3 = wt(e2[t3], r2[t3]);
          if (n3 !== 0)
            return n3;
        }
        return wt(e2.length, r2.length);
      }(t.referenceValue, n.referenceValue);
    case 8:
      return function(t2, n2) {
        const e2 = wt(Tt(t2.latitude), Tt(n2.latitude));
        if (e2 !== 0)
          return e2;
        return wt(Tt(t2.longitude), Tt(n2.longitude));
      }(t.geoPointValue, n.geoPointValue);
    case 9:
      return function(t2, n2) {
        const e2 = t2.values || [], r2 = n2.values || [];
        for (let t3 = 0; t3 < e2.length && t3 < r2.length; ++t3) {
          const n3 = Ft(e2[t3], r2[t3]);
          if (n3)
            return n3;
        }
        return wt(e2.length, r2.length);
      }(t.arrayValue, n.arrayValue);
    case 10:
      return function(t2, n2) {
        const e2 = t2.fields || {}, r2 = Object.keys(e2), s = n2.fields || {}, i = Object.keys(s);
        r2.sort(), i.sort();
        for (let t3 = 0; t3 < r2.length && t3 < i.length; ++t3) {
          const n3 = wt(r2[t3], i[t3]);
          if (n3 !== 0)
            return n3;
          const o = Ft(e2[r2[t3]], s[i[t3]]);
          if (o !== 0)
            return o;
        }
        return wt(r2.length, i.length);
      }(t.mapValue, n.mapValue);
    default:
      throw _();
  }
}
function St(t, n) {
  if (typeof t == "string" && typeof n == "string" && t.length === n.length)
    return wt(t, n);
  const e = It(t), r = It(n), s = wt(e.seconds, r.seconds);
  return s !== 0 ? s : wt(e.nanos, r.nanos);
}
function qt(t, n) {
  return {
    referenceValue: `projects/${t.projectId}/databases/${t.database}/documents/${n.path.canonicalString()}`
  };
}
function xt(t) {
  return !!t && "arrayValue" in t;
}
function Ot(t) {
  return !!t && "nullValue" in t;
}
function Ct(t) {
  return !!t && "doubleValue" in t && isNaN(Number(t.doubleValue));
}
function Lt(t) {
  return !!t && "mapValue" in t;
}
function Ut(t) {
  if (t.geoPointValue)
    return {
      geoPointValue: Object.assign({}, t.geoPointValue)
    };
  if (t.timestampValue && typeof t.timestampValue == "object")
    return {
      timestampValue: Object.assign({}, t.timestampValue)
    };
  if (t.mapValue) {
    const n = {
      mapValue: {
        fields: {}
      }
    };
    return gt(t.mapValue.fields, (t2, e) => n.mapValue.fields[t2] = Ut(e)), n;
  }
  if (t.arrayValue) {
    const n = {
      arrayValue: {
        values: []
      }
    };
    for (let e = 0; e < (t.arrayValue.values || []).length; ++e)
      n.arrayValue.values[e] = Ut(t.arrayValue.values[e]);
    return n;
  }
  return Object.assign({}, t);
}
var jt = class {
  constructor(t) {
    this.value = t;
  }
  static empty() {
    return new jt({
      mapValue: {}
    });
  }
  field(t) {
    if (t.isEmpty())
      return this.value;
    {
      let n = this.value;
      for (let e = 0; e < t.length - 1; ++e)
        if (n = (n.mapValue.fields || {})[t.get(e)], !Lt(n))
          return null;
      return n = (n.mapValue.fields || {})[t.lastSegment()], n || null;
    }
  }
  set(t, n) {
    this.getFieldsMap(t.popLast())[t.lastSegment()] = Ut(n);
  }
  setAll(t) {
    let n = J.emptyPath(), e = {}, r = [];
    t.forEach((t2, s2) => {
      if (!n.isImmediateParentOf(s2)) {
        const t3 = this.getFieldsMap(n);
        this.applyChanges(t3, e, r), e = {}, r = [], n = s2.popLast();
      }
      t2 ? e[s2.lastSegment()] = Ut(t2) : r.push(s2.lastSegment());
    });
    const s = this.getFieldsMap(n);
    this.applyChanges(s, e, r);
  }
  delete(t) {
    const n = this.field(t.popLast());
    Lt(n) && n.mapValue.fields && delete n.mapValue.fields[t.lastSegment()];
  }
  isEqual(t) {
    return Dt(this.value, t.value);
  }
  getFieldsMap(t) {
    let n = this.value;
    n.mapValue.fields || (n.mapValue = {
      fields: {}
    });
    for (let e = 0; e < t.length; ++e) {
      let r = n.mapValue.fields[t.get(e)];
      Lt(r) && r.mapValue.fields || (r = {
        mapValue: {
          fields: {}
        }
      }, n.mapValue.fields[t.get(e)] = r), n = r;
    }
    return n.mapValue.fields;
  }
  applyChanges(t, n, e) {
    gt(n, (n2, e2) => t[n2] = e2);
    for (const n2 of e)
      delete t[n2];
  }
  clone() {
    return new jt(Ut(this.value));
  }
};
var kt = class {
  constructor(t, n, e, r, s) {
    this.key = t, this.documentType = n, this.version = e, this.data = r, this.documentState = s;
  }
  static newInvalidDocument(t) {
    return new kt(t, 0, yt.min(), jt.empty(), 0);
  }
  static newFoundDocument(t, n, e) {
    return new kt(t, 1, n, e, 0);
  }
  static newNoDocument(t, n) {
    return new kt(t, 2, n, jt.empty(), 0);
  }
  static newUnknownDocument(t, n) {
    return new kt(t, 3, n, jt.empty(), 2);
  }
  convertToFoundDocument(t, n) {
    return this.version = t, this.documentType = 1, this.data = n, this.documentState = 0, this;
  }
  convertToNoDocument(t) {
    return this.version = t, this.documentType = 2, this.data = jt.empty(), this.documentState = 0, this;
  }
  convertToUnknownDocument(t) {
    return this.version = t, this.documentType = 3, this.data = jt.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this;
  }
  get hasLocalMutations() {
    return this.documentState === 1;
  }
  get hasCommittedMutations() {
    return this.documentState === 2;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return this.documentType !== 0;
  }
  isFoundDocument() {
    return this.documentType === 1;
  }
  isNoDocument() {
    return this.documentType === 2;
  }
  isUnknownDocument() {
    return this.documentType === 3;
  }
  isEqual(t) {
    return t instanceof kt && this.key.isEqual(t.key) && this.version.isEqual(t.version) && this.documentType === t.documentType && this.documentState === t.documentState && this.data.isEqual(t.data);
  }
  clone() {
    return new kt(this.key, this.documentType, this.version, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
};
var Mt = class {
  constructor(t, n = null, e = [], r = [], s = null, i = null, o = null) {
    this.path = t, this.collectionGroup = n, this.orderBy = e, this.filters = r, this.limit = s, this.startAt = i, this.endAt = o, this.P = null;
  }
};
function Bt(t, n = null, e = [], r = [], s = null, i = null, o = null) {
  return new Mt(t, n, e, r, s, i, o);
}
var Qt = class extends class {
} {
  constructor(t, n, e) {
    super(), this.field = t, this.op = n, this.value = e;
  }
  static create(t, n, e) {
    return t.isKeyField() ? n === "in" || n === "not-in" ? this.R(t, n, e) : new zt(t, n, e) : n === "array-contains" ? new Yt(t, e) : n === "in" ? new Kt(t, e) : n === "not-in" ? new Jt(t, e) : n === "array-contains-any" ? new Zt(t, e) : new Qt(t, n, e);
  }
  static R(t, n, e) {
    return n === "in" ? new Wt(t, e) : new Gt(t, e);
  }
  matches(t) {
    const n = t.data.field(this.field);
    return this.op === "!=" ? n !== null && this.V(Ft(n, this.value)) : n !== null && Nt(this.value) === Nt(n) && this.V(Ft(n, this.value));
  }
  V(t) {
    switch (this.op) {
      case "<":
        return t < 0;
      case "<=":
        return t <= 0;
      case "==":
        return t === 0;
      case "!=":
        return t !== 0;
      case ">":
        return t > 0;
      case ">=":
        return t >= 0;
      default:
        return _();
    }
  }
  N() {
    return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0;
  }
};
var zt = class extends Qt {
  constructor(t, n, e) {
    super(t, n, e), this.key = Z.fromName(e.referenceValue);
  }
  matches(t) {
    const n = Z.comparator(t.key, this.key);
    return this.V(n);
  }
};
var Wt = class extends Qt {
  constructor(t, n) {
    super(t, "in", n), this.keys = Ht("in", n);
  }
  matches(t) {
    return this.keys.some((n) => n.isEqual(t.key));
  }
};
var Gt = class extends Qt {
  constructor(t, n) {
    super(t, "not-in", n), this.keys = Ht("not-in", n);
  }
  matches(t) {
    return !this.keys.some((n) => n.isEqual(t.key));
  }
};
function Ht(t, n) {
  var e;
  return (((e = n.arrayValue) === null || e === void 0 ? void 0 : e.values) || []).map((t2) => Z.fromName(t2.referenceValue));
}
var Yt = class extends Qt {
  constructor(t, n) {
    super(t, "array-contains", n);
  }
  matches(t) {
    const n = t.data.field(this.field);
    return xt(n) && $t(n.arrayValue, this.value);
  }
};
var Kt = class extends Qt {
  constructor(t, n) {
    super(t, "in", n);
  }
  matches(t) {
    const n = t.data.field(this.field);
    return n !== null && $t(this.value.arrayValue, n);
  }
};
var Jt = class extends Qt {
  constructor(t, n) {
    super(t, "not-in", n);
  }
  matches(t) {
    if ($t(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    }))
      return false;
    const n = t.data.field(this.field);
    return n !== null && !$t(this.value.arrayValue, n);
  }
};
var Zt = class extends Qt {
  constructor(t, n) {
    super(t, "array-contains-any", n);
  }
  matches(t) {
    const n = t.data.field(this.field);
    return !(!xt(n) || !n.arrayValue.values) && n.arrayValue.values.some((t2) => $t(this.value.arrayValue, t2));
  }
};
var Xt = class {
  constructor(t, n) {
    this.position = t, this.before = n;
  }
};
var tn = class {
  constructor(t, n = "asc") {
    this.field = t, this.dir = n;
  }
};
function nn(t, n) {
  return t.dir === n.dir && t.field.isEqual(n.field);
}
function en(t, n) {
  if (t === null)
    return n === null;
  if (n === null)
    return false;
  if (t.before !== n.before || t.position.length !== n.position.length)
    return false;
  for (let e = 0; e < t.position.length; e++) {
    if (!Dt(t.position[e], n.position[e]))
      return false;
  }
  return true;
}
var rn = class {
  constructor(t, n = null, e = [], r = [], s = null, i = "F", o = null, u = null) {
    this.path = t, this.collectionGroup = n, this.explicitOrderBy = e, this.filters = r, this.limit = s, this.limitType = i, this.startAt = o, this.endAt = u, this.D = null, this.$ = null, this.startAt, this.endAt;
  }
};
function sn(t) {
  return !it(t.limit) && t.limitType === "L";
}
function on(t) {
  return t.explicitOrderBy.length > 0 ? t.explicitOrderBy[0].field : null;
}
function un(t) {
  for (const n of t.filters)
    if (n.N())
      return n.field;
  return null;
}
function cn(t) {
  return t.collectionGroup !== null;
}
function an(t) {
  const n = b(t);
  if (n.D === null) {
    n.D = [];
    const t2 = un(n), e = on(n);
    if (t2 !== null && e === null)
      t2.isKeyField() || n.D.push(new tn(t2)), n.D.push(new tn(J.keyField(), "asc"));
    else {
      let t3 = false;
      for (const e2 of n.explicitOrderBy)
        n.D.push(e2), e2.field.isKeyField() && (t3 = true);
      if (!t3) {
        const t4 = n.explicitOrderBy.length > 0 ? n.explicitOrderBy[n.explicitOrderBy.length - 1].dir : "asc";
        n.D.push(new tn(J.keyField(), t4));
      }
    }
  }
  return n.D;
}
function hn(t) {
  const n = b(t);
  if (!n.$)
    if (n.limitType === "F")
      n.$ = Bt(n.path, n.collectionGroup, an(n), n.filters, n.limit, n.startAt, n.endAt);
    else {
      const t2 = [];
      for (const e2 of an(n)) {
        const n2 = e2.dir === "desc" ? "asc" : "desc";
        t2.push(new tn(e2.field, n2));
      }
      const e = n.endAt ? new Xt(n.endAt.position, !n.endAt.before) : null, r = n.startAt ? new Xt(n.startAt.position, !n.startAt.before) : null;
      n.$ = Bt(n.path, n.collectionGroup, t2, n.filters, n.limit, e, r);
    }
  return n.$;
}
function ln(t, n) {
  return function(t2, n2) {
    if (t2.limit !== n2.limit)
      return false;
    if (t2.orderBy.length !== n2.orderBy.length)
      return false;
    for (let e2 = 0; e2 < t2.orderBy.length; e2++)
      if (!nn(t2.orderBy[e2], n2.orderBy[e2]))
        return false;
    if (t2.filters.length !== n2.filters.length)
      return false;
    for (let s = 0; s < t2.filters.length; s++)
      if (e = t2.filters[s], r = n2.filters[s], e.op !== r.op || !e.field.isEqual(r.field) || !Dt(e.value, r.value))
        return false;
    var e, r;
    return t2.collectionGroup === n2.collectionGroup && !!t2.path.isEqual(n2.path) && !!en(t2.startAt, n2.startAt) && en(t2.endAt, n2.endAt);
  }(hn(t), hn(n)) && t.limitType === n.limitType;
}
function fn(t, n) {
  return function(t2) {
    return typeof t2 == "number" && Number.isInteger(t2) && !ot(t2) && t2 <= Number.MAX_SAFE_INTEGER && t2 >= Number.MIN_SAFE_INTEGER;
  }(n) ? function(t2) {
    return {
      integerValue: "" + t2
    };
  }(n) : function(t2, n2) {
    if (t2.F) {
      if (isNaN(n2))
        return {
          doubleValue: "NaN"
        };
      if (n2 === 1 / 0)
        return {
          doubleValue: "Infinity"
        };
      if (n2 === -1 / 0)
        return {
          doubleValue: "-Infinity"
        };
    }
    return {
      doubleValue: ot(n2) ? "-0" : n2
    };
  }(t, n);
}
var dn = class {
  constructor() {
    this._ = void 0;
  }
};
var wn = class extends dn {
};
var mn = class extends dn {
  constructor(t) {
    super(), this.elements = t;
  }
};
var pn = class extends dn {
  constructor(t) {
    super(), this.elements = t;
  }
};
var yn = class extends dn {
  constructor(t, n) {
    super(), this.S = t, this.q = n;
  }
};
var _n = class {
  constructor(t, n) {
    this.field = t, this.transform = n;
  }
};
var gn = class {
  constructor(t, n) {
    this.updateTime = t, this.exists = n;
  }
  static none() {
    return new gn();
  }
  static exists(t) {
    return new gn(void 0, t);
  }
  static updateTime(t) {
    return new gn(t);
  }
  get isNone() {
    return this.updateTime === void 0 && this.exists === void 0;
  }
  isEqual(t) {
    return this.exists === t.exists && (this.updateTime ? !!t.updateTime && this.updateTime.isEqual(t.updateTime) : !t.updateTime);
  }
};
var bn = class {
};
var vn = class extends bn {
  constructor(t, n, e, r = []) {
    super(), this.key = t, this.value = n, this.precondition = e, this.fieldTransforms = r, this.type = 0;
  }
};
var En = class extends bn {
  constructor(t, n, e, r, s = []) {
    super(), this.key = t, this.data = n, this.fieldMask = e, this.precondition = r, this.fieldTransforms = s, this.type = 1;
  }
};
var In = class extends bn {
  constructor(t, n) {
    super(), this.key = t, this.precondition = n, this.type = 2, this.fieldTransforms = [];
  }
};
var Tn = class extends bn {
  constructor(t, n) {
    super(), this.key = t, this.precondition = n, this.type = 3, this.fieldTransforms = [];
  }
};
var An = (() => {
  const t = {
    asc: "ASCENDING",
    desc: "DESCENDING"
  };
  return t;
})();
var Pn = (() => {
  const t = {
    "<": "LESS_THAN",
    "<=": "LESS_THAN_OR_EQUAL",
    ">": "GREATER_THAN",
    ">=": "GREATER_THAN_OR_EQUAL",
    "==": "EQUAL",
    "!=": "NOT_EQUAL",
    "array-contains": "ARRAY_CONTAINS",
    in: "IN",
    "not-in": "NOT_IN",
    "array-contains-any": "ARRAY_CONTAINS_ANY"
  };
  return t;
})();
var Rn = class {
  constructor(t, n) {
    this.databaseId = t, this.F = n;
  }
};
function Vn(t, n) {
  if (t.F) {
    return `${new Date(1e3 * n.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + n.nanoseconds).slice(-9)}Z`;
  }
  return {
    seconds: "" + n.seconds,
    nanos: n.nanoseconds
  };
}
function Nn(t, n) {
  return t.F ? n.toBase64() : n.toUint8Array();
}
function Dn(t, n) {
  return Vn(t, n.toTimestamp());
}
function $n(t) {
  return g(!!t), yt.fromTimestamp(function(t2) {
    const n = It(t2);
    return new pt(n.seconds, n.nanos);
  }(t));
}
function Fn(t, n) {
  return function(t2) {
    return new Y(["projects", t2.projectId, "databases", t2.database]);
  }(t).child("documents").child(n).canonicalString();
}
function Sn(t, n) {
  return Fn(t.databaseId, n.path);
}
function qn(t, n) {
  const e = function(t2) {
    const n2 = Y.fromString(t2);
    return g(Wn(n2)), n2;
  }(n);
  if (e.get(1) !== t.databaseId.projectId)
    throw new L(T, "Tried to deserialize key from different project: " + e.get(1) + " vs " + t.databaseId.projectId);
  if (e.get(3) !== t.databaseId.database)
    throw new L(T, "Tried to deserialize key from different database: " + e.get(3) + " vs " + t.databaseId.database);
  return new Z((g((r = e).length > 4 && r.get(4) === "documents"), r.popFirst(5)));
  var r;
}
function xn(t, n) {
  return Fn(t.databaseId, n);
}
function On(t) {
  return new Y(["projects", t.databaseId.projectId, "databases", t.databaseId.database]).canonicalString();
}
function Cn(t, n, e) {
  return {
    name: Sn(t, n),
    fields: e.value.mapValue.fields
  };
}
function Ln(t, n) {
  return "found" in n ? function(t2, n2) {
    g(!!n2.found), n2.found.name, n2.found.updateTime;
    const e = qn(t2, n2.found.name), r = $n(n2.found.updateTime), s = new jt({
      mapValue: {
        fields: n2.found.fields
      }
    });
    return kt.newFoundDocument(e, r, s);
  }(t, n) : "missing" in n ? function(t2, n2) {
    g(!!n2.missing), g(!!n2.readTime);
    const e = qn(t2, n2.missing), r = $n(n2.readTime);
    return kt.newNoDocument(e, r);
  }(t, n) : _();
}
function Un(t, n) {
  let e;
  if (n instanceof vn)
    e = {
      update: Cn(t, n.key, n.value)
    };
  else if (n instanceof In)
    e = {
      delete: Sn(t, n.key)
    };
  else if (n instanceof En)
    e = {
      update: Cn(t, n.key, n.data),
      updateMask: zn(n.fieldMask)
    };
  else {
    if (!(n instanceof Tn))
      return _();
    e = {
      verify: Sn(t, n.key)
    };
  }
  return n.fieldTransforms.length > 0 && (e.updateTransforms = n.fieldTransforms.map((t2) => function(t3, n2) {
    const e2 = n2.transform;
    if (e2 instanceof wn)
      return {
        fieldPath: n2.field.canonicalString(),
        setToServerValue: "REQUEST_TIME"
      };
    if (e2 instanceof mn)
      return {
        fieldPath: n2.field.canonicalString(),
        appendMissingElements: {
          values: e2.elements
        }
      };
    if (e2 instanceof pn)
      return {
        fieldPath: n2.field.canonicalString(),
        removeAllFromArray: {
          values: e2.elements
        }
      };
    if (e2 instanceof yn)
      return {
        fieldPath: n2.field.canonicalString(),
        increment: e2.q
      };
    throw _();
  }(0, t2))), n.precondition.isNone || (e.currentDocument = function(t2, n2) {
    return n2.updateTime !== void 0 ? {
      updateTime: Dn(t2, n2.updateTime)
    } : n2.exists !== void 0 ? {
      exists: n2.exists
    } : _();
  }(t, n.precondition)), e;
}
function jn(t, n) {
  const e = {
    structuredQuery: {}
  }, r = n.path;
  n.collectionGroup !== null ? (e.parent = xn(t, r), e.structuredQuery.from = [{
    collectionId: n.collectionGroup,
    allDescendants: true
  }]) : (e.parent = xn(t, r.popLast()), e.structuredQuery.from = [{
    collectionId: r.lastSegment()
  }]);
  const s = function(t2) {
    if (t2.length === 0)
      return;
    const n2 = t2.map((t3) => function(t4) {
      if (t4.op === "==") {
        if (Ct(t4.value))
          return {
            unaryFilter: {
              field: Qn(t4.field),
              op: "IS_NAN"
            }
          };
        if (Ot(t4.value))
          return {
            unaryFilter: {
              field: Qn(t4.field),
              op: "IS_NULL"
            }
          };
      } else if (t4.op === "!=") {
        if (Ct(t4.value))
          return {
            unaryFilter: {
              field: Qn(t4.field),
              op: "IS_NOT_NAN"
            }
          };
        if (Ot(t4.value))
          return {
            unaryFilter: {
              field: Qn(t4.field),
              op: "IS_NOT_NULL"
            }
          };
      }
      return {
        fieldFilter: {
          field: Qn(t4.field),
          op: Bn(t4.op),
          value: t4.value
        }
      };
    }(t3));
    if (n2.length === 1)
      return n2[0];
    return {
      compositeFilter: {
        op: "AND",
        filters: n2
      }
    };
  }(n.filters);
  s && (e.structuredQuery.where = s);
  const i = function(t2) {
    if (t2.length === 0)
      return;
    return t2.map((t3) => function(t4) {
      return {
        field: Qn(t4.field),
        direction: Mn(t4.dir)
      };
    }(t3));
  }(n.orderBy);
  i && (e.structuredQuery.orderBy = i);
  const o = function(t2, n2) {
    return t2.F || it(n2) ? n2 : {
      value: n2
    };
  }(t, n.limit);
  return o !== null && (e.structuredQuery.limit = o), n.startAt && (e.structuredQuery.startAt = kn(n.startAt)), n.endAt && (e.structuredQuery.endAt = kn(n.endAt)), e;
}
function kn(t) {
  return {
    before: t.before,
    values: t.position
  };
}
function Mn(t) {
  return An[t];
}
function Bn(t) {
  return Pn[t];
}
function Qn(t) {
  return {
    fieldPath: t.canonicalString()
  };
}
function zn(t) {
  const n = [];
  return t.fields.forEach((t2) => n.push(t2.canonicalString())), {
    fieldPaths: n
  };
}
function Wn(t) {
  return t.length >= 4 && t.get(0) === "projects" && t.get(2) === "databases";
}
function Gn(t) {
  return new Rn(t, true);
}
var Hn = class {
  constructor(t, n, e = 1e3, r = 1.5, s = 6e4) {
    this.O = t, this.timerId = n, this.C = e, this.L = r, this.U = s, this.j = 0, this.k = null, this.M = Date.now(), this.reset();
  }
  reset() {
    this.j = 0;
  }
  B() {
    this.j = this.U;
  }
  W(t) {
    this.cancel();
    const n = Math.floor(this.j + this.G()), e = Math.max(0, Date.now() - this.M), r = Math.max(0, n - e);
    r > 0 && w("ExponentialBackoff", `Backing off for ${r} ms (base delay: ${this.j} ms, delay with jitter: ${n} ms, last attempt: ${e} ms ago)`), this.k = this.O.enqueueAfterDelay(this.timerId, r, () => (this.M = Date.now(), t())), this.j *= this.L, this.j < this.C && (this.j = this.C), this.j > this.U && (this.j = this.U);
  }
  H() {
    this.k !== null && (this.k.skipDelay(), this.k = null);
  }
  cancel() {
    this.k !== null && (this.k.cancel(), this.k = null);
  }
  G() {
    return (Math.random() - 0.5) * this.j;
  }
};
var Yn = class extends class {
} {
  constructor(t, n, e) {
    super(), this.credentials = t, this.Y = n, this.S = e, this.K = false;
  }
  J() {
    if (this.K)
      throw new L($, "The client has already been terminated.");
  }
  l(t, n, e) {
    return this.J(), this.credentials.getToken().then((r) => this.Y.l(t, n, e, r)).catch((t2) => {
      throw t2.name === "FirebaseError" ? (t2.code === N && this.credentials.invalidateToken(), t2) : new L(I, t2.toString());
    });
  }
  v(t, n, e) {
    return this.J(), this.credentials.getToken().then((r) => this.Y.v(t, n, e, r)).catch((t2) => {
      throw t2.name === "FirebaseError" ? (t2.code === N && this.credentials.invalidateToken(), t2) : new L(I, t2.toString());
    });
  }
  terminate() {
    this.K = true;
  }
};
async function Kn(t, n) {
  const e = b(t), r = On(e.S) + "/documents", s = {
    writes: n.map((t2) => Un(e.S, t2))
  };
  await e.l("Commit", r, s);
}
async function Jn(t, n) {
  const e = b(t), r = On(e.S) + "/documents", s = {
    documents: n.map((t2) => Sn(e.S, t2))
  }, i = await e.v("BatchGetDocuments", r, s), o = new Map();
  i.forEach((t2) => {
    const n2 = Ln(e.S, t2);
    o.set(n2.key.toString(), n2);
  });
  const u = [];
  return n.forEach((t2) => {
    const n2 = o.get(t2.toString());
    g(!!n2), u.push(n2);
  }), u;
}
async function Zn(t, n) {
  const e = b(t), r = jn(e.S, hn(n));
  return (await e.v("RunQuery", r.parent, {
    structuredQuery: r.structuredQuery
  })).filter((t2) => !!t2.document).map((t2) => function(t3, n2, e2) {
    const r2 = qn(t3, n2.name), s = $n(n2.updateTime), i = new jt({
      mapValue: {
        fields: n2.fields
      }
    }), o = kt.newFoundDocument(r2, s, i);
    return e2 && o.setHasCommittedMutations(), e2 ? o.setHasCommittedMutations() : o;
  }(e.S, t2.document, void 0));
}
var Xn = new Map();
function te(t) {
  if (t._terminated)
    throw new L($, "The client has already been terminated.");
  if (!Xn.has(t)) {
    w("ComponentProvider", "Initializing Datastore");
    const i = function(t2) {
      return new lt(t2, fetch.bind(null));
    }((n = t._databaseId, e = t.app.options.appId || "", r = t._persistenceKey, s = t._freezeSettings(), new W(n, e, r, s.host, s.ssl, s.experimentalForceLongPolling, s.experimentalAutoDetectLongPolling, s.useFetchStreams))), o = Gn(t._databaseId), u = function(t2, n2, e2) {
      return new Yn(t2, n2, e2);
    }(t._credentials, i, o);
    Xn.set(t, u);
  }
  var n, e, r, s;
  return Xn.get(t);
}
var ne = class {
  constructor(t) {
    var n;
    if (t.host === void 0) {
      if (t.ssl !== void 0)
        throw new L(T, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = true;
    } else
      this.host = t.host, this.ssl = (n = t.ssl) === null || n === void 0 || n;
    if (this.credentials = t.credentials, this.ignoreUndefinedProperties = !!t.ignoreUndefinedProperties, t.cacheSizeBytes === void 0)
      this.cacheSizeBytes = 41943040;
    else {
      if (t.cacheSizeBytes !== -1 && t.cacheSizeBytes < 1048576)
        throw new L(T, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = t.cacheSizeBytes;
    }
    this.experimentalForceLongPolling = !!t.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!t.experimentalAutoDetectLongPolling, this.useFetchStreams = !!t.useFetchStreams, function(t2, n2, e, r) {
      if (n2 === true && r === true)
        throw new L(T, `${t2} and ${e} cannot be used together.`);
    }("experimentalForceLongPolling", t.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t.experimentalAutoDetectLongPolling);
  }
  isEqual(t) {
    return this.host === t.host && this.ssl === t.ssl && this.credentials === t.credentials && this.cacheSizeBytes === t.cacheSizeBytes && this.experimentalForceLongPolling === t.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === t.ignoreUndefinedProperties && this.useFetchStreams === t.useFetchStreams;
  }
};
var ee = class {
  constructor(t, n) {
    this._credentials = n, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new ne({}), this._settingsFrozen = false, t instanceof G ? this._databaseId = t : (this._app = t, this._databaseId = function(t2) {
      if (!Object.prototype.hasOwnProperty.apply(t2.options, ["projectId"]))
        throw new L(T, '"projectId" not provided in firebase.initializeApp.');
      return new G(t2.options.projectId);
    }(t));
  }
  get app() {
    if (!this._app)
      throw new L($, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return this._terminateTask !== void 0;
  }
  _setSettings(t) {
    if (this._settingsFrozen)
      throw new L($, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new ne(t), t.credentials !== void 0 && (this._credentials = function(t2) {
      if (!t2)
        return new k();
      switch (t2.type) {
        case "gapi":
          const n = t2.client;
          return g(!(typeof n != "object" || n === null || !n.auth || !n.auth.getAuthHeaderValueForFirstParty)), new z(n, t2.sessionIndex || "0", t2.iamToken || null);
        case "provider":
          return t2.client;
        default:
          throw new L(T, "makeCredentialsProvider failed due to invalid credential type");
      }
    }(t.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = true, this._settings;
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
  }
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  _terminate() {
    return function(t) {
      const n = Xn.get(t);
      n && (w("ComponentProvider", "Removing Datastore"), Xn.delete(t), n.terminate());
    }(this), Promise.resolve();
  }
};
function re(t, n) {
  const e = _getProvider(t, "firestore/lite");
  if (e.isInitialized())
    throw new L($, "Firestore can only be initialized once per app.");
  return e.initialize({
    options: n
  });
}
function se(n = getApp()) {
  return _getProvider(n, "firestore/lite").getImmediate();
}
function ie(t, n, e, r = {}) {
  var s;
  const i = (t = rt(t, ee))._getSettings();
  if (i.host !== "firestore.googleapis.com" && i.host !== n && p("Host has been set in both settings() and useEmulator(), emulator host will be used"), t._setSettings(Object.assign(Object.assign({}, i), {
    host: `${n}:${e}`,
    ssl: false
  })), r.mockUserToken) {
    let n2, e2;
    if (typeof r.mockUserToken == "string")
      n2 = r.mockUserToken, e2 = h.MOCK_USER;
    else {
      n2 = createMockUserToken(r.mockUserToken, (s = t._app) === null || s === void 0 ? void 0 : s.options.projectId);
      const i2 = r.mockUserToken.sub || r.mockUserToken.user_id;
      if (!i2)
        throw new L(T, "mockUserToken must contain 'sub' or 'user_id' field!");
      e2 = new h(i2);
    }
    t._credentials = new M(new j(n2, e2));
  }
}
function oe(t) {
  return t = rt(t, ee), _removeServiceInstance(t.app, "firestore/lite"), t._delete();
}
var ue = class {
  constructor(t, n, e) {
    this.converter = n, this._key = e, this.type = "document", this.firestore = t;
  }
  get _path() {
    return this._key.path;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get path() {
    return this._key.path.canonicalString();
  }
  get parent() {
    return new ae(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(t) {
    return new ue(this.firestore, t, this._key);
  }
};
var ce = class {
  constructor(t, n, e) {
    this.converter = n, this._query = e, this.type = "query", this.firestore = t;
  }
  withConverter(t) {
    return new ce(this.firestore, t, this._query);
  }
};
var ae = class extends ce {
  constructor(t, n, e) {
    super(t, n, new rn(e)), this._path = e, this.type = "collection";
  }
  get id() {
    return this._query.path.lastSegment();
  }
  get path() {
    return this._query.path.canonicalString();
  }
  get parent() {
    const t = this._path.popLast();
    return t.isEmpty() ? null : new ue(this.firestore, null, new Z(t));
  }
  withConverter(t) {
    return new ae(this.firestore, t, this._path);
  }
};
function he(t, n, ...e) {
  if (t = getModularInstance(t), X("collection", "path", n), t instanceof ee) {
    const r = Y.fromString(n, ...e);
    return nt(r), new ae(t, null, r);
  }
  {
    if (!(t instanceof ue || t instanceof ae))
      throw new L(T, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const r = t._path.child(Y.fromString(n, ...e));
    return nt(r), new ae(t.firestore, null, r);
  }
}
function le(t, n) {
  if (t = rt(t, ee), X("collectionGroup", "collection id", n), n.indexOf("/") >= 0)
    throw new L(T, `Invalid collection ID '${n}' passed to function collectionGroup(). Collection IDs must not contain '/'.`);
  return new ce(t, null, function(t2) {
    return new rn(Y.emptyPath(), t2);
  }(n));
}
function fe(t, n, ...e) {
  if (t = getModularInstance(t), arguments.length === 1 && (n = dt.A()), X("doc", "path", n), t instanceof ee) {
    const r = Y.fromString(n, ...e);
    return tt(r), new ue(t, null, new Z(r));
  }
  {
    if (!(t instanceof ue || t instanceof ae))
      throw new L(T, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const r = t._path.child(Y.fromString(n, ...e));
    return tt(r), new ue(t.firestore, t instanceof ae ? t.converter : null, new Z(r));
  }
}
function de(t, n) {
  return t = getModularInstance(t), n = getModularInstance(n), (t instanceof ue || t instanceof ae) && (n instanceof ue || n instanceof ae) && (t.firestore === n.firestore && t.path === n.path && t.converter === n.converter);
}
function we(t, n) {
  return t = getModularInstance(t), n = getModularInstance(n), t instanceof ce && n instanceof ce && (t.firestore === n.firestore && ln(t._query, n._query) && t.converter === n.converter);
}
var me = class {
  constructor(...t) {
    for (let n = 0; n < t.length; ++n)
      if (t[n].length === 0)
        throw new L(T, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new J(t);
  }
  isEqual(t) {
    return this._internalPath.isEqual(t._internalPath);
  }
};
function pe() {
  return new me("__name__");
}
var ye = class {
  constructor(t) {
    this._byteString = t;
  }
  static fromBase64String(t) {
    try {
      return new ye(vt.fromBase64String(t));
    } catch (t2) {
      throw new L(T, "Failed to construct data from Base64 string: " + t2);
    }
  }
  static fromUint8Array(t) {
    return new ye(vt.fromUint8Array(t));
  }
  toBase64() {
    return this._byteString.toBase64();
  }
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  isEqual(t) {
    return this._byteString.isEqual(t._byteString);
  }
};
var _e = class {
  constructor(t) {
    this._methodName = t;
  }
};
var ge = class {
  constructor(t, n) {
    if (!isFinite(t) || t < -90 || t > 90)
      throw new L(T, "Latitude must be a number between -90 and 90, but was: " + t);
    if (!isFinite(n) || n < -180 || n > 180)
      throw new L(T, "Longitude must be a number between -180 and 180, but was: " + n);
    this._lat = t, this._long = n;
  }
  get latitude() {
    return this._lat;
  }
  get longitude() {
    return this._long;
  }
  isEqual(t) {
    return this._lat === t._lat && this._long === t._long;
  }
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long
    };
  }
  _compareTo(t) {
    return wt(this._lat, t._lat) || wt(this._long, t._long);
  }
};
var be = /^__.*__$/;
var ve = class {
  constructor(t, n, e) {
    this.data = t, this.fieldMask = n, this.fieldTransforms = e;
  }
  toMutation(t, n) {
    return this.fieldMask !== null ? new En(t, this.data, this.fieldMask, n, this.fieldTransforms) : new vn(t, this.data, n, this.fieldTransforms);
  }
};
var Ee = class {
  constructor(t, n, e) {
    this.data = t, this.fieldMask = n, this.fieldTransforms = e;
  }
  toMutation(t, n) {
    return new En(t, this.data, this.fieldMask, n, this.fieldTransforms);
  }
};
function Ie(t) {
  switch (t) {
    case 0:
    case 2:
    case 1:
      return true;
    case 3:
    case 4:
      return false;
    default:
      throw _();
  }
}
var Te = class {
  constructor(t, n, e, r, s, i) {
    this.settings = t, this.databaseId = n, this.S = e, this.ignoreUndefinedProperties = r, s === void 0 && this.Z(), this.fieldTransforms = s || [], this.fieldMask = i || [];
  }
  get path() {
    return this.settings.path;
  }
  get X() {
    return this.settings.X;
  }
  tt(t) {
    return new Te(Object.assign(Object.assign({}, this.settings), t), this.databaseId, this.S, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  nt(t) {
    var n;
    const e = (n = this.path) === null || n === void 0 ? void 0 : n.child(t), r = this.tt({
      path: e,
      et: false
    });
    return r.rt(t), r;
  }
  st(t) {
    var n;
    const e = (n = this.path) === null || n === void 0 ? void 0 : n.child(t), r = this.tt({
      path: e,
      et: false
    });
    return r.Z(), r;
  }
  it(t) {
    return this.tt({
      path: void 0,
      et: true
    });
  }
  ot(t) {
    return Qe(t, this.settings.methodName, this.settings.ut || false, this.path, this.settings.ct);
  }
  contains(t) {
    return this.fieldMask.find((n) => t.isPrefixOf(n)) !== void 0 || this.fieldTransforms.find((n) => t.isPrefixOf(n.field)) !== void 0;
  }
  Z() {
    if (this.path)
      for (let t = 0; t < this.path.length; t++)
        this.rt(this.path.get(t));
  }
  rt(t) {
    if (t.length === 0)
      throw this.ot("Document fields must not be empty");
    if (Ie(this.X) && be.test(t))
      throw this.ot('Document fields cannot begin and end with "__"');
  }
};
var Ae = class {
  constructor(t, n, e) {
    this.databaseId = t, this.ignoreUndefinedProperties = n, this.S = e || Gn(t);
  }
  at(t, n, e, r = false) {
    return new Te({
      X: t,
      methodName: n,
      ct: e,
      path: J.emptyPath(),
      et: false,
      ut: r
    }, this.databaseId, this.S, this.ignoreUndefinedProperties);
  }
};
function Pe(t) {
  const n = t._freezeSettings(), e = Gn(t._databaseId);
  return new Ae(t._databaseId, !!n.ignoreUndefinedProperties, e);
}
function Re(t, n, e, r, s, i = {}) {
  const o = t.at(i.merge || i.mergeFields ? 2 : 0, n, e, s);
  je("Data must be an object, but it was:", o, r);
  const u = Le(r, o);
  let c, a;
  if (i.merge)
    c = new bt(o.fieldMask), a = o.fieldTransforms;
  else if (i.mergeFields) {
    const t2 = [];
    for (const r2 of i.mergeFields) {
      const s2 = ke(n, r2, e);
      if (!o.contains(s2))
        throw new L(T, `Field '${s2}' is specified in your field mask but missing from your input data.`);
      ze(t2, s2) || t2.push(s2);
    }
    c = new bt(t2), a = o.fieldTransforms.filter((t3) => c.covers(t3.field));
  } else
    c = null, a = o.fieldTransforms;
  return new ve(new jt(u), c, a);
}
var Ve = class extends _e {
  _toFieldTransform(t) {
    if (t.X !== 2)
      throw t.X === 1 ? t.ot(`${this._methodName}() can only appear at the top level of your update data`) : t.ot(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    return t.fieldMask.push(t.path), null;
  }
  isEqual(t) {
    return t instanceof Ve;
  }
};
function Ne(t, n, e) {
  return new Te({
    X: 3,
    ct: n.settings.ct,
    methodName: t._methodName,
    et: e
  }, n.databaseId, n.S, n.ignoreUndefinedProperties);
}
var De = class extends _e {
  _toFieldTransform(t) {
    return new _n(t.path, new wn());
  }
  isEqual(t) {
    return t instanceof De;
  }
};
var $e = class extends _e {
  constructor(t, n) {
    super(t), this.ht = n;
  }
  _toFieldTransform(t) {
    const n = Ne(this, t, true), e = this.ht.map((t2) => Ce(t2, n)), r = new mn(e);
    return new _n(t.path, r);
  }
  isEqual(t) {
    return this === t;
  }
};
var Fe = class extends _e {
  constructor(t, n) {
    super(t), this.ht = n;
  }
  _toFieldTransform(t) {
    const n = Ne(this, t, true), e = this.ht.map((t2) => Ce(t2, n)), r = new pn(e);
    return new _n(t.path, r);
  }
  isEqual(t) {
    return this === t;
  }
};
var Se = class extends _e {
  constructor(t, n) {
    super(t), this.lt = n;
  }
  _toFieldTransform(t) {
    const n = new yn(t.S, fn(t.S, this.lt));
    return new _n(t.path, n);
  }
  isEqual(t) {
    return this === t;
  }
};
function qe(t, n, e, r) {
  const s = t.at(1, n, e);
  je("Data must be an object, but it was:", s, r);
  const i = [], o = jt.empty();
  gt(r, (t2, r2) => {
    const u2 = Be(n, t2, e);
    r2 = getModularInstance(r2);
    const c = s.st(u2);
    if (r2 instanceof Ve)
      i.push(u2);
    else {
      const t3 = Ce(r2, c);
      t3 != null && (i.push(u2), o.set(u2, t3));
    }
  });
  const u = new bt(i);
  return new Ee(o, u, s.fieldTransforms);
}
function xe(t, n, e, r, s, i) {
  const o = t.at(1, n, e), u = [ke(n, r, e)], c = [s];
  if (i.length % 2 != 0)
    throw new L(T, `Function ${n}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let t2 = 0; t2 < i.length; t2 += 2)
    u.push(ke(n, i[t2])), c.push(i[t2 + 1]);
  const h2 = [], l2 = jt.empty();
  for (let t2 = u.length - 1; t2 >= 0; --t2)
    if (!ze(h2, u[t2])) {
      const n2 = u[t2];
      let e2 = c[t2];
      e2 = getModularInstance(e2);
      const r2 = o.st(n2);
      if (e2 instanceof Ve)
        h2.push(n2);
      else {
        const t3 = Ce(e2, r2);
        t3 != null && (h2.push(n2), l2.set(n2, t3));
      }
    }
  const f2 = new bt(h2);
  return new Ee(l2, f2, o.fieldTransforms);
}
function Oe(t, n, e, r = false) {
  return Ce(e, t.at(r ? 4 : 3, n));
}
function Ce(t, n) {
  if (Ue(t = getModularInstance(t)))
    return je("Unsupported field value:", n, t), Le(t, n);
  if (t instanceof _e)
    return function(t2, n2) {
      if (!Ie(n2.X))
        throw n2.ot(`${t2._methodName}() can only be used with update() and set()`);
      if (!n2.path)
        throw n2.ot(`${t2._methodName}() is not currently supported inside arrays`);
      const e = t2._toFieldTransform(n2);
      e && n2.fieldTransforms.push(e);
    }(t, n), null;
  if (t === void 0 && n.ignoreUndefinedProperties)
    return null;
  if (n.path && n.fieldMask.push(n.path), t instanceof Array) {
    if (n.settings.et && n.X !== 4)
      throw n.ot("Nested arrays are not supported");
    return function(t2, n2) {
      const e = [];
      let r = 0;
      for (const s of t2) {
        let t3 = Ce(s, n2.it(r));
        t3 == null && (t3 = {
          nullValue: "NULL_VALUE"
        }), e.push(t3), r++;
      }
      return {
        arrayValue: {
          values: e
        }
      };
    }(t, n);
  }
  return function(t2, n2) {
    if ((t2 = getModularInstance(t2)) === null)
      return {
        nullValue: "NULL_VALUE"
      };
    if (typeof t2 == "number")
      return fn(n2.S, t2);
    if (typeof t2 == "boolean")
      return {
        booleanValue: t2
      };
    if (typeof t2 == "string")
      return {
        stringValue: t2
      };
    if (t2 instanceof Date) {
      const e = pt.fromDate(t2);
      return {
        timestampValue: Vn(n2.S, e)
      };
    }
    if (t2 instanceof pt) {
      const e = new pt(t2.seconds, 1e3 * Math.floor(t2.nanoseconds / 1e3));
      return {
        timestampValue: Vn(n2.S, e)
      };
    }
    if (t2 instanceof ge)
      return {
        geoPointValue: {
          latitude: t2.latitude,
          longitude: t2.longitude
        }
      };
    if (t2 instanceof ye)
      return {
        bytesValue: Nn(n2.S, t2._byteString)
      };
    if (t2 instanceof ue) {
      const e = n2.databaseId, r = t2.firestore._databaseId;
      if (!r.isEqual(e))
        throw n2.ot(`Document reference is for database ${r.projectId}/${r.database} but should be for database ${e.projectId}/${e.database}`);
      return {
        referenceValue: Fn(t2.firestore._databaseId || n2.databaseId, t2._key.path)
      };
    }
    throw n2.ot(`Unsupported field value: ${et(t2)}`);
  }(t, n);
}
function Le(t, n) {
  const e = {};
  return !function(t2) {
    for (const n2 in t2)
      if (Object.prototype.hasOwnProperty.call(t2, n2))
        return false;
    return true;
  }(t) ? gt(t, (t2, r) => {
    const s = Ce(r, n.nt(t2));
    s != null && (e[t2] = s);
  }) : n.path && n.path.length > 0 && n.fieldMask.push(n.path), {
    mapValue: {
      fields: e
    }
  };
}
function Ue(t) {
  return !(typeof t != "object" || t === null || t instanceof Array || t instanceof Date || t instanceof pt || t instanceof ge || t instanceof ye || t instanceof ue || t instanceof _e);
}
function je(t, n, e) {
  if (!Ue(e) || !function(t2) {
    return typeof t2 == "object" && t2 !== null && (Object.getPrototypeOf(t2) === Object.prototype || Object.getPrototypeOf(t2) === null);
  }(e)) {
    const r = et(e);
    throw r === "an object" ? n.ot(t + " a custom object") : n.ot(t + " " + r);
  }
}
function ke(t, n, e) {
  if ((n = getModularInstance(n)) instanceof me)
    return n._internalPath;
  if (typeof n == "string")
    return Be(t, n);
  throw Qe("Field path arguments must be of type string or FieldPath.", t, false, void 0, e);
}
var Me = new RegExp("[~\\*/\\[\\]]");
function Be(t, n, e) {
  if (n.search(Me) >= 0)
    throw Qe(`Invalid field path (${n}). Paths must not contain '~', '*', '/', '[', or ']'`, t, false, void 0, e);
  try {
    return new me(...n.split("."))._internalPath;
  } catch (r) {
    throw Qe(`Invalid field path (${n}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, t, false, void 0, e);
  }
}
function Qe(t, n, e, r, s) {
  const i = r && !r.isEmpty(), o = s !== void 0;
  let u = `Function ${n}() called with invalid data`;
  e && (u += " (via `toFirestore()`)"), u += ". ";
  let c = "";
  return (i || o) && (c += " (found", i && (c += ` in field ${r}`), o && (c += ` in document ${s}`), c += ")"), new L(T, u + t + c);
}
function ze(t, n) {
  return t.some((t2) => t2.isEqual(n));
}
var We = class {
  constructor(t, n, e, r, s) {
    this._firestore = t, this._userDataWriter = n, this._key = e, this._document = r, this._converter = s;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get ref() {
    return new ue(this._firestore, this._converter, this._key);
  }
  exists() {
    return this._document !== null;
  }
  data() {
    if (this._document) {
      if (this._converter) {
        const t = new Ge(this._firestore, this._userDataWriter, this._key, this._document, null);
        return this._converter.fromFirestore(t);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  get(t) {
    if (this._document) {
      const n = this._document.data.field(Ke("DocumentSnapshot.get", t));
      if (n !== null)
        return this._userDataWriter.convertValue(n);
    }
  }
};
var Ge = class extends We {
  data() {
    return super.data();
  }
};
var He = class {
  constructor(t, n) {
    this._docs = n, this.query = t;
  }
  get docs() {
    return [...this._docs];
  }
  get size() {
    return this.docs.length;
  }
  get empty() {
    return this.docs.length === 0;
  }
  forEach(t, n) {
    this._docs.forEach(t, n);
  }
};
function Ye(t, n) {
  return t = getModularInstance(t), n = getModularInstance(n), t instanceof We && n instanceof We ? t._firestore === n._firestore && t._key.isEqual(n._key) && (t._document === null ? n._document === null : t._document.isEqual(n._document)) && t._converter === n._converter : t instanceof He && n instanceof He && (we(t.query, n.query) && mt(t.docs, n.docs, Ye));
}
function Ke(t, n) {
  return typeof n == "string" ? Be(t, n) : n instanceof me ? n._internalPath : n._delegate._internalPath;
}
var Je = class {
};
function Ze(t, ...n) {
  for (const e of n)
    t = e._apply(t);
  return t;
}
var Xe = class extends Je {
  constructor(t, n, e) {
    super(), this.ft = t, this.dt = n, this.wt = e, this.type = "where";
  }
  _apply(t) {
    const n = Pe(t.firestore), e = function(t2, n2, e2, r, s, i, o) {
      let u;
      if (s.isKeyField()) {
        if (i === "array-contains" || i === "array-contains-any")
          throw new L(T, `Invalid Query. You can't perform '${i}' queries on FieldPath.documentId().`);
        if (i === "in" || i === "not-in") {
          wr(o, i);
          const n3 = [];
          for (const e3 of o)
            n3.push(dr(r, t2, e3));
          u = {
            arrayValue: {
              values: n3
            }
          };
        } else
          u = dr(r, t2, o);
      } else
        i !== "in" && i !== "not-in" && i !== "array-contains-any" || wr(o, i), u = Oe(e2, n2, o, i === "in" || i === "not-in");
      const c = Qt.create(s, i, u);
      return function(t3, n3) {
        if (n3.N()) {
          const e4 = un(t3);
          if (e4 !== null && !e4.isEqual(n3.field))
            throw new L(T, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${e4.toString()}' and '${n3.field.toString()}'`);
          const r2 = on(t3);
          r2 !== null && mr(t3, n3.field, r2);
        }
        const e3 = function(t4, n4) {
          for (const e4 of t4.filters)
            if (n4.indexOf(e4.op) >= 0)
              return e4.op;
          return null;
        }(t3, function(t4) {
          switch (t4) {
            case "!=":
              return ["!=", "not-in"];
            case "array-contains":
              return ["array-contains", "array-contains-any", "not-in"];
            case "in":
              return ["array-contains-any", "in", "not-in"];
            case "array-contains-any":
              return ["array-contains", "array-contains-any", "in", "not-in"];
            case "not-in":
              return ["array-contains", "array-contains-any", "in", "not-in", "!="];
            default:
              return [];
          }
        }(n3.op));
        if (e3 !== null)
          throw e3 === n3.op ? new L(T, `Invalid query. You cannot use more than one '${n3.op.toString()}' filter.`) : new L(T, `Invalid query. You cannot use '${n3.op.toString()}' filters with '${e3.toString()}' filters.`);
      }(t2, c), c;
    }(t._query, "where", n, t.firestore._databaseId, this.ft, this.dt, this.wt);
    return new ce(t.firestore, t.converter, function(t2, n2) {
      const e2 = t2.filters.concat([n2]);
      return new rn(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), e2, t2.limit, t2.limitType, t2.startAt, t2.endAt);
    }(t._query, e));
  }
};
function tr(t, n, e) {
  const r = n, s = Ke("where", t);
  return new Xe(s, r, e);
}
var nr = class extends Je {
  constructor(t, n) {
    super(), this.ft = t, this.yt = n, this.type = "orderBy";
  }
  _apply(t) {
    const n = function(t2, n2, e) {
      if (t2.startAt !== null)
        throw new L(T, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      if (t2.endAt !== null)
        throw new L(T, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      const r = new tn(n2, e);
      return function(t3, n3) {
        if (on(t3) === null) {
          const e2 = un(t3);
          e2 !== null && mr(t3, e2, n3.field);
        }
      }(t2, r), r;
    }(t._query, this.ft, this.yt);
    return new ce(t.firestore, t.converter, function(t2, n2) {
      const e = t2.explicitOrderBy.concat([n2]);
      return new rn(t2.path, t2.collectionGroup, e, t2.filters.slice(), t2.limit, t2.limitType, t2.startAt, t2.endAt);
    }(t._query, n));
  }
};
function er(t, n = "asc") {
  const e = n, r = Ke("orderBy", t);
  return new nr(r, e);
}
var rr = class extends Je {
  constructor(t, n, e) {
    super(), this.type = t, this._t = n, this.gt = e;
  }
  _apply(t) {
    return new ce(t.firestore, t.converter, function(t2, n, e) {
      return new rn(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), t2.filters.slice(), n, e, t2.startAt, t2.endAt);
    }(t._query, this._t, this.gt));
  }
};
function sr(t) {
  return st("limit", t), new rr("limit", t, "F");
}
function ir(t) {
  return st("limitToLast", t), new rr("limitToLast", t, "L");
}
var or = class extends Je {
  constructor(t, n, e) {
    super(), this.type = t, this.bt = n, this.vt = e;
  }
  _apply(t) {
    const n = fr(t, this.type, this.bt, this.vt);
    return new ce(t.firestore, t.converter, function(t2, n2) {
      return new rn(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), t2.filters.slice(), t2.limit, t2.limitType, n2, t2.endAt);
    }(t._query, n));
  }
};
function ur(...t) {
  return new or("startAt", t, true);
}
function cr(...t) {
  return new or("startAfter", t, false);
}
var ar = class extends Je {
  constructor(t, n, e) {
    super(), this.type = t, this.bt = n, this.vt = e;
  }
  _apply(t) {
    const n = fr(t, this.type, this.bt, this.vt);
    return new ce(t.firestore, t.converter, function(t2, n2) {
      return new rn(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), t2.filters.slice(), t2.limit, t2.limitType, t2.startAt, n2);
    }(t._query, n));
  }
};
function hr(...t) {
  return new ar("endBefore", t, true);
}
function lr(...t) {
  return new ar("endAt", t, false);
}
function fr(t, n, e, r) {
  if (e[0] = getModularInstance(e[0]), e[0] instanceof We)
    return function(t2, n2, e2, r2, s) {
      if (!r2)
        throw new L(P, `Can't use a DocumentSnapshot that doesn't exist for ${e2}().`);
      const i = [];
      for (const e3 of an(t2))
        if (e3.field.isKeyField())
          i.push(qt(n2, r2.key));
        else {
          const t3 = r2.data.field(e3.field);
          if (Pt(t3))
            throw new L(T, 'Invalid query. You are trying to start or end a query using a document for which the field "' + e3.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
          if (t3 === null) {
            const t4 = e3.field.canonicalString();
            throw new L(T, `Invalid query. You are trying to start or end a query using a document for which the field '${t4}' (used as the orderBy) does not exist.`);
          }
          i.push(t3);
        }
      return new Xt(i, s);
    }(t._query, t.firestore._databaseId, n, e[0]._document, r);
  {
    const s = Pe(t.firestore);
    return function(t2, n2, e2, r2, s2, i) {
      const o = t2.explicitOrderBy;
      if (s2.length > o.length)
        throw new L(T, `Too many arguments provided to ${r2}(). The number of arguments must be less than or equal to the number of orderBy() clauses`);
      const u = [];
      for (let i2 = 0; i2 < s2.length; i2++) {
        const c = s2[i2];
        if (o[i2].field.isKeyField()) {
          if (typeof c != "string")
            throw new L(T, `Invalid query. Expected a string for document ID in ${r2}(), but got a ${typeof c}`);
          if (!cn(t2) && c.indexOf("/") !== -1)
            throw new L(T, `Invalid query. When querying a collection and ordering by FieldPath.documentId(), the value passed to ${r2}() must be a plain document ID, but '${c}' contains a slash.`);
          const e3 = t2.path.child(Y.fromString(c));
          if (!Z.isDocumentKey(e3))
            throw new L(T, `Invalid query. When querying a collection group and ordering by FieldPath.documentId(), the value passed to ${r2}() must result in a valid document path, but '${e3}' is not because it contains an odd number of segments.`);
          const s3 = new Z(e3);
          u.push(qt(n2, s3));
        } else {
          const t3 = Oe(e2, r2, c);
          u.push(t3);
        }
      }
      return new Xt(u, i);
    }(t._query, t.firestore._databaseId, s, n, e, r);
  }
}
function dr(t, n, e) {
  if (typeof (e = getModularInstance(e)) == "string") {
    if (e === "")
      throw new L(T, "Invalid query. When querying with FieldPath.documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!cn(n) && e.indexOf("/") !== -1)
      throw new L(T, `Invalid query. When querying a collection by FieldPath.documentId(), you must provide a plain document ID, but '${e}' contains a '/' character.`);
    const r = n.path.child(Y.fromString(e));
    if (!Z.isDocumentKey(r))
      throw new L(T, `Invalid query. When querying a collection group by FieldPath.documentId(), the value provided must result in a valid document path, but '${r}' is not because it has an odd number of segments (${r.length}).`);
    return qt(t, new Z(r));
  }
  if (e instanceof ue)
    return qt(t, e._key);
  throw new L(T, `Invalid query. When querying with FieldPath.documentId(), you must provide a valid string or a DocumentReference, but it was: ${et(e)}.`);
}
function wr(t, n) {
  if (!Array.isArray(t) || t.length === 0)
    throw new L(T, `Invalid Query. A non-empty array is required for '${n.toString()}' filters.`);
  if (t.length > 10)
    throw new L(T, `Invalid Query. '${n.toString()}' filters support a maximum of 10 elements in the value array.`);
}
function mr(t, n, e) {
  if (!e.isEqual(n))
    throw new L(T, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${n.toString()}' and so you must also use '${n.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${e.toString()}' instead.`);
}
function pr(t, n, e) {
  let r;
  return r = t ? e && (e.merge || e.mergeFields) ? t.toFirestore(n, e) : t.toFirestore(n) : n, r;
}
var yr = class extends class {
  convertValue(t, n = "none") {
    switch (Nt(t)) {
      case 0:
        return null;
      case 1:
        return t.booleanValue;
      case 2:
        return Tt(t.integerValue || t.doubleValue);
      case 3:
        return this.convertTimestamp(t.timestampValue);
      case 4:
        return this.convertServerTimestamp(t, n);
      case 5:
        return t.stringValue;
      case 6:
        return this.convertBytes(At(t.bytesValue));
      case 7:
        return this.convertReference(t.referenceValue);
      case 8:
        return this.convertGeoPoint(t.geoPointValue);
      case 9:
        return this.convertArray(t.arrayValue, n);
      case 10:
        return this.convertObject(t.mapValue, n);
      default:
        throw _();
    }
  }
  convertObject(t, n) {
    const e = {};
    return gt(t.fields, (t2, r) => {
      e[t2] = this.convertValue(r, n);
    }), e;
  }
  convertGeoPoint(t) {
    return new ge(Tt(t.latitude), Tt(t.longitude));
  }
  convertArray(t, n) {
    return (t.values || []).map((t2) => this.convertValue(t2, n));
  }
  convertServerTimestamp(t, n) {
    switch (n) {
      case "previous":
        const e = Rt(t);
        return e == null ? null : this.convertValue(e, n);
      case "estimate":
        return this.convertTimestamp(Vt(t));
      default:
        return null;
    }
  }
  convertTimestamp(t) {
    const n = It(t);
    return new pt(n.seconds, n.nanos);
  }
  convertDocumentKey(t, n) {
    const e = Y.fromString(t);
    g(Wn(e));
    const r = new G(e.get(1), e.get(3)), s = new Z(e.popFirst(5));
    return r.isEqual(n) || m(`Document ${s} contains a document reference within a different database (${r.projectId}/${r.database}) which is not supported. It will be treated as a reference in the current database (${n.projectId}/${n.database}) instead.`), s;
  }
} {
  constructor(t) {
    super(), this.firestore = t;
  }
  convertBytes(t) {
    return new ye(t);
  }
  convertReference(t) {
    const n = this.convertDocumentKey(t, this.firestore._databaseId);
    return new ue(this.firestore, null, n);
  }
};
function _r(t) {
  const n = te((t = rt(t, ue)).firestore), e = new yr(t.firestore);
  return Jn(n, [t._key]).then((n2) => {
    g(n2.length === 1);
    const r = n2[0];
    return new We(t.firestore, e, t._key, r.isFoundDocument() ? r : null, t.converter);
  });
}
function gr(t) {
  !function(t2) {
    if (sn(t2) && t2.explicitOrderBy.length === 0)
      throw new L(q, "limitToLast() queries require specifying at least one orderBy() clause");
  }((t = rt(t, ce))._query);
  const n = te(t.firestore), e = new yr(t.firestore);
  return Zn(n, t._query).then((n2) => {
    const r = n2.map((n3) => new Ge(t.firestore, e, n3.key, n3, t.converter));
    return sn(t._query) && r.reverse(), new He(t, r);
  });
}
function br(t, n, e) {
  const r = pr((t = rt(t, ue)).converter, n, e), s = Re(Pe(t.firestore), "setDoc", t._key, r, t.converter !== null, e);
  return Kn(te(t.firestore), [s.toMutation(t._key, gn.none())]);
}
function vr(t, n, e, ...r) {
  const s = Pe((t = rt(t, ue)).firestore);
  let i;
  i = typeof (n = getModularInstance(n)) == "string" || n instanceof me ? xe(s, "updateDoc", t._key, n, e, r) : qe(s, "updateDoc", t._key, n);
  return Kn(te(t.firestore), [i.toMutation(t._key, gn.exists(true))]);
}
function Er(t) {
  return Kn(te((t = rt(t, ue)).firestore), [new In(t._key, gn.none())]);
}
function Ir(t, n) {
  const e = fe(t = rt(t, ae)), r = pr(t.converter, n), s = Re(Pe(t.firestore), "addDoc", e._key, r, e.converter !== null, {});
  return Kn(te(t.firestore), [s.toMutation(e._key, gn.exists(false))]).then(() => e);
}
function Tr() {
  return new Ve("deleteField");
}
function Ar() {
  return new De("serverTimestamp");
}
function Pr(...t) {
  return new $e("arrayUnion", t);
}
function Rr(...t) {
  return new Fe("arrayRemove", t);
}
function Vr(t) {
  return new Se("increment", t);
}
var Nr = class {
  constructor(t, n) {
    this._firestore = t, this._commitHandler = n, this._mutations = [], this._committed = false, this._dataReader = Pe(t);
  }
  set(t, n, e) {
    this._verifyNotCommitted();
    const r = Dr(t, this._firestore), s = pr(r.converter, n, e), i = Re(this._dataReader, "WriteBatch.set", r._key, s, r.converter !== null, e);
    return this._mutations.push(i.toMutation(r._key, gn.none())), this;
  }
  update(t, n, e, ...r) {
    this._verifyNotCommitted();
    const s = Dr(t, this._firestore);
    let i;
    return i = typeof (n = getModularInstance(n)) == "string" || n instanceof me ? xe(this._dataReader, "WriteBatch.update", s._key, n, e, r) : qe(this._dataReader, "WriteBatch.update", s._key, n), this._mutations.push(i.toMutation(s._key, gn.exists(true))), this;
  }
  delete(t) {
    this._verifyNotCommitted();
    const n = Dr(t, this._firestore);
    return this._mutations = this._mutations.concat(new In(n._key, gn.none())), this;
  }
  commit() {
    return this._verifyNotCommitted(), this._committed = true, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();
  }
  _verifyNotCommitted() {
    if (this._committed)
      throw new L($, "A write batch can no longer be used after commit() has been called.");
  }
};
function Dr(t, n) {
  if ((t = getModularInstance(t)).firestore !== n)
    throw new L(T, "Provided document reference is from a different Firestore instance.");
  return t;
}
function $r(t) {
  const n = te(t = rt(t, ee));
  return new Nr(t, (t2) => Kn(n, t2));
}
var Fr = class {
  constructor(t) {
    this.datastore = t, this.readVersions = new Map(), this.mutations = [], this.committed = false, this.lastWriteError = null, this.writtenDocs = new Set();
  }
  async lookup(t) {
    if (this.ensureCommitNotCalled(), this.mutations.length > 0)
      throw new L(T, "Firestore transactions require all reads to be executed before all writes.");
    const n = await Jn(this.datastore, t);
    return n.forEach((t2) => this.recordVersion(t2)), n;
  }
  set(t, n) {
    this.write(n.toMutation(t, this.precondition(t))), this.writtenDocs.add(t.toString());
  }
  update(t, n) {
    try {
      this.write(n.toMutation(t, this.preconditionForUpdate(t)));
    } catch (t2) {
      this.lastWriteError = t2;
    }
    this.writtenDocs.add(t.toString());
  }
  delete(t) {
    this.write(new In(t, this.precondition(t))), this.writtenDocs.add(t.toString());
  }
  async commit() {
    if (this.ensureCommitNotCalled(), this.lastWriteError)
      throw this.lastWriteError;
    const t = this.readVersions;
    this.mutations.forEach((n) => {
      t.delete(n.key.toString());
    }), t.forEach((t2, n) => {
      const e = Z.fromPath(n);
      this.mutations.push(new Tn(e, this.precondition(e)));
    }), await Kn(this.datastore, this.mutations), this.committed = true;
  }
  recordVersion(t) {
    let n;
    if (t.isFoundDocument())
      n = t.version;
    else {
      if (!t.isNoDocument())
        throw _();
      n = yt.min();
    }
    const e = this.readVersions.get(t.key.toString());
    if (e) {
      if (!n.isEqual(e))
        throw new L(F, "Document version changed between two reads.");
    } else
      this.readVersions.set(t.key.toString(), n);
  }
  precondition(t) {
    const n = this.readVersions.get(t.toString());
    return !this.writtenDocs.has(t.toString()) && n ? gn.updateTime(n) : gn.none();
  }
  preconditionForUpdate(t) {
    const n = this.readVersions.get(t.toString());
    if (!this.writtenDocs.has(t.toString()) && n) {
      if (n.isEqual(yt.min()))
        throw new L(T, "Can't update a document that doesn't exist.");
      return gn.updateTime(n);
    }
    return gn.exists(true);
  }
  write(t) {
    this.ensureCommitNotCalled(), this.mutations.push(t);
  }
  ensureCommitNotCalled() {
  }
};
var Sr = class {
  constructor(t, n, e, r) {
    this.asyncQueue = t, this.datastore = n, this.updateFunction = e, this.deferred = r, this.Et = 5, this.It = new Hn(this.asyncQueue, "transaction_retry");
  }
  run() {
    this.Et -= 1, this.Tt();
  }
  Tt() {
    this.It.W(async () => {
      const t = new Fr(this.datastore), n = this.At(t);
      n && n.then((n2) => {
        this.asyncQueue.enqueueAndForget(() => t.commit().then(() => {
          this.deferred.resolve(n2);
        }).catch((t2) => {
          this.Pt(t2);
        }));
      }).catch((t2) => {
        this.Pt(t2);
      });
    });
  }
  At(t) {
    try {
      const n = this.updateFunction(t);
      return !it(n) && n.catch && n.then ? n : (this.deferred.reject(Error("Transaction callback must return a Promise")), null);
    } catch (t2) {
      return this.deferred.reject(t2), null;
    }
  }
  Pt(t) {
    this.Et > 0 && this.Rt(t) ? (this.Et -= 1, this.asyncQueue.enqueueAndForget(() => (this.Tt(), Promise.resolve()))) : this.deferred.reject(t);
  }
  Rt(t) {
    if (t.name === "FirebaseError") {
      const n = t.code;
      return n === "aborted" || n === "failed-precondition" || !function(t2) {
        switch (t2) {
          case v:
            return _();
          case E:
          case I:
          case A:
          case D:
          case x:
          case O:
          case N:
            return false;
          case T:
          case P:
          case R:
          case V:
          case $:
          case F:
          case S:
          case q:
          case C:
            return true;
          default:
            return _();
        }
      }(n);
    }
    return false;
  }
};
function qr() {
  return typeof document != "undefined" ? document : null;
}
var xr = class {
  constructor(t, n, e, r, s) {
    this.asyncQueue = t, this.timerId = n, this.targetTimeMs = e, this.op = r, this.removalCallback = s, this.deferred = new U(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch((t2) => {
    });
  }
  static createAndSchedule(t, n, e, r, s) {
    const i = Date.now() + e, o = new xr(t, n, i, r, s);
    return o.start(e), o;
  }
  start(t) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t);
  }
  skipDelay() {
    return this.handleDelayElapsed();
  }
  cancel(t) {
    this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new L(E, "Operation cancelled" + (t ? ": " + t : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then((t) => this.deferred.resolve(t))) : Promise.resolve());
  }
  clearTimeout() {
    this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
};
var Or = class {
  constructor() {
    this.Vt = Promise.resolve(), this.Nt = [], this.Dt = false, this.$t = [], this.Ft = null, this.St = false, this.qt = false, this.xt = [], this.It = new Hn(this, "async_queue_retry"), this.Ot = () => {
      const t2 = qr();
      t2 && w("AsyncQueue", "Visibility state changed to " + t2.visibilityState), this.It.H();
    };
    const t = qr();
    t && typeof t.addEventListener == "function" && t.addEventListener("visibilitychange", this.Ot);
  }
  get isShuttingDown() {
    return this.Dt;
  }
  enqueueAndForget(t) {
    this.enqueue(t);
  }
  enqueueAndForgetEvenWhileRestricted(t) {
    this.Ct(), this.Lt(t);
  }
  enterRestrictedMode(t) {
    if (!this.Dt) {
      this.Dt = true, this.qt = t || false;
      const n = qr();
      n && typeof n.removeEventListener == "function" && n.removeEventListener("visibilitychange", this.Ot);
    }
  }
  enqueue(t) {
    if (this.Ct(), this.Dt)
      return new Promise(() => {
      });
    const n = new U();
    return this.Lt(() => this.Dt && this.qt ? Promise.resolve() : (t().then(n.resolve, n.reject), n.promise)).then(() => n.promise);
  }
  enqueueRetryable(t) {
    this.enqueueAndForget(() => (this.Nt.push(t), this.Ut()));
  }
  async Ut() {
    if (this.Nt.length !== 0) {
      try {
        await this.Nt[0](), this.Nt.shift(), this.It.reset();
      } catch (t) {
        if (!function(t2) {
          return t2.name === "IndexedDbTransactionError";
        }(t))
          throw t;
        w("AsyncQueue", "Operation failed with retryable error: " + t);
      }
      this.Nt.length > 0 && this.It.W(() => this.Ut());
    }
  }
  Lt(t) {
    const n = this.Vt.then(() => (this.St = true, t().catch((t2) => {
      this.Ft = t2, this.St = false;
      throw m("INTERNAL UNHANDLED ERROR: ", function(t3) {
        let n2 = t3.message || "";
        t3.stack && (n2 = t3.stack.includes(t3.message) ? t3.stack : t3.message + "\n" + t3.stack);
        return n2;
      }(t2)), t2;
    }).then((t2) => (this.St = false, t2))));
    return this.Vt = n, n;
  }
  enqueueAfterDelay(t, n, e) {
    this.Ct(), this.xt.indexOf(t) > -1 && (n = 0);
    const r = xr.createAndSchedule(this, t, n, e, (t2) => this.jt(t2));
    return this.$t.push(r), r;
  }
  Ct() {
    this.Ft && _();
  }
  verifyOperationInProgress() {
  }
  async kt() {
    let t;
    do {
      t = this.Vt, await t;
    } while (t !== this.Vt);
  }
  Mt(t) {
    for (const n of this.$t)
      if (n.timerId === t)
        return true;
    return false;
  }
  Bt(t) {
    return this.kt().then(() => {
      this.$t.sort((t2, n) => t2.targetTimeMs - n.targetTimeMs);
      for (const n of this.$t)
        if (n.skipDelay(), t !== "all" && n.timerId === t)
          break;
      return this.kt();
    });
  }
  Qt(t) {
    this.xt.push(t);
  }
  jt(t) {
    const n = this.$t.indexOf(t);
    this.$t.splice(n, 1);
  }
};
var Cr = class {
  constructor(t, n) {
    this._firestore = t, this._transaction = n, this._dataReader = Pe(t);
  }
  get(t) {
    const n = Dr(t, this._firestore), e = new yr(this._firestore);
    return this._transaction.lookup([n._key]).then((t2) => {
      if (!t2 || t2.length !== 1)
        return _();
      const r = t2[0];
      if (r.isFoundDocument())
        return new We(this._firestore, e, r.key, r, n.converter);
      if (r.isNoDocument())
        return new We(this._firestore, e, n._key, null, n.converter);
      throw _();
    });
  }
  set(t, n, e) {
    const r = Dr(t, this._firestore), s = pr(r.converter, n, e), i = Re(this._dataReader, "Transaction.set", r._key, s, r.converter !== null, e);
    return this._transaction.set(r._key, i), this;
  }
  update(t, n, e, ...r) {
    const s = Dr(t, this._firestore);
    let i;
    return i = typeof (n = getModularInstance(n)) == "string" || n instanceof me ? xe(this._dataReader, "Transaction.update", s._key, n, e, r) : qe(this._dataReader, "Transaction.update", s._key, n), this._transaction.update(s._key, i), this;
  }
  delete(t) {
    const n = Dr(t, this._firestore);
    return this._transaction.delete(n._key), this;
  }
};
function Lr(t, n) {
  const e = te(t = rt(t, ee)), r = new U();
  return new Sr(new Or(), e, (e2) => n(new Cr(t, e2)), r).run(), r.promise;
}
!function(t) {
  l = t;
}(`${SDK_VERSION}_lite`), _registerComponent(new Component("firestore/lite", (t, { options: n }) => {
  const e = t.getProvider("app").getImmediate(), r = new ee(e, new B(t.getProvider("auth-internal")));
  return n && r._setSettings(n), r;
}, "PUBLIC")), registerVersion("firestore-lite", "3.0.2", "node");
export {
  ye as Bytes,
  ae as CollectionReference,
  ue as DocumentReference,
  We as DocumentSnapshot,
  me as FieldPath,
  _e as FieldValue,
  ee as Firestore,
  L as FirestoreError,
  ge as GeoPoint,
  ce as Query,
  Je as QueryConstraint,
  Ge as QueryDocumentSnapshot,
  He as QuerySnapshot,
  pt as Timestamp,
  Cr as Transaction,
  Nr as WriteBatch,
  Ir as addDoc,
  Rr as arrayRemove,
  Pr as arrayUnion,
  he as collection,
  le as collectionGroup,
  ie as connectFirestoreEmulator,
  Er as deleteDoc,
  Tr as deleteField,
  fe as doc,
  pe as documentId,
  lr as endAt,
  hr as endBefore,
  _r as getDoc,
  gr as getDocs,
  se as getFirestore,
  Vr as increment,
  re as initializeFirestore,
  sr as limit,
  ir as limitToLast,
  er as orderBy,
  Ze as query,
  we as queryEqual,
  de as refEqual,
  Lr as runTransaction,
  Ar as serverTimestamp,
  br as setDoc,
  d as setLogLevel,
  Ye as snapshotEqual,
  cr as startAfter,
  ur as startAt,
  oe as terminate,
  vr as updateDoc,
  tr as where,
  $r as writeBatch
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
* @license
* Copyright 2018 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* @license
* Copyright 2020 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
//# sourceMappingURL=@firebase_firestore_lite.js.map
