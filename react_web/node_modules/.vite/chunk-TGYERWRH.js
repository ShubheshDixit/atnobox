import {
  Component,
  LogLevel,
  Logger,
  SDK_VERSION,
  _getProvider,
  _registerComponent,
  _removeServiceInstance,
  createMockUserToken,
  deepEqual,
  getApp,
  getModularInstance,
  getUA,
  isBrowserExtension,
  isElectron,
  isIE,
  isMobileCordova,
  isReactNative,
  isSafari,
  isUWP,
  registerVersion
} from "./chunk-52TUVP2Y.js";

// node_modules/@firebase/webchannel-wrapper/dist/index.esm.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p2 in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p2))
        d2[p2] = b2[p2];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var k;
var goog = goog || {};
var l = commonjsGlobal || self;
function aa() {
}
function ba(a) {
  var b = typeof a;
  b = b != "object" ? b : a ? Array.isArray(a) ? "array" : b : "null";
  return b == "array" || b == "object" && typeof a.length == "number";
}
function p(a) {
  var b = typeof a;
  return b == "object" && a != null || b == "function";
}
function da(a) {
  return Object.prototype.hasOwnProperty.call(a, ea) && a[ea] || (a[ea] = ++fa);
}
var ea = "closure_uid_" + (1e9 * Math.random() >>> 0);
var fa = 0;
function ha(a, b, c) {
  return a.call.apply(a.bind, arguments);
}
function ia(a, b, c) {
  if (!a)
    throw Error();
  if (2 < arguments.length) {
    var d = Array.prototype.slice.call(arguments, 2);
    return function() {
      var e = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(e, d);
      return a.apply(b, e);
    };
  }
  return function() {
    return a.apply(b, arguments);
  };
}
function q(a, b, c) {
  Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? q = ha : q = ia;
  return q.apply(null, arguments);
}
function ja(a, b) {
  var c = Array.prototype.slice.call(arguments, 1);
  return function() {
    var d = c.slice();
    d.push.apply(d, arguments);
    return a.apply(this, d);
  };
}
function t(a, b) {
  function c() {
  }
  c.prototype = b.prototype;
  a.Z = b.prototype;
  a.prototype = new c();
  a.prototype.constructor = a;
  a.Vb = function(d, e, f) {
    for (var h = Array(arguments.length - 2), n = 2; n < arguments.length; n++)
      h[n - 2] = arguments[n];
    return b.prototype[e].apply(d, h);
  };
}
function v() {
  this.s = this.s;
  this.o = this.o;
}
var ka = 0;
var la = {};
v.prototype.s = false;
v.prototype.na = function() {
  if (!this.s && (this.s = true, this.M(), ka != 0)) {
    var a = da(this);
    delete la[a];
  }
};
v.prototype.M = function() {
  if (this.o)
    for (; this.o.length; )
      this.o.shift()();
};
var ma = Array.prototype.indexOf ? function(a, b) {
  return Array.prototype.indexOf.call(a, b, void 0);
} : function(a, b) {
  if (typeof a === "string")
    return typeof b !== "string" || b.length != 1 ? -1 : a.indexOf(b, 0);
  for (var c = 0; c < a.length; c++)
    if (c in a && a[c] === b)
      return c;
  return -1;
};
var na = Array.prototype.forEach ? function(a, b, c) {
  Array.prototype.forEach.call(a, b, c);
} : function(a, b, c) {
  var d = a.length, e = typeof a === "string" ? a.split("") : a;
  for (var f = 0; f < d; f++)
    f in e && b.call(c, e[f], f, a);
};
function oa(a) {
  a: {
    var b = pa;
    var c = a.length, d = typeof a === "string" ? a.split("") : a;
    for (var e = 0; e < c; e++)
      if (e in d && b.call(void 0, d[e], e, a)) {
        b = e;
        break a;
      }
    b = -1;
  }
  return 0 > b ? null : typeof a === "string" ? a.charAt(b) : a[b];
}
function qa(a) {
  return Array.prototype.concat.apply([], arguments);
}
function ra(a) {
  var b = a.length;
  if (0 < b) {
    var c = Array(b);
    for (var d = 0; d < b; d++)
      c[d] = a[d];
    return c;
  }
  return [];
}
function sa(a) {
  return /^[\s\xa0]*$/.test(a);
}
var ta = String.prototype.trim ? function(a) {
  return a.trim();
} : function(a) {
  return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1];
};
function w(a, b) {
  return a.indexOf(b) != -1;
}
function ua(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
var x;
a: {
  va2 = l.navigator;
  if (va2) {
    wa2 = va2.userAgent;
    if (wa2) {
      x = wa2;
      break a;
    }
  }
  x = "";
}
var va2;
var wa2;
function xa(a, b, c) {
  for (var d in a)
    b.call(c, a[d], d, a);
}
function ya(a) {
  var b = {};
  for (var c in a)
    b[c] = a[c];
  return b;
}
var za = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Aa(a, b) {
  var c, d;
  for (var e = 1; e < arguments.length; e++) {
    d = arguments[e];
    for (c in d)
      a[c] = d[c];
    for (var f = 0; f < za.length; f++)
      c = za[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
  }
}
function Ca(a) {
  Ca[" "](a);
  return a;
}
Ca[" "] = aa;
function Fa(a) {
  var b = Ga;
  return Object.prototype.hasOwnProperty.call(b, 9) ? b[9] : b[9] = a(9);
}
var Ha = w(x, "Opera");
var y = w(x, "Trident") || w(x, "MSIE");
var Ia = w(x, "Edge");
var Ja = Ia || y;
var Ka = w(x, "Gecko") && !(w(x.toLowerCase(), "webkit") && !w(x, "Edge")) && !(w(x, "Trident") || w(x, "MSIE")) && !w(x, "Edge");
var La = w(x.toLowerCase(), "webkit") && !w(x, "Edge");
function Ma() {
  var a = l.document;
  return a ? a.documentMode : void 0;
}
var Na;
a: {
  Oa2 = "", Pa2 = function() {
    var a = x;
    if (Ka)
      return /rv:([^\);]+)(\)|;)/.exec(a);
    if (Ia)
      return /Edge\/([\d\.]+)/.exec(a);
    if (y)
      return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);
    if (La)
      return /WebKit\/(\S+)/.exec(a);
    if (Ha)
      return /(?:Version)[ \/]?(\S+)/.exec(a);
  }();
  Pa2 && (Oa2 = Pa2 ? Pa2[1] : "");
  if (y) {
    Qa2 = Ma();
    if (Qa2 != null && Qa2 > parseFloat(Oa2)) {
      Na = String(Qa2);
      break a;
    }
  }
  Na = Oa2;
}
var Oa2;
var Pa2;
var Qa2;
var Ga = {};
function Ra() {
  return Fa(function() {
    var a = 0;
    var b = ta(String(Na)).split("."), c = ta("9").split("."), d = Math.max(b.length, c.length);
    for (var h = 0; a == 0 && h < d; h++) {
      var e = b[h] || "", f = c[h] || "";
      do {
        e = /(\d*)(\D*)(.*)/.exec(e) || ["", "", "", ""];
        f = /(\d*)(\D*)(.*)/.exec(f) || ["", "", "", ""];
        if (e[0].length == 0 && f[0].length == 0)
          break;
        a = ua(e[1].length == 0 ? 0 : parseInt(e[1], 10), f[1].length == 0 ? 0 : parseInt(f[1], 10)) || ua(e[2].length == 0, f[2].length == 0) || ua(e[2], f[2]);
        e = e[3];
        f = f[3];
      } while (a == 0);
    }
    return 0 <= a;
  });
}
var Sa;
if (l.document && y) {
  Ta2 = Ma();
  Sa = Ta2 ? Ta2 : parseInt(Na, 10) || void 0;
} else
  Sa = void 0;
var Ta2;
var Ua = Sa;
var Va = function() {
  if (!l.addEventListener || !Object.defineProperty)
    return false;
  var a = false, b = Object.defineProperty({}, "passive", { get: function() {
    a = true;
  } });
  try {
    l.addEventListener("test", aa, b), l.removeEventListener("test", aa, b);
  } catch (c) {
  }
  return a;
}();
function z(a, b) {
  this.type = a;
  this.g = this.target = b;
  this.defaultPrevented = false;
}
z.prototype.h = function() {
  this.defaultPrevented = true;
};
function A(a, b) {
  z.call(this, a ? a.type : "");
  this.relatedTarget = this.g = this.target = null;
  this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
  this.key = "";
  this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false;
  this.state = null;
  this.pointerId = 0;
  this.pointerType = "";
  this.i = null;
  if (a) {
    var c = this.type = a.type, d = a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : null;
    this.target = a.target || a.srcElement;
    this.g = b;
    if (b = a.relatedTarget) {
      if (Ka) {
        a: {
          try {
            Ca(b.nodeName);
            var e = true;
            break a;
          } catch (f) {
          }
          e = false;
        }
        e || (b = null);
      }
    } else
      c == "mouseover" ? b = a.fromElement : c == "mouseout" && (b = a.toElement);
    this.relatedTarget = b;
    d ? (this.clientX = d.clientX !== void 0 ? d.clientX : d.pageX, this.clientY = d.clientY !== void 0 ? d.clientY : d.pageY, this.screenX = d.screenX || 0, this.screenY = d.screenY || 0) : (this.clientX = a.clientX !== void 0 ? a.clientX : a.pageX, this.clientY = a.clientY !== void 0 ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0);
    this.button = a.button;
    this.key = a.key || "";
    this.ctrlKey = a.ctrlKey;
    this.altKey = a.altKey;
    this.shiftKey = a.shiftKey;
    this.metaKey = a.metaKey;
    this.pointerId = a.pointerId || 0;
    this.pointerType = typeof a.pointerType === "string" ? a.pointerType : Wa[a.pointerType] || "";
    this.state = a.state;
    this.i = a;
    a.defaultPrevented && A.Z.h.call(this);
  }
}
t(A, z);
var Wa = { 2: "touch", 3: "pen", 4: "mouse" };
A.prototype.h = function() {
  A.Z.h.call(this);
  var a = this.i;
  a.preventDefault ? a.preventDefault() : a.returnValue = false;
};
var B = "closure_listenable_" + (1e6 * Math.random() | 0);
var Xa = 0;
function Ya(a, b, c, d, e) {
  this.listener = a;
  this.proxy = null;
  this.src = b;
  this.type = c;
  this.capture = !!d;
  this.ia = e;
  this.key = ++Xa;
  this.ca = this.fa = false;
}
function Za(a) {
  a.ca = true;
  a.listener = null;
  a.proxy = null;
  a.src = null;
  a.ia = null;
}
function $a(a) {
  this.src = a;
  this.g = {};
  this.h = 0;
}
$a.prototype.add = function(a, b, c, d, e) {
  var f = a.toString();
  a = this.g[f];
  a || (a = this.g[f] = [], this.h++);
  var h = ab(a, b, d, e);
  -1 < h ? (b = a[h], c || (b.fa = false)) : (b = new Ya(b, this.src, f, !!d, e), b.fa = c, a.push(b));
  return b;
};
function bb(a, b) {
  var c = b.type;
  if (c in a.g) {
    var d = a.g[c], e = ma(d, b), f;
    (f = 0 <= e) && Array.prototype.splice.call(d, e, 1);
    f && (Za(b), a.g[c].length == 0 && (delete a.g[c], a.h--));
  }
}
function ab(a, b, c, d) {
  for (var e = 0; e < a.length; ++e) {
    var f = a[e];
    if (!f.ca && f.listener == b && f.capture == !!c && f.ia == d)
      return e;
  }
  return -1;
}
var cb = "closure_lm_" + (1e6 * Math.random() | 0);
var db = {};
function fb(a, b, c, d, e) {
  if (d && d.once)
    return gb(a, b, c, d, e);
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      fb(a, b[f], c, d, e);
    return null;
  }
  c = hb(c);
  return a && a[B] ? a.N(b, c, p(d) ? !!d.capture : !!d, e) : ib(a, b, c, false, d, e);
}
function ib(a, b, c, d, e, f) {
  if (!b)
    throw Error("Invalid event type");
  var h = p(e) ? !!e.capture : !!e, n = jb(a);
  n || (a[cb] = n = new $a(a));
  c = n.add(b, c, d, h, f);
  if (c.proxy)
    return c;
  d = kb();
  c.proxy = d;
  d.src = a;
  d.listener = c;
  if (a.addEventListener)
    Va || (e = h), e === void 0 && (e = false), a.addEventListener(b.toString(), d, e);
  else if (a.attachEvent)
    a.attachEvent(lb(b.toString()), d);
  else if (a.addListener && a.removeListener)
    a.addListener(d);
  else
    throw Error("addEventListener and attachEvent are unavailable.");
  return c;
}
function kb() {
  function a(c) {
    return b.call(a.src, a.listener, c);
  }
  var b = mb;
  return a;
}
function gb(a, b, c, d, e) {
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      gb(a, b[f], c, d, e);
    return null;
  }
  c = hb(c);
  return a && a[B] ? a.O(b, c, p(d) ? !!d.capture : !!d, e) : ib(a, b, c, true, d, e);
}
function nb(a, b, c, d, e) {
  if (Array.isArray(b))
    for (var f = 0; f < b.length; f++)
      nb(a, b[f], c, d, e);
  else
    (d = p(d) ? !!d.capture : !!d, c = hb(c), a && a[B]) ? (a = a.i, b = String(b).toString(), b in a.g && (f = a.g[b], c = ab(f, c, d, e), -1 < c && (Za(f[c]), Array.prototype.splice.call(f, c, 1), f.length == 0 && (delete a.g[b], a.h--)))) : a && (a = jb(a)) && (b = a.g[b.toString()], a = -1, b && (a = ab(b, c, d, e)), (c = -1 < a ? b[a] : null) && ob(c));
}
function ob(a) {
  if (typeof a !== "number" && a && !a.ca) {
    var b = a.src;
    if (b && b[B])
      bb(b.i, a);
    else {
      var c = a.type, d = a.proxy;
      b.removeEventListener ? b.removeEventListener(c, d, a.capture) : b.detachEvent ? b.detachEvent(lb(c), d) : b.addListener && b.removeListener && b.removeListener(d);
      (c = jb(b)) ? (bb(c, a), c.h == 0 && (c.src = null, b[cb] = null)) : Za(a);
    }
  }
}
function lb(a) {
  return a in db ? db[a] : db[a] = "on" + a;
}
function mb(a, b) {
  if (a.ca)
    a = true;
  else {
    b = new A(b, this);
    var c = a.listener, d = a.ia || a.src;
    a.fa && ob(a);
    a = c.call(d, b);
  }
  return a;
}
function jb(a) {
  a = a[cb];
  return a instanceof $a ? a : null;
}
var pb = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
function hb(a) {
  if (typeof a === "function")
    return a;
  a[pb] || (a[pb] = function(b) {
    return a.handleEvent(b);
  });
  return a[pb];
}
function C() {
  v.call(this);
  this.i = new $a(this);
  this.P = this;
  this.I = null;
}
t(C, v);
C.prototype[B] = true;
C.prototype.removeEventListener = function(a, b, c, d) {
  nb(this, a, b, c, d);
};
function D(a, b) {
  var c, d = a.I;
  if (d)
    for (c = []; d; d = d.I)
      c.push(d);
  a = a.P;
  d = b.type || b;
  if (typeof b === "string")
    b = new z(b, a);
  else if (b instanceof z)
    b.target = b.target || a;
  else {
    var e = b;
    b = new z(d, a);
    Aa(b, e);
  }
  e = true;
  if (c)
    for (var f = c.length - 1; 0 <= f; f--) {
      var h = b.g = c[f];
      e = qb(h, d, true, b) && e;
    }
  h = b.g = a;
  e = qb(h, d, true, b) && e;
  e = qb(h, d, false, b) && e;
  if (c)
    for (f = 0; f < c.length; f++)
      h = b.g = c[f], e = qb(h, d, false, b) && e;
}
C.prototype.M = function() {
  C.Z.M.call(this);
  if (this.i) {
    var a = this.i, c;
    for (c in a.g) {
      for (var d = a.g[c], e = 0; e < d.length; e++)
        Za(d[e]);
      delete a.g[c];
      a.h--;
    }
  }
  this.I = null;
};
C.prototype.N = function(a, b, c, d) {
  return this.i.add(String(a), b, false, c, d);
};
C.prototype.O = function(a, b, c, d) {
  return this.i.add(String(a), b, true, c, d);
};
function qb(a, b, c, d) {
  b = a.i.g[String(b)];
  if (!b)
    return true;
  b = b.concat();
  for (var e = true, f = 0; f < b.length; ++f) {
    var h = b[f];
    if (h && !h.ca && h.capture == c) {
      var n = h.listener, u = h.ia || h.src;
      h.fa && bb(a.i, h);
      e = n.call(u, d) !== false && e;
    }
  }
  return e && !d.defaultPrevented;
}
var rb = l.JSON.stringify;
function sb() {
  var a = tb;
  var b = null;
  a.g && (b = a.g, a.g = a.g.next, a.g || (a.h = null), b.next = null);
  return b;
}
var ub = function() {
  function ub2() {
    this.h = this.g = null;
  }
  ub2.prototype.add = function(a, b) {
    var c = vb.get();
    c.set(a, b);
    this.h ? this.h.next = c : this.g = c;
    this.h = c;
  };
  return ub2;
}();
var vb = new (function() {
  function class_2(a, b) {
    this.i = a;
    this.j = b;
    this.h = 0;
    this.g = null;
  }
  class_2.prototype.get = function() {
    var a;
    0 < this.h ? (this.h--, a = this.g, this.g = a.next, a.next = null) : a = this.i();
    return a;
  };
  return class_2;
}())(function() {
  return new wb();
}, function(a) {
  return a.reset();
});
var wb = function() {
  function wb2() {
    this.next = this.g = this.h = null;
  }
  wb2.prototype.set = function(a, b) {
    this.h = a;
    this.g = b;
    this.next = null;
  };
  wb2.prototype.reset = function() {
    this.next = this.g = this.h = null;
  };
  return wb2;
}();
function yb(a) {
  l.setTimeout(function() {
    throw a;
  }, 0);
}
function zb(a, b) {
  Ab || Bb();
  Cb || (Ab(), Cb = true);
  tb.add(a, b);
}
var Ab;
function Bb() {
  var a = l.Promise.resolve(void 0);
  Ab = function() {
    a.then(Db);
  };
}
var Cb = false;
var tb = new ub();
function Db() {
  for (var a; a = sb(); ) {
    try {
      a.h.call(a.g);
    } catch (c) {
      yb(c);
    }
    var b = vb;
    b.j(a);
    100 > b.h && (b.h++, a.next = b.g, b.g = a);
  }
  Cb = false;
}
function Eb(a, b) {
  C.call(this);
  this.h = a || 1;
  this.g = b || l;
  this.j = q(this.kb, this);
  this.l = Date.now();
}
t(Eb, C);
k = Eb.prototype;
k.da = false;
k.S = null;
k.kb = function() {
  if (this.da) {
    var a = Date.now() - this.l;
    0 < a && a < 0.8 * this.h ? this.S = this.g.setTimeout(this.j, this.h - a) : (this.S && (this.g.clearTimeout(this.S), this.S = null), D(this, "tick"), this.da && (Fb(this), this.start()));
  }
};
k.start = function() {
  this.da = true;
  this.S || (this.S = this.g.setTimeout(this.j, this.h), this.l = Date.now());
};
function Fb(a) {
  a.da = false;
  a.S && (a.g.clearTimeout(a.S), a.S = null);
}
k.M = function() {
  Eb.Z.M.call(this);
  Fb(this);
  delete this.g;
};
function Gb(a, b, c) {
  if (typeof a === "function")
    c && (a = q(a, c));
  else if (a && typeof a.handleEvent == "function")
    a = q(a.handleEvent, a);
  else
    throw Error("Invalid listener argument");
  return 2147483647 < Number(b) ? -1 : l.setTimeout(a, b || 0);
}
function Hb(a) {
  a.g = Gb(function() {
    a.g = null;
    a.i && (a.i = false, Hb(a));
  }, a.j);
  var b = a.h;
  a.h = null;
  a.m.apply(null, b);
}
var Ib = function(_super) {
  __extends(Ib2, _super);
  function Ib2(a, b) {
    var _this = _super.call(this) || this;
    _this.m = a;
    _this.j = b;
    _this.h = null;
    _this.i = false;
    _this.g = null;
    return _this;
  }
  Ib2.prototype.l = function(a) {
    this.h = arguments;
    this.g ? this.i = true : Hb(this);
  };
  Ib2.prototype.M = function() {
    _super.prototype.M.call(this);
    this.g && (l.clearTimeout(this.g), this.g = null, this.i = false, this.h = null);
  };
  return Ib2;
}(v);
function E(a) {
  v.call(this);
  this.h = a;
  this.g = {};
}
t(E, v);
var Jb = [];
function Kb(a, b, c, d) {
  Array.isArray(c) || (c && (Jb[0] = c.toString()), c = Jb);
  for (var e = 0; e < c.length; e++) {
    var f = fb(b, c[e], d || a.handleEvent, false, a.h || a);
    if (!f)
      break;
    a.g[f.key] = f;
  }
}
function Lb(a) {
  xa(a.g, function(b, c) {
    this.g.hasOwnProperty(c) && ob(b);
  }, a);
  a.g = {};
}
E.prototype.M = function() {
  E.Z.M.call(this);
  Lb(this);
};
E.prototype.handleEvent = function() {
  throw Error("EventHandler.handleEvent not implemented");
};
function Mb() {
  this.g = true;
}
Mb.prototype.Aa = function() {
  this.g = false;
};
function Nb(a, b, c, d, e, f) {
  a.info(function() {
    if (a.g)
      if (f) {
        var h = "";
        for (var n = f.split("&"), u = 0; u < n.length; u++) {
          var m = n[u].split("=");
          if (1 < m.length) {
            var r = m[0];
            m = m[1];
            var G2 = r.split("_");
            h = 2 <= G2.length && G2[1] == "type" ? h + (r + "=" + m + "&") : h + (r + "=redacted&");
          }
        }
      } else
        h = null;
    else
      h = f;
    return "XMLHTTP REQ (" + d + ") [attempt " + e + "]: " + b + "\n" + c + "\n" + h;
  });
}
function Ob(a, b, c, d, e, f, h) {
  a.info(function() {
    return "XMLHTTP RESP (" + d + ") [ attempt " + e + "]: " + b + "\n" + c + "\n" + f + " " + h;
  });
}
function F(a, b, c, d) {
  a.info(function() {
    return "XMLHTTP TEXT (" + b + "): " + Pb(a, c) + (d ? " " + d : "");
  });
}
function Qb(a, b) {
  a.info(function() {
    return "TIMEOUT: " + b;
  });
}
Mb.prototype.info = function() {
};
function Pb(a, b) {
  if (!a.g)
    return b;
  if (!b)
    return null;
  try {
    var c = JSON.parse(b);
    if (c) {
      for (a = 0; a < c.length; a++)
        if (Array.isArray(c[a])) {
          var d = c[a];
          if (!(2 > d.length)) {
            var e = d[1];
            if (Array.isArray(e) && !(1 > e.length)) {
              var f = e[0];
              if (f != "noop" && f != "stop" && f != "close")
                for (var h = 1; h < e.length; h++)
                  e[h] = "";
            }
          }
        }
    }
    return rb(c);
  } catch (n) {
    return b;
  }
}
var H = {};
var Rb = null;
function Sb() {
  return Rb = Rb || new C();
}
H.Ma = "serverreachability";
function Tb(a) {
  z.call(this, H.Ma, a);
}
t(Tb, z);
function I(a) {
  var b = Sb();
  D(b, new Tb(b, a));
}
H.STAT_EVENT = "statevent";
function Ub(a, b) {
  z.call(this, H.STAT_EVENT, a);
  this.stat = b;
}
t(Ub, z);
function J(a) {
  var b = Sb();
  D(b, new Ub(b, a));
}
H.Na = "timingevent";
function Vb(a, b) {
  z.call(this, H.Na, a);
  this.size = b;
}
t(Vb, z);
function K(a, b) {
  if (typeof a !== "function")
    throw Error("Fn must not be null and must be a function");
  return l.setTimeout(function() {
    a();
  }, b);
}
var Wb = { NO_ERROR: 0, lb: 1, yb: 2, xb: 3, sb: 4, wb: 5, zb: 6, Ja: 7, TIMEOUT: 8, Cb: 9 };
var Xb = { qb: "complete", Mb: "success", Ka: "error", Ja: "abort", Eb: "ready", Fb: "readystatechange", TIMEOUT: "timeout", Ab: "incrementaldata", Db: "progress", tb: "downloadprogress", Ub: "uploadprogress" };
function Yb() {
}
Yb.prototype.h = null;
function Zb(a) {
  return a.h || (a.h = a.i());
}
function $b() {
}
var L = { OPEN: "a", pb: "b", Ka: "c", Bb: "d" };
function ac() {
  z.call(this, "d");
}
t(ac, z);
function bc() {
  z.call(this, "c");
}
t(bc, z);
var cc;
function dc() {
}
t(dc, Yb);
dc.prototype.g = function() {
  return new XMLHttpRequest();
};
dc.prototype.i = function() {
  return {};
};
cc = new dc();
function M(a, b, c, d) {
  this.l = a;
  this.j = b;
  this.m = c;
  this.X = d || 1;
  this.V = new E(this);
  this.P = ec;
  a = Ja ? 125 : void 0;
  this.W = new Eb(a);
  this.H = null;
  this.i = false;
  this.s = this.A = this.v = this.K = this.F = this.Y = this.B = null;
  this.D = [];
  this.g = null;
  this.C = 0;
  this.o = this.u = null;
  this.N = -1;
  this.I = false;
  this.O = 0;
  this.L = null;
  this.aa = this.J = this.$ = this.U = false;
  this.h = new fc();
}
function fc() {
  this.i = null;
  this.g = "";
  this.h = false;
}
var ec = 45e3;
var gc = {};
var hc = {};
k = M.prototype;
k.setTimeout = function(a) {
  this.P = a;
};
function ic(a, b, c) {
  a.K = 1;
  a.v = jc(N(b));
  a.s = c;
  a.U = true;
  kc(a, null);
}
function kc(a, b) {
  a.F = Date.now();
  lc(a);
  a.A = N(a.v);
  var c = a.A, d = a.X;
  Array.isArray(d) || (d = [String(d)]);
  mc(c.h, "t", d);
  a.C = 0;
  c = a.l.H;
  a.h = new fc();
  a.g = nc(a.l, c ? b : null, !a.s);
  0 < a.O && (a.L = new Ib(q(a.Ia, a, a.g), a.O));
  Kb(a.V, a.g, "readystatechange", a.gb);
  b = a.H ? ya(a.H) : {};
  a.s ? (a.u || (a.u = "POST"), b["Content-Type"] = "application/x-www-form-urlencoded", a.g.ea(a.A, a.u, a.s, b)) : (a.u = "GET", a.g.ea(a.A, a.u, null, b));
  I(1);
  Nb(a.j, a.u, a.A, a.m, a.X, a.s);
}
k.gb = function(a) {
  a = a.target;
  var b = this.L;
  b && O(a) == 3 ? b.l() : this.Ia(a);
};
k.Ia = function(a) {
  try {
    if (a == this.g)
      a: {
        var r = O(this.g);
        var b = this.g.Da();
        var G2 = this.g.ba();
        if (!(3 > r) && (r != 3 || Ja || this.g && (this.h.h || this.g.ga() || oc(this.g)))) {
          this.I || r != 4 || b == 7 || (b == 8 || 0 >= G2 ? I(3) : I(2));
          pc(this);
          var c = this.g.ba();
          this.N = c;
          b:
            if (qc(this)) {
              var d = oc(this.g);
              a = "";
              var e = d.length, f = O(this.g) == 4;
              if (!this.h.i) {
                if (typeof TextDecoder === "undefined") {
                  P(this);
                  rc(this);
                  var h = "";
                  break b;
                }
                this.h.i = new l.TextDecoder();
              }
              for (b = 0; b < e; b++)
                this.h.h = true, a += this.h.i.decode(d[b], { stream: f && b == e - 1 });
              d.splice(0, e);
              this.h.g += a;
              this.C = 0;
              h = this.h.g;
            } else
              h = this.g.ga();
          this.i = c == 200;
          Ob(this.j, this.u, this.A, this.m, this.X, r, c);
          if (this.i) {
            if (this.$ && !this.J) {
              b: {
                if (this.g) {
                  var n, u = this.g;
                  if ((n = u.g ? u.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !sa(n)) {
                    var m = n;
                    break b;
                  }
                }
                m = null;
              }
              if (c = m)
                F(this.j, this.m, c, "Initial handshake response via X-HTTP-Initial-Response"), this.J = true, sc(this, c);
              else {
                this.i = false;
                this.o = 3;
                J(12);
                P(this);
                rc(this);
                break a;
              }
            }
            this.U ? (tc(this, r, h), Ja && this.i && r == 3 && (Kb(this.V, this.W, "tick", this.fb), this.W.start())) : (F(this.j, this.m, h, null), sc(this, h));
            r == 4 && P(this);
            this.i && !this.I && (r == 4 ? uc(this.l, this) : (this.i = false, lc(this)));
          } else
            c == 400 && 0 < h.indexOf("Unknown SID") ? (this.o = 3, J(12)) : (this.o = 0, J(13)), P(this), rc(this);
        }
      }
  } catch (r2) {
  } finally {
  }
};
function qc(a) {
  return a.g ? a.u == "GET" && a.K != 2 && a.l.Ba : false;
}
function tc(a, b, c) {
  var d = true, e;
  for (; !a.I && a.C < c.length; )
    if (e = vc(a, c), e == hc) {
      b == 4 && (a.o = 4, J(14), d = false);
      F(a.j, a.m, null, "[Incomplete Response]");
      break;
    } else if (e == gc) {
      a.o = 4;
      J(15);
      F(a.j, a.m, c, "[Invalid Chunk]");
      d = false;
      break;
    } else
      F(a.j, a.m, e, null), sc(a, e);
  qc(a) && e != hc && e != gc && (a.h.g = "", a.C = 0);
  b != 4 || c.length != 0 || a.h.h || (a.o = 1, J(16), d = false);
  a.i = a.i && d;
  d ? 0 < c.length && !a.aa && (a.aa = true, b = a.l, b.g == a && b.$ && !b.L && (b.h.info("Great, no buffering proxy detected. Bytes received: " + c.length), wc(b), b.L = true, J(11))) : (F(a.j, a.m, c, "[Invalid Chunked Response]"), P(a), rc(a));
}
k.fb = function() {
  if (this.g) {
    var a = O(this.g), b = this.g.ga();
    this.C < b.length && (pc(this), tc(this, a, b), this.i && a != 4 && lc(this));
  }
};
function vc(a, b) {
  var c = a.C, d = b.indexOf("\n", c);
  if (d == -1)
    return hc;
  c = Number(b.substring(c, d));
  if (isNaN(c))
    return gc;
  d += 1;
  if (d + c > b.length)
    return hc;
  b = b.substr(d, c);
  a.C = d + c;
  return b;
}
k.cancel = function() {
  this.I = true;
  P(this);
};
function lc(a) {
  a.Y = Date.now() + a.P;
  xc(a, a.P);
}
function xc(a, b) {
  if (a.B != null)
    throw Error("WatchDog timer not null");
  a.B = K(q(a.eb, a), b);
}
function pc(a) {
  a.B && (l.clearTimeout(a.B), a.B = null);
}
k.eb = function() {
  this.B = null;
  var a = Date.now();
  0 <= a - this.Y ? (Qb(this.j, this.A), this.K != 2 && (I(3), J(17)), P(this), this.o = 2, rc(this)) : xc(this, this.Y - a);
};
function rc(a) {
  a.l.G == 0 || a.I || uc(a.l, a);
}
function P(a) {
  pc(a);
  var b = a.L;
  b && typeof b.na == "function" && b.na();
  a.L = null;
  Fb(a.W);
  Lb(a.V);
  a.g && (b = a.g, a.g = null, b.abort(), b.na());
}
function sc(a, b) {
  try {
    var c = a.l;
    if (c.G != 0 && (c.g == a || yc(c.i, a))) {
      if (c.I = a.N, !a.J && yc(c.i, a) && c.G == 3) {
        try {
          var d = c.Ca.g.parse(b);
        } catch (m2) {
          d = null;
        }
        if (Array.isArray(d) && d.length == 3) {
          var e = d;
          if (e[0] == 0)
            a: {
              if (!c.u) {
                if (c.g)
                  if (c.g.F + 3e3 < a.F)
                    zc(c), Ac(c);
                  else
                    break a;
                Bc(c);
                J(18);
              }
            }
          else
            c.ta = e[1], 0 < c.ta - c.U && 37500 > e[2] && c.N && c.A == 0 && !c.v && (c.v = K(q(c.ab, c), 6e3));
          if (1 >= Cc(c.i) && c.ka) {
            try {
              c.ka();
            } catch (m2) {
            }
            c.ka = void 0;
          }
        } else
          Q(c, 11);
      } else if ((a.J || c.g == a) && zc(c), !sa(b))
        for (e = c.Ca.g.parse(b), b = 0; b < e.length; b++) {
          var m = e[b];
          c.U = m[0];
          m = m[1];
          if (c.G == 2)
            if (m[0] == "c") {
              c.J = m[1];
              c.la = m[2];
              var r = m[3];
              r != null && (c.ma = r, c.h.info("VER=" + c.ma));
              var G2 = m[4];
              G2 != null && (c.za = G2, c.h.info("SVER=" + c.za));
              var Da2 = m[5];
              Da2 != null && typeof Da2 === "number" && 0 < Da2 && (d = 1.5 * Da2, c.K = d, c.h.info("backChannelRequestTimeoutMs_=" + d));
              d = c;
              var ca2 = a.g;
              if (ca2) {
                var Ea2 = ca2.g ? ca2.g.getResponseHeader("X-Client-Wire-Protocol") : null;
                if (Ea2) {
                  var f = d.i;
                  !f.g && (w(Ea2, "spdy") || w(Ea2, "quic") || w(Ea2, "h2")) && (f.j = f.l, f.g = new Set(), f.h && (Dc(f, f.h), f.h = null));
                }
                if (d.D) {
                  var xb = ca2.g ? ca2.g.getResponseHeader("X-HTTP-Session-Id") : null;
                  xb && (d.sa = xb, R(d.F, d.D, xb));
                }
              }
              c.G = 3;
              c.j && c.j.xa();
              c.$ && (c.O = Date.now() - a.F, c.h.info("Handshake RTT: " + c.O + "ms"));
              d = c;
              var h = a;
              d.oa = Ec(d, d.H ? d.la : null, d.W);
              if (h.J) {
                Fc(d.i, h);
                var n = h, u = d.K;
                u && n.setTimeout(u);
                n.B && (pc(n), lc(n));
                d.g = h;
              } else
                Gc(d);
              0 < c.l.length && Hc(c);
            } else
              m[0] != "stop" && m[0] != "close" || Q(c, 7);
          else
            c.G == 3 && (m[0] == "stop" || m[0] == "close" ? m[0] == "stop" ? Q(c, 7) : Ic(c) : m[0] != "noop" && c.j && c.j.wa(m), c.A = 0);
        }
    }
    I(4);
  } catch (m2) {
  }
}
function Jc(a) {
  if (a.R && typeof a.R == "function")
    return a.R();
  if (typeof a === "string")
    return a.split("");
  if (ba(a)) {
    for (var b = [], c = a.length, d = 0; d < c; d++)
      b.push(a[d]);
    return b;
  }
  b = [];
  c = 0;
  for (d in a)
    b[c++] = a[d];
  return b;
}
function Kc(a, b) {
  if (a.forEach && typeof a.forEach == "function")
    a.forEach(b, void 0);
  else if (ba(a) || typeof a === "string")
    na(a, b, void 0);
  else {
    if (a.T && typeof a.T == "function")
      var c = a.T();
    else if (a.R && typeof a.R == "function")
      c = void 0;
    else if (ba(a) || typeof a === "string") {
      c = [];
      for (var d = a.length, e = 0; e < d; e++)
        c.push(e);
    } else
      for (e in c = [], d = 0, a)
        c[d++] = e;
    d = Jc(a);
    e = d.length;
    for (var f = 0; f < e; f++)
      b.call(void 0, d[f], c && c[f], a);
  }
}
function S(a, b) {
  this.h = {};
  this.g = [];
  this.i = 0;
  var c = arguments.length;
  if (1 < c) {
    if (c % 2)
      throw Error("Uneven number of arguments");
    for (var d = 0; d < c; d += 2)
      this.set(arguments[d], arguments[d + 1]);
  } else if (a)
    if (a instanceof S)
      for (c = a.T(), d = 0; d < c.length; d++)
        this.set(c[d], a.get(c[d]));
    else
      for (d in a)
        this.set(d, a[d]);
}
k = S.prototype;
k.R = function() {
  Lc(this);
  for (var a = [], b = 0; b < this.g.length; b++)
    a.push(this.h[this.g[b]]);
  return a;
};
k.T = function() {
  Lc(this);
  return this.g.concat();
};
function Lc(a) {
  if (a.i != a.g.length) {
    for (var b = 0, c = 0; b < a.g.length; ) {
      var d = a.g[b];
      T(a.h, d) && (a.g[c++] = d);
      b++;
    }
    a.g.length = c;
  }
  if (a.i != a.g.length) {
    var e = {};
    for (c = b = 0; b < a.g.length; )
      d = a.g[b], T(e, d) || (a.g[c++] = d, e[d] = 1), b++;
    a.g.length = c;
  }
}
k.get = function(a, b) {
  return T(this.h, a) ? this.h[a] : b;
};
k.set = function(a, b) {
  T(this.h, a) || (this.i++, this.g.push(a));
  this.h[a] = b;
};
k.forEach = function(a, b) {
  for (var c = this.T(), d = 0; d < c.length; d++) {
    var e = c[d], f = this.get(e);
    a.call(b, f, e, this);
  }
};
function T(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}
var Mc = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^\\/?#]*)@)?([^\\/?#]*?)(?::([0-9]+))?(?=[\\/?#]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;
function Nc(a, b) {
  if (a) {
    a = a.split("&");
    for (var c = 0; c < a.length; c++) {
      var d = a[c].indexOf("="), e = null;
      if (0 <= d) {
        var f = a[c].substring(0, d);
        e = a[c].substring(d + 1);
      } else
        f = a[c];
      b(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
    }
  }
}
function U(a, b) {
  this.i = this.s = this.j = "";
  this.m = null;
  this.o = this.l = "";
  this.g = false;
  if (a instanceof U) {
    this.g = b !== void 0 ? b : a.g;
    Oc(this, a.j);
    this.s = a.s;
    Pc(this, a.i);
    Qc(this, a.m);
    this.l = a.l;
    b = a.h;
    var c = new Rc();
    c.i = b.i;
    b.g && (c.g = new S(b.g), c.h = b.h);
    Sc(this, c);
    this.o = a.o;
  } else
    a && (c = String(a).match(Mc)) ? (this.g = !!b, Oc(this, c[1] || "", true), this.s = Tc(c[2] || ""), Pc(this, c[3] || "", true), Qc(this, c[4]), this.l = Tc(c[5] || "", true), Sc(this, c[6] || "", true), this.o = Tc(c[7] || "")) : (this.g = !!b, this.h = new Rc(null, this.g));
}
U.prototype.toString = function() {
  var a = [], b = this.j;
  b && a.push(Uc(b, Vc, true), ":");
  var c = this.i;
  if (c || b == "file")
    a.push("//"), (b = this.s) && a.push(Uc(b, Vc, true), "@"), a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.m, c != null && a.push(":", String(c));
  if (c = this.l)
    this.i && c.charAt(0) != "/" && a.push("/"), a.push(Uc(c, c.charAt(0) == "/" ? Wc : Xc, true));
  (c = this.h.toString()) && a.push("?", c);
  (c = this.o) && a.push("#", Uc(c, Yc));
  return a.join("");
};
function N(a) {
  return new U(a);
}
function Oc(a, b, c) {
  a.j = c ? Tc(b, true) : b;
  a.j && (a.j = a.j.replace(/:$/, ""));
}
function Pc(a, b, c) {
  a.i = c ? Tc(b, true) : b;
}
function Qc(a, b) {
  if (b) {
    b = Number(b);
    if (isNaN(b) || 0 > b)
      throw Error("Bad port number " + b);
    a.m = b;
  } else
    a.m = null;
}
function Sc(a, b, c) {
  b instanceof Rc ? (a.h = b, Zc(a.h, a.g)) : (c || (b = Uc(b, $c)), a.h = new Rc(b, a.g));
}
function R(a, b, c) {
  a.h.set(b, c);
}
function jc(a) {
  R(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36));
  return a;
}
function ad(a) {
  return a instanceof U ? N(a) : new U(a, void 0);
}
function bd(a, b, c, d) {
  var e = new U(null, void 0);
  a && Oc(e, a);
  b && Pc(e, b);
  c && Qc(e, c);
  d && (e.l = d);
  return e;
}
function Tc(a, b) {
  return a ? b ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
}
function Uc(a, b, c) {
  return typeof a === "string" ? (a = encodeURI(a).replace(b, cd), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
}
function cd(a) {
  a = a.charCodeAt(0);
  return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
}
var Vc = /[#\/\?@]/g;
var Xc = /[#\?:]/g;
var Wc = /[#\?]/g;
var $c = /[#\?@]/g;
var Yc = /#/g;
function Rc(a, b) {
  this.h = this.g = null;
  this.i = a || null;
  this.j = !!b;
}
function V(a) {
  a.g || (a.g = new S(), a.h = 0, a.i && Nc(a.i, function(b, c) {
    a.add(decodeURIComponent(b.replace(/\+/g, " ")), c);
  }));
}
k = Rc.prototype;
k.add = function(a, b) {
  V(this);
  this.i = null;
  a = W(this, a);
  var c = this.g.get(a);
  c || this.g.set(a, c = []);
  c.push(b);
  this.h += 1;
  return this;
};
function dd(a, b) {
  V(a);
  b = W(a, b);
  T(a.g.h, b) && (a.i = null, a.h -= a.g.get(b).length, a = a.g, T(a.h, b) && (delete a.h[b], a.i--, a.g.length > 2 * a.i && Lc(a)));
}
function ed(a, b) {
  V(a);
  b = W(a, b);
  return T(a.g.h, b);
}
k.forEach = function(a, b) {
  V(this);
  this.g.forEach(function(c, d) {
    na(c, function(e) {
      a.call(b, e, d, this);
    }, this);
  }, this);
};
k.T = function() {
  V(this);
  for (var a = this.g.R(), b = this.g.T(), c = [], d = 0; d < b.length; d++)
    for (var e = a[d], f = 0; f < e.length; f++)
      c.push(b[d]);
  return c;
};
k.R = function(a) {
  V(this);
  var b = [];
  if (typeof a === "string")
    ed(this, a) && (b = qa(b, this.g.get(W(this, a))));
  else {
    a = this.g.R();
    for (var c = 0; c < a.length; c++)
      b = qa(b, a[c]);
  }
  return b;
};
k.set = function(a, b) {
  V(this);
  this.i = null;
  a = W(this, a);
  ed(this, a) && (this.h -= this.g.get(a).length);
  this.g.set(a, [b]);
  this.h += 1;
  return this;
};
k.get = function(a, b) {
  if (!a)
    return b;
  a = this.R(a);
  return 0 < a.length ? String(a[0]) : b;
};
function mc(a, b, c) {
  dd(a, b);
  0 < c.length && (a.i = null, a.g.set(W(a, b), ra(c)), a.h += c.length);
}
k.toString = function() {
  if (this.i)
    return this.i;
  if (!this.g)
    return "";
  for (var a = [], b = this.g.T(), c = 0; c < b.length; c++) {
    var d = b[c], e = encodeURIComponent(String(d));
    d = this.R(d);
    for (var f = 0; f < d.length; f++) {
      var h = e;
      d[f] !== "" && (h += "=" + encodeURIComponent(String(d[f])));
      a.push(h);
    }
  }
  return this.i = a.join("&");
};
function W(a, b) {
  b = String(b);
  a.j && (b = b.toLowerCase());
  return b;
}
function Zc(a, b) {
  b && !a.j && (V(a), a.i = null, a.g.forEach(function(c, d) {
    var e = d.toLowerCase();
    d != e && (dd(this, d), mc(this, e, c));
  }, a));
  a.j = b;
}
var fd = function() {
  function fd2(a, b) {
    this.h = a;
    this.g = b;
  }
  return fd2;
}();
function gd(a) {
  this.l = a || hd;
  l.PerformanceNavigationTiming ? (a = l.performance.getEntriesByType("navigation"), a = 0 < a.length && (a[0].nextHopProtocol == "hq" || a[0].nextHopProtocol == "h2")) : a = !!(l.g && l.g.Ea && l.g.Ea() && l.g.Ea().Zb);
  this.j = a ? this.l : 1;
  this.g = null;
  1 < this.j && (this.g = new Set());
  this.h = null;
  this.i = [];
}
var hd = 10;
function id(a) {
  return a.h ? true : a.g ? a.g.size >= a.j : false;
}
function Cc(a) {
  return a.h ? 1 : a.g ? a.g.size : 0;
}
function yc(a, b) {
  return a.h ? a.h == b : a.g ? a.g.has(b) : false;
}
function Dc(a, b) {
  a.g ? a.g.add(b) : a.h = b;
}
function Fc(a, b) {
  a.h && a.h == b ? a.h = null : a.g && a.g.has(b) && a.g.delete(b);
}
gd.prototype.cancel = function() {
  var e_1, _a2;
  this.i = jd(this);
  if (this.h)
    this.h.cancel(), this.h = null;
  else if (this.g && this.g.size !== 0) {
    try {
      for (var _b = __values(this.g.values()), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
        var a = _c2.value;
        a.cancel();
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c2 && !_c2.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    this.g.clear();
  }
};
function jd(a) {
  var e_2, _a2;
  if (a.h != null)
    return a.i.concat(a.h.D);
  if (a.g != null && a.g.size !== 0) {
    var b = a.i;
    try {
      for (var _b = __values(a.g.values()), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
        var c = _c2.value;
        b = b.concat(c.D);
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (_c2 && !_c2.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    return b;
  }
  return ra(a.i);
}
function kd() {
}
kd.prototype.stringify = function(a) {
  return l.JSON.stringify(a, void 0);
};
kd.prototype.parse = function(a) {
  return l.JSON.parse(a, void 0);
};
function ld() {
  this.g = new kd();
}
function md(a, b, c) {
  var d = c || "";
  try {
    Kc(a, function(e, f) {
      var h = e;
      p(e) && (h = rb(e));
      b.push(d + f + "=" + encodeURIComponent(h));
    });
  } catch (e) {
    throw b.push(d + "type=" + encodeURIComponent("_badmap")), e;
  }
}
function nd(a, b) {
  var c = new Mb();
  if (l.Image) {
    var d_1 = new Image();
    d_1.onload = ja(od, c, d_1, "TestLoadImage: loaded", true, b);
    d_1.onerror = ja(od, c, d_1, "TestLoadImage: error", false, b);
    d_1.onabort = ja(od, c, d_1, "TestLoadImage: abort", false, b);
    d_1.ontimeout = ja(od, c, d_1, "TestLoadImage: timeout", false, b);
    l.setTimeout(function() {
      if (d_1.ontimeout)
        d_1.ontimeout();
    }, 1e4);
    d_1.src = a;
  } else
    b(false);
}
function od(a, b, c, d, e) {
  try {
    b.onload = null, b.onerror = null, b.onabort = null, b.ontimeout = null, e(d);
  } catch (f) {
  }
}
function pd(a) {
  this.l = a.$b || null;
  this.j = a.ib || false;
}
t(pd, Yb);
pd.prototype.g = function() {
  return new qd(this.l, this.j);
};
pd.prototype.i = function(a) {
  return function() {
    return a;
  };
}({});
function qd(a, b) {
  C.call(this);
  this.D = a;
  this.u = b;
  this.m = void 0;
  this.readyState = rd;
  this.status = 0;
  this.responseType = this.responseText = this.response = this.statusText = "";
  this.onreadystatechange = null;
  this.v = new Headers();
  this.h = null;
  this.C = "GET";
  this.B = "";
  this.g = false;
  this.A = this.j = this.l = null;
}
t(qd, C);
var rd = 0;
k = qd.prototype;
k.open = function(a, b) {
  if (this.readyState != rd)
    throw this.abort(), Error("Error reopening a connection");
  this.C = a;
  this.B = b;
  this.readyState = 1;
  sd(this);
};
k.send = function(a) {
  if (this.readyState != 1)
    throw this.abort(), Error("need to call open() first. ");
  this.g = true;
  var b = { headers: this.v, method: this.C, credentials: this.m, cache: void 0 };
  a && (b.body = a);
  (this.D || l).fetch(new Request(this.B, b)).then(this.Va.bind(this), this.ha.bind(this));
};
k.abort = function() {
  this.response = this.responseText = "";
  this.v = new Headers();
  this.status = 0;
  this.j && this.j.cancel("Request was aborted.");
  1 <= this.readyState && this.g && this.readyState != 4 && (this.g = false, td(this));
  this.readyState = rd;
};
k.Va = function(a) {
  if (this.g && (this.l = a, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = a.headers, this.readyState = 2, sd(this)), this.g && (this.readyState = 3, sd(this), this.g)))
    if (this.responseType === "arraybuffer")
      a.arrayBuffer().then(this.Ta.bind(this), this.ha.bind(this));
    else if (typeof l.ReadableStream !== "undefined" && "body" in a) {
      this.j = a.body.getReader();
      if (this.u) {
        if (this.responseType)
          throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
        this.response = [];
      } else
        this.response = this.responseText = "", this.A = new TextDecoder();
      ud(this);
    } else
      a.text().then(this.Ua.bind(this), this.ha.bind(this));
};
function ud(a) {
  a.j.read().then(a.Sa.bind(a)).catch(a.ha.bind(a));
}
k.Sa = function(a) {
  if (this.g) {
    if (this.u && a.value)
      this.response.push(a.value);
    else if (!this.u) {
      var b = a.value ? a.value : new Uint8Array(0);
      if (b = this.A.decode(b, { stream: !a.done }))
        this.response = this.responseText += b;
    }
    a.done ? td(this) : sd(this);
    this.readyState == 3 && ud(this);
  }
};
k.Ua = function(a) {
  this.g && (this.response = this.responseText = a, td(this));
};
k.Ta = function(a) {
  this.g && (this.response = a, td(this));
};
k.ha = function() {
  this.g && td(this);
};
function td(a) {
  a.readyState = 4;
  a.l = null;
  a.j = null;
  a.A = null;
  sd(a);
}
k.setRequestHeader = function(a, b) {
  this.v.append(a, b);
};
k.getResponseHeader = function(a) {
  return this.h ? this.h.get(a.toLowerCase()) || "" : "";
};
k.getAllResponseHeaders = function() {
  if (!this.h)
    return "";
  var a = [], b = this.h.entries();
  for (var c = b.next(); !c.done; )
    c = c.value, a.push(c[0] + ": " + c[1]), c = b.next();
  return a.join("\r\n");
};
function sd(a) {
  a.onreadystatechange && a.onreadystatechange.call(a);
}
Object.defineProperty(qd.prototype, "withCredentials", { get: function() {
  return this.m === "include";
}, set: function(a) {
  this.m = a ? "include" : "same-origin";
} });
var vd = l.JSON.parse;
function X(a) {
  C.call(this);
  this.headers = new S();
  this.u = a || null;
  this.h = false;
  this.C = this.g = null;
  this.H = "";
  this.m = 0;
  this.j = "";
  this.l = this.F = this.v = this.D = false;
  this.B = 0;
  this.A = null;
  this.J = wd;
  this.K = this.L = false;
}
t(X, C);
var wd = "";
var xd = /^https?$/i;
var yd = ["POST", "PUT"];
k = X.prototype;
k.ea = function(a, b, c, d) {
  if (this.g)
    throw Error("[goog.net.XhrIo] Object is active with another request=" + this.H + "; newUri=" + a);
  b = b ? b.toUpperCase() : "GET";
  this.H = a;
  this.j = "";
  this.m = 0;
  this.D = false;
  this.h = true;
  this.g = this.u ? this.u.g() : cc.g();
  this.C = this.u ? Zb(this.u) : Zb(cc);
  this.g.onreadystatechange = q(this.Fa, this);
  try {
    this.F = true, this.g.open(b, String(a), true), this.F = false;
  } catch (f) {
    zd(this, f);
    return;
  }
  a = c || "";
  var e = new S(this.headers);
  d && Kc(d, function(f, h) {
    e.set(h, f);
  });
  d = oa(e.T());
  c = l.FormData && a instanceof l.FormData;
  !(0 <= ma(yd, b)) || d || c || e.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
  e.forEach(function(f, h) {
    this.g.setRequestHeader(h, f);
  }, this);
  this.J && (this.g.responseType = this.J);
  "withCredentials" in this.g && this.g.withCredentials !== this.L && (this.g.withCredentials = this.L);
  try {
    Ad(this), 0 < this.B && ((this.K = Bd(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = q(this.pa, this)) : this.A = Gb(this.pa, this.B, this)), this.v = true, this.g.send(a), this.v = false;
  } catch (f) {
    zd(this, f);
  }
};
function Bd(a) {
  return y && Ra() && typeof a.timeout === "number" && a.ontimeout !== void 0;
}
function pa(a) {
  return a.toLowerCase() == "content-type";
}
k.pa = function() {
  typeof goog != "undefined" && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, D(this, "timeout"), this.abort(8));
};
function zd(a, b) {
  a.h = false;
  a.g && (a.l = true, a.g.abort(), a.l = false);
  a.j = b;
  a.m = 5;
  Cd(a);
  Dd(a);
}
function Cd(a) {
  a.D || (a.D = true, D(a, "complete"), D(a, "error"));
}
k.abort = function(a) {
  this.g && this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false, this.m = a || 7, D(this, "complete"), D(this, "abort"), Dd(this));
};
k.M = function() {
  this.g && (this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false), Dd(this, true));
  X.Z.M.call(this);
};
k.Fa = function() {
  this.s || (this.F || this.v || this.l ? Ed(this) : this.cb());
};
k.cb = function() {
  Ed(this);
};
function Ed(a) {
  if (a.h && typeof goog != "undefined" && (!a.C[1] || O(a) != 4 || a.ba() != 2)) {
    if (a.v && O(a) == 4)
      Gb(a.Fa, 0, a);
    else if (D(a, "readystatechange"), O(a) == 4) {
      a.h = false;
      try {
        var n = a.ba();
        a:
          switch (n) {
            case 200:
            case 201:
            case 202:
            case 204:
            case 206:
            case 304:
            case 1223:
              var b = true;
              break a;
            default:
              b = false;
          }
        var c;
        if (!(c = b)) {
          var d;
          if (d = n === 0) {
            var e = String(a.H).match(Mc)[1] || null;
            if (!e && l.self && l.self.location) {
              var f = l.self.location.protocol;
              e = f.substr(0, f.length - 1);
            }
            d = !xd.test(e ? e.toLowerCase() : "");
          }
          c = d;
        }
        if (c)
          D(a, "complete"), D(a, "success");
        else {
          a.m = 6;
          try {
            var h = 2 < O(a) ? a.g.statusText : "";
          } catch (u) {
            h = "";
          }
          a.j = h + " [" + a.ba() + "]";
          Cd(a);
        }
      } finally {
        Dd(a);
      }
    }
  }
}
function Dd(a, b) {
  if (a.g) {
    Ad(a);
    var c = a.g, d = a.C[0] ? aa : null;
    a.g = null;
    a.C = null;
    b || D(a, "ready");
    try {
      c.onreadystatechange = d;
    } catch (e) {
    }
  }
}
function Ad(a) {
  a.g && a.K && (a.g.ontimeout = null);
  a.A && (l.clearTimeout(a.A), a.A = null);
}
function O(a) {
  return a.g ? a.g.readyState : 0;
}
k.ba = function() {
  try {
    return 2 < O(this) ? this.g.status : -1;
  } catch (a) {
    return -1;
  }
};
k.ga = function() {
  try {
    return this.g ? this.g.responseText : "";
  } catch (a) {
    return "";
  }
};
k.Qa = function(a) {
  if (this.g) {
    var b = this.g.responseText;
    a && b.indexOf(a) == 0 && (b = b.substring(a.length));
    return vd(b);
  }
};
function oc(a) {
  try {
    if (!a.g)
      return null;
    if ("response" in a.g)
      return a.g.response;
    switch (a.J) {
      case wd:
      case "text":
        return a.g.responseText;
      case "arraybuffer":
        if ("mozResponseArrayBuffer" in a.g)
          return a.g.mozResponseArrayBuffer;
    }
    return null;
  } catch (b) {
    return null;
  }
}
k.Da = function() {
  return this.m;
};
k.La = function() {
  return typeof this.j === "string" ? this.j : String(this.j);
};
function Fd(a) {
  var b = "";
  xa(a, function(c, d) {
    b += d;
    b += ":";
    b += c;
    b += "\r\n";
  });
  return b;
}
function Gd(a, b, c) {
  a: {
    for (d in c) {
      var d = false;
      break a;
    }
    d = true;
  }
  d || (c = Fd(c), typeof a === "string" ? c != null && encodeURIComponent(String(c)) : R(a, b, c));
}
function Hd(a, b, c) {
  return c && c.internalChannelParams ? c.internalChannelParams[a] || b : b;
}
function Id(a) {
  this.za = 0;
  this.l = [];
  this.h = new Mb();
  this.la = this.oa = this.F = this.W = this.g = this.sa = this.D = this.aa = this.o = this.P = this.s = null;
  this.Za = this.V = 0;
  this.Xa = Hd("failFast", false, a);
  this.N = this.v = this.u = this.m = this.j = null;
  this.X = true;
  this.I = this.ta = this.U = -1;
  this.Y = this.A = this.C = 0;
  this.Pa = Hd("baseRetryDelayMs", 5e3, a);
  this.$a = Hd("retryDelaySeedMs", 1e4, a);
  this.Ya = Hd("forwardChannelMaxRetries", 2, a);
  this.ra = Hd("forwardChannelRequestTimeoutMs", 2e4, a);
  this.qa = a && a.xmlHttpFactory || void 0;
  this.Ba = a && a.Yb || false;
  this.K = void 0;
  this.H = a && a.supportsCrossDomainXhr || false;
  this.J = "";
  this.i = new gd(a && a.concurrentRequestLimit);
  this.Ca = new ld();
  this.ja = a && a.fastHandshake || false;
  this.Ra = a && a.Wb || false;
  a && a.Aa && this.h.Aa();
  a && a.forceLongPolling && (this.X = false);
  this.$ = !this.ja && this.X && a && a.detectBufferingProxy || false;
  this.ka = void 0;
  this.O = 0;
  this.L = false;
  this.B = null;
  this.Wa = !a || a.Xb !== false;
}
k = Id.prototype;
k.ma = 8;
k.G = 1;
function Ic(a) {
  Jd(a);
  if (a.G == 3) {
    var b = a.V++, c = N(a.F);
    R(c, "SID", a.J);
    R(c, "RID", b);
    R(c, "TYPE", "terminate");
    Kd(a, c);
    b = new M(a, a.h, b, void 0);
    b.K = 2;
    b.v = jc(N(c));
    c = false;
    l.navigator && l.navigator.sendBeacon && (c = l.navigator.sendBeacon(b.v.toString(), ""));
    !c && l.Image && (new Image().src = b.v, c = true);
    c || (b.g = nc(b.l, null), b.g.ea(b.v));
    b.F = Date.now();
    lc(b);
  }
  Ld(a);
}
k.hb = function(a) {
  try {
    this.h.info("Origin Trials invoked: " + a);
  } catch (b) {
  }
};
function Ac(a) {
  a.g && (wc(a), a.g.cancel(), a.g = null);
}
function Jd(a) {
  Ac(a);
  a.u && (l.clearTimeout(a.u), a.u = null);
  zc(a);
  a.i.cancel();
  a.m && (typeof a.m === "number" && l.clearTimeout(a.m), a.m = null);
}
function Md(a, b) {
  a.l.push(new fd(a.Za++, b));
  a.G == 3 && Hc(a);
}
function Hc(a) {
  id(a.i) || a.m || (a.m = true, zb(a.Ha, a), a.C = 0);
}
function Nd(a, b) {
  if (Cc(a.i) >= a.i.j - (a.m ? 1 : 0))
    return false;
  if (a.m)
    return a.l = b.D.concat(a.l), true;
  if (a.G == 1 || a.G == 2 || a.C >= (a.Xa ? 0 : a.Ya))
    return false;
  a.m = K(q(a.Ha, a, b), Od(a, a.C));
  a.C++;
  return true;
}
k.Ha = function(a) {
  if (this.m)
    if (this.m = null, this.G == 1) {
      if (!a) {
        this.V = Math.floor(1e5 * Math.random());
        a = this.V++;
        var e = new M(this, this.h, a, void 0);
        var f = this.s;
        this.P && (f ? (f = ya(f), Aa(f, this.P)) : f = this.P);
        this.o === null && (e.H = f);
        if (this.ja)
          a: {
            var b = 0;
            for (var c = 0; c < this.l.length; c++) {
              b: {
                var d = this.l[c];
                if ("__data__" in d.g && (d = d.g.__data__, typeof d === "string")) {
                  d = d.length;
                  break b;
                }
                d = void 0;
              }
              if (d === void 0)
                break;
              b += d;
              if (4096 < b) {
                b = c;
                break a;
              }
              if (b === 4096 || c === this.l.length - 1) {
                b = c + 1;
                break a;
              }
            }
            b = 1e3;
          }
        else
          b = 1e3;
        b = Pd(this, e, b);
        c = N(this.F);
        R(c, "RID", a);
        R(c, "CVER", 22);
        this.D && R(c, "X-HTTP-Session-Id", this.D);
        Kd(this, c);
        this.o && f && Gd(c, this.o, f);
        Dc(this.i, e);
        this.Ra && R(c, "TYPE", "init");
        this.ja ? (R(c, "$req", b), R(c, "SID", "null"), e.$ = true, ic(e, c, null)) : ic(e, c, b);
        this.G = 2;
      }
    } else
      this.G == 3 && (a ? Qd(this, a) : this.l.length == 0 || id(this.i) || Qd(this));
};
function Qd(a, b) {
  var c;
  b ? c = b.m : c = a.V++;
  var d = N(a.F);
  R(d, "SID", a.J);
  R(d, "RID", c);
  R(d, "AID", a.U);
  Kd(a, d);
  a.o && a.s && Gd(d, a.o, a.s);
  c = new M(a, a.h, c, a.C + 1);
  a.o === null && (c.H = a.s);
  b && (a.l = b.D.concat(a.l));
  b = Pd(a, c, 1e3);
  c.setTimeout(Math.round(0.5 * a.ra) + Math.round(0.5 * a.ra * Math.random()));
  Dc(a.i, c);
  ic(c, d, b);
}
function Kd(a, b) {
  a.j && Kc({}, function(c, d) {
    R(b, d, c);
  });
}
function Pd(a, b, c) {
  c = Math.min(a.l.length, c);
  var d = a.j ? q(a.j.Oa, a.j, a) : null;
  a: {
    var e = a.l;
    var f = -1;
    for (; ; ) {
      var h = ["count=" + c];
      f == -1 ? 0 < c ? (f = e[0].h, h.push("ofs=" + f)) : f = 0 : h.push("ofs=" + f);
      var n = true;
      for (var u = 0; u < c; u++) {
        var m = e[u].h;
        var r = e[u].g;
        m -= f;
        if (0 > m)
          f = Math.max(0, e[u].h - 100), n = false;
        else
          try {
            md(r, h, "req" + m + "_");
          } catch (G2) {
            d && d(r);
          }
      }
      if (n) {
        d = h.join("&");
        break a;
      }
    }
  }
  a = a.l.splice(0, c);
  b.D = a;
  return d;
}
function Gc(a) {
  a.g || a.u || (a.Y = 1, zb(a.Ga, a), a.A = 0);
}
function Bc(a) {
  if (a.g || a.u || 3 <= a.A)
    return false;
  a.Y++;
  a.u = K(q(a.Ga, a), Od(a, a.A));
  a.A++;
  return true;
}
k.Ga = function() {
  this.u = null;
  Rd(this);
  if (this.$ && !(this.L || this.g == null || 0 >= this.O)) {
    var a = 2 * this.O;
    this.h.info("BP detection timer enabled: " + a);
    this.B = K(q(this.bb, this), a);
  }
};
k.bb = function() {
  this.B && (this.B = null, this.h.info("BP detection timeout reached."), this.h.info("Buffering proxy detected and switch to long-polling!"), this.N = false, this.L = true, J(10), Ac(this), Rd(this));
};
function wc(a) {
  a.B != null && (l.clearTimeout(a.B), a.B = null);
}
function Rd(a) {
  a.g = new M(a, a.h, "rpc", a.Y);
  a.o === null && (a.g.H = a.s);
  a.g.O = 0;
  var b = N(a.oa);
  R(b, "RID", "rpc");
  R(b, "SID", a.J);
  R(b, "CI", a.N ? "0" : "1");
  R(b, "AID", a.U);
  Kd(a, b);
  R(b, "TYPE", "xmlhttp");
  a.o && a.s && Gd(b, a.o, a.s);
  a.K && a.g.setTimeout(a.K);
  var c = a.g;
  a = a.la;
  c.K = 1;
  c.v = jc(N(b));
  c.s = null;
  c.U = true;
  kc(c, a);
}
k.ab = function() {
  this.v != null && (this.v = null, Ac(this), Bc(this), J(19));
};
function zc(a) {
  a.v != null && (l.clearTimeout(a.v), a.v = null);
}
function uc(a, b) {
  var c = null;
  if (a.g == b) {
    zc(a);
    wc(a);
    a.g = null;
    var d = 2;
  } else if (yc(a.i, b))
    c = b.D, Fc(a.i, b), d = 1;
  else
    return;
  a.I = b.N;
  if (a.G != 0) {
    if (b.i)
      if (d == 1) {
        c = b.s ? b.s.length : 0;
        b = Date.now() - b.F;
        var e = a.C;
        d = Sb();
        D(d, new Vb(d, c, b, e));
        Hc(a);
      } else
        Gc(a);
    else if (e = b.o, e == 3 || e == 0 && 0 < a.I || !(d == 1 && Nd(a, b) || d == 2 && Bc(a)))
      switch (c && 0 < c.length && (b = a.i, b.i = b.i.concat(c)), e) {
        case 1:
          Q(a, 5);
          break;
        case 4:
          Q(a, 10);
          break;
        case 3:
          Q(a, 6);
          break;
        default:
          Q(a, 2);
      }
  }
}
function Od(a, b) {
  var c = a.Pa + Math.floor(Math.random() * a.$a);
  a.j || (c *= 2);
  return c * b;
}
function Q(a, b) {
  a.h.info("Error code " + b);
  if (b == 2) {
    var c = null;
    a.j && (c = null);
    var d = q(a.jb, a);
    c || (c = new U("//www.google.com/images/cleardot.gif"), l.location && l.location.protocol == "http" || Oc(c, "https"), jc(c));
    nd(c.toString(), d);
  } else
    J(2);
  a.G = 0;
  a.j && a.j.va(b);
  Ld(a);
  Jd(a);
}
k.jb = function(a) {
  a ? (this.h.info("Successfully pinged google.com"), J(2)) : (this.h.info("Failed to ping google.com"), J(1));
};
function Ld(a) {
  a.G = 0;
  a.I = -1;
  if (a.j) {
    if (jd(a.i).length != 0 || a.l.length != 0)
      a.i.i.length = 0, ra(a.l), a.l.length = 0;
    a.j.ua();
  }
}
function Ec(a, b, c) {
  var d = ad(c);
  if (d.i != "")
    b && Pc(d, b + "." + d.i), Qc(d, d.m);
  else {
    var e = l.location;
    d = bd(e.protocol, b ? b + "." + e.hostname : e.hostname, +e.port, c);
  }
  a.aa && xa(a.aa, function(e2, f) {
    R(d, f, e2);
  });
  b = a.D;
  c = a.sa;
  b && c && R(d, b, c);
  R(d, "VER", a.ma);
  Kd(a, d);
  return d;
}
function nc(a, b, c) {
  if (b && !a.H)
    throw Error("Can't create secondary domain capable XhrIo object.");
  b = c && a.Ba && !a.qa ? new X(new pd({ ib: true })) : new X(a.qa);
  b.L = a.H;
  return b;
}
function Sd() {
}
k = Sd.prototype;
k.xa = function() {
};
k.wa = function() {
};
k.va = function() {
};
k.ua = function() {
};
k.Oa = function() {
};
function Td() {
  if (y && !(10 <= Number(Ua)))
    throw Error("Environmental error: no available transport.");
}
Td.prototype.g = function(a, b) {
  return new Y(a, b);
};
function Y(a, b) {
  C.call(this);
  this.g = new Id(b);
  this.l = a;
  this.h = b && b.messageUrlParams || null;
  a = b && b.messageHeaders || null;
  b && b.clientProtocolHeaderRequired && (a ? a["X-Client-Protocol"] = "webchannel" : a = { "X-Client-Protocol": "webchannel" });
  this.g.s = a;
  a = b && b.initMessageHeaders || null;
  b && b.messageContentType && (a ? a["X-WebChannel-Content-Type"] = b.messageContentType : a = { "X-WebChannel-Content-Type": b.messageContentType });
  b && b.ya && (a ? a["X-WebChannel-Client-Profile"] = b.ya : a = { "X-WebChannel-Client-Profile": b.ya });
  this.g.P = a;
  (a = b && b.httpHeadersOverwriteParam) && !sa(a) && (this.g.o = a);
  this.A = b && b.supportsCrossDomainXhr || false;
  this.v = b && b.sendRawJson || false;
  (b = b && b.httpSessionIdParam) && !sa(b) && (this.g.D = b, a = this.h, a !== null && b in a && (a = this.h, b in a && delete a[b]));
  this.j = new Z(this);
}
t(Y, C);
Y.prototype.m = function() {
  this.g.j = this.j;
  this.A && (this.g.H = true);
  var a = this.g, b = this.l, c = this.h || void 0;
  a.Wa && (a.h.info("Origin Trials enabled."), zb(q(a.hb, a, b)));
  J(0);
  a.W = b;
  a.aa = c || {};
  a.N = a.X;
  a.F = Ec(a, null, a.W);
  Hc(a);
};
Y.prototype.close = function() {
  Ic(this.g);
};
Y.prototype.u = function(a) {
  if (typeof a === "string") {
    var b = {};
    b.__data__ = a;
    Md(this.g, b);
  } else
    this.v ? (b = {}, b.__data__ = rb(a), Md(this.g, b)) : Md(this.g, a);
};
Y.prototype.M = function() {
  this.g.j = null;
  delete this.j;
  Ic(this.g);
  delete this.g;
  Y.Z.M.call(this);
};
function Ud(a) {
  ac.call(this);
  var b = a.__sm__;
  if (b) {
    a: {
      for (var c in b) {
        a = c;
        break a;
      }
      a = void 0;
    }
    if (this.i = a)
      a = this.i, b = b !== null && a in b ? b[a] : void 0;
    this.data = b;
  } else
    this.data = a;
}
t(Ud, ac);
function Vd() {
  bc.call(this);
  this.status = 1;
}
t(Vd, bc);
function Z(a) {
  this.g = a;
}
t(Z, Sd);
Z.prototype.xa = function() {
  D(this.g, "a");
};
Z.prototype.wa = function(a) {
  D(this.g, new Ud(a));
};
Z.prototype.va = function(a) {
  D(this.g, new Vd(a));
};
Z.prototype.ua = function() {
  D(this.g, "b");
};
Td.prototype.createWebChannel = Td.prototype.g;
Y.prototype.send = Y.prototype.u;
Y.prototype.open = Y.prototype.m;
Y.prototype.close = Y.prototype.close;
Wb.NO_ERROR = 0;
Wb.TIMEOUT = 8;
Wb.HTTP_ERROR = 6;
Xb.COMPLETE = "complete";
$b.EventType = L;
L.OPEN = "a";
L.CLOSE = "b";
L.ERROR = "c";
L.MESSAGE = "d";
C.prototype.listen = C.prototype.N;
X.prototype.listenOnce = X.prototype.O;
X.prototype.getLastError = X.prototype.La;
X.prototype.getLastErrorCode = X.prototype.Da;
X.prototype.getStatus = X.prototype.ba;
X.prototype.getResponseJson = X.prototype.Qa;
X.prototype.getResponseText = X.prototype.ga;
X.prototype.send = X.prototype.ea;
var createWebChannelTransport = function() {
  return new Td();
};
var getStatEventTarget = function() {
  return Sb();
};
var ErrorCode = Wb;
var EventType = Xb;
var Event = H;
var Stat = { rb: 0, ub: 1, vb: 2, Ob: 3, Tb: 4, Qb: 5, Rb: 6, Pb: 7, Nb: 8, Sb: 9, PROXY: 10, NOPROXY: 11, Lb: 12, Hb: 13, Ib: 14, Gb: 15, Jb: 16, Kb: 17, nb: 18, mb: 19, ob: 20 };
var FetchXmlHttpFactory = pd;
var WebChannel = $b;
var XhrIo = X;

// node_modules/@firebase/firestore/dist/index.esm2017.js
var V2 = class {
  constructor(t2) {
    this.uid = t2;
  }
  isAuthenticated() {
    return this.uid != null;
  }
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(t2) {
    return t2.uid === this.uid;
  }
};
V2.UNAUTHENTICATED = new V2(null), V2.GOOGLE_CREDENTIALS = new V2("google-credentials-uid"), V2.FIRST_PARTY = new V2("first-party-uid"), V2.MOCK_USER = new V2("mock-user");
var S2 = "9.0.2";
var D2 = new Logger("@firebase/firestore");
function C2() {
  return D2.logLevel;
}
function N2(t2) {
  D2.setLogLevel(t2);
}
function x2(t2, ...e) {
  if (D2.logLevel <= LogLevel.DEBUG) {
    const n = e.map(O2);
    D2.debug(`Firestore (${S2}): ${t2}`, ...n);
  }
}
function k2(t2, ...e) {
  if (D2.logLevel <= LogLevel.ERROR) {
    const n = e.map(O2);
    D2.error(`Firestore (${S2}): ${t2}`, ...n);
  }
}
function $(t2, ...e) {
  if (D2.logLevel <= LogLevel.WARN) {
    const n = e.map(O2);
    D2.warn(`Firestore (${S2}): ${t2}`, ...n);
  }
}
function O2(t2) {
  if (typeof t2 == "string")
    return t2;
  try {
    return e = t2, JSON.stringify(e);
  } catch (e2) {
    return t2;
  }
  var e;
}
function F2(t2 = "Unexpected state") {
  const e = `FIRESTORE (${S2}) INTERNAL ASSERTION FAILED: ` + t2;
  throw k2(e), new Error(e);
}
function M2(t2, e) {
  t2 || F2();
}
function L2(t2, e) {
  t2 || F2();
}
function B2(t2, e) {
  return t2;
}
var U2 = {
  OK: "ok",
  CANCELLED: "cancelled",
  UNKNOWN: "unknown",
  INVALID_ARGUMENT: "invalid-argument",
  DEADLINE_EXCEEDED: "deadline-exceeded",
  NOT_FOUND: "not-found",
  ALREADY_EXISTS: "already-exists",
  PERMISSION_DENIED: "permission-denied",
  UNAUTHENTICATED: "unauthenticated",
  RESOURCE_EXHAUSTED: "resource-exhausted",
  FAILED_PRECONDITION: "failed-precondition",
  ABORTED: "aborted",
  OUT_OF_RANGE: "out-of-range",
  UNIMPLEMENTED: "unimplemented",
  INTERNAL: "internal",
  UNAVAILABLE: "unavailable",
  DATA_LOSS: "data-loss"
};
var q2 = class extends Error {
  constructor(t2, e) {
    super(e), this.code = t2, this.message = e, this.name = "FirebaseError", this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
};
var K2 = class {
  constructor() {
    this.promise = new Promise((t2, e) => {
      this.resolve = t2, this.reject = e;
    });
  }
};
var j = class {
  constructor(t2, e) {
    this.user = e, this.type = "OAuth", this.authHeaders = {}, this.authHeaders.Authorization = `Bearer ${t2}`;
  }
};
var Q2 = class {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(t2, e) {
    t2.enqueueRetryable(() => e(V2.UNAUTHENTICATED));
  }
  shutdown() {
  }
};
var W2 = class {
  constructor(t2) {
    this.token = t2, this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(t2, e) {
    this.changeListener = e, t2.enqueueRetryable(() => e(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
};
var G = class {
  constructor(t2) {
    this.t = t2, this.currentUser = V2.UNAUTHENTICATED, this.i = 0, this.forceRefresh = false, this.auth = null;
  }
  start(t2, e) {
    let n = this.i;
    const s = (t3) => this.i !== n ? (n = this.i, e(t3)) : Promise.resolve();
    let i = new K2();
    this.o = () => {
      this.i++, this.currentUser = this.u(), i.resolve(), i = new K2(), t2.enqueueRetryable(() => s(this.currentUser));
    };
    const r = () => {
      const e2 = i;
      t2.enqueueRetryable(async () => {
        await e2.promise, await s(this.currentUser);
      });
    }, o = (t3) => {
      x2("FirebaseCredentialsProvider", "Auth detected"), this.auth = t3, this.auth.addAuthTokenListener(this.o), r();
    };
    this.t.onInit((t3) => o(t3)), setTimeout(() => {
      if (!this.auth) {
        const t3 = this.t.getImmediate({
          optional: true
        });
        t3 ? o(t3) : (x2("FirebaseCredentialsProvider", "Auth not yet detected"), i.resolve(), i = new K2());
      }
    }, 0), r();
  }
  getToken() {
    const t2 = this.i, e = this.forceRefresh;
    return this.forceRefresh = false, this.auth ? this.auth.getToken(e).then((e2) => this.i !== t2 ? (x2("FirebaseCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : e2 ? (M2(typeof e2.accessToken == "string"), new j(e2.accessToken, this.currentUser)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.auth && this.auth.removeAuthTokenListener(this.o);
  }
  u() {
    const t2 = this.auth && this.auth.getUid();
    return M2(t2 === null || typeof t2 == "string"), new V2(t2);
  }
};
var z2 = class {
  constructor(t2, e, n) {
    this.h = t2, this.l = e, this.m = n, this.type = "FirstParty", this.user = V2.FIRST_PARTY;
  }
  get authHeaders() {
    const t2 = {
      "X-Goog-AuthUser": this.l
    }, e = this.h.auth.getAuthHeaderValueForFirstParty([]);
    return e && (t2.Authorization = e), this.m && (t2["X-Goog-Iam-Authorization-Token"] = this.m), t2;
  }
};
var H2 = class {
  constructor(t2, e, n) {
    this.h = t2, this.l = e, this.m = n;
  }
  getToken() {
    return Promise.resolve(new z2(this.h, this.l, this.m));
  }
  start(t2, e) {
    t2.enqueueRetryable(() => e(V2.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
};
var J2 = class {
  constructor(t2, e) {
    this.previousValue = t2, e && (e.sequenceNumberHandler = (t3) => this.g(t3), this.p = (t3) => e.writeSequenceNumber(t3));
  }
  g(t2) {
    return this.previousValue = Math.max(t2, this.previousValue), this.previousValue;
  }
  next() {
    const t2 = ++this.previousValue;
    return this.p && this.p(t2), t2;
  }
};
function Y2(t2) {
  const e = typeof self != "undefined" && (self.crypto || self.msCrypto), n = new Uint8Array(t2);
  if (e && typeof e.getRandomValues == "function")
    e.getRandomValues(n);
  else
    for (let e2 = 0; e2 < t2; e2++)
      n[e2] = Math.floor(256 * Math.random());
  return n;
}
J2.T = -1;
var X2 = class {
  static I() {
    const t2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", e = Math.floor(256 / t2.length) * t2.length;
    let n = "";
    for (; n.length < 20; ) {
      const s = Y2(40);
      for (let i = 0; i < s.length; ++i)
        n.length < 20 && s[i] < e && (n += t2.charAt(s[i] % t2.length));
    }
    return n;
  }
};
function Z2(t2, e) {
  return t2 < e ? -1 : t2 > e ? 1 : 0;
}
function tt(t2, e, n) {
  return t2.length === e.length && t2.every((t3, s) => n(t3, e[s]));
}
function et(t2) {
  return t2 + "\0";
}
var nt = class {
  constructor(t2, e) {
    if (this.seconds = t2, this.nanoseconds = e, e < 0)
      throw new q2(U2.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (e >= 1e9)
      throw new q2(U2.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (t2 < -62135596800)
      throw new q2(U2.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
    if (t2 >= 253402300800)
      throw new q2(U2.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
  }
  static now() {
    return nt.fromMillis(Date.now());
  }
  static fromDate(t2) {
    return nt.fromMillis(t2.getTime());
  }
  static fromMillis(t2) {
    const e = Math.floor(t2 / 1e3), n = Math.floor(1e6 * (t2 - 1e3 * e));
    return new nt(e, n);
  }
  toDate() {
    return new Date(this.toMillis());
  }
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(t2) {
    return this.seconds === t2.seconds ? Z2(this.nanoseconds, t2.nanoseconds) : Z2(this.seconds, t2.seconds);
  }
  isEqual(t2) {
    return t2.seconds === this.seconds && t2.nanoseconds === this.nanoseconds;
  }
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  valueOf() {
    const t2 = this.seconds - -62135596800;
    return String(t2).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
};
var st = class {
  constructor(t2) {
    this.timestamp = t2;
  }
  static fromTimestamp(t2) {
    return new st(t2);
  }
  static min() {
    return new st(new nt(0, 0));
  }
  compareTo(t2) {
    return this.timestamp._compareTo(t2.timestamp);
  }
  isEqual(t2) {
    return this.timestamp.isEqual(t2.timestamp);
  }
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
};
function it(t2) {
  let e = 0;
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e++;
  return e;
}
function rt(t2, e) {
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e(n, t2[n]);
}
function ot(t2) {
  for (const e in t2)
    if (Object.prototype.hasOwnProperty.call(t2, e))
      return false;
  return true;
}
var at = class {
  constructor(t2, e, n) {
    e === void 0 ? e = 0 : e > t2.length && F2(), n === void 0 ? n = t2.length - e : n > t2.length - e && F2(), this.segments = t2, this.offset = e, this.len = n;
  }
  get length() {
    return this.len;
  }
  isEqual(t2) {
    return at.comparator(this, t2) === 0;
  }
  child(t2) {
    const e = this.segments.slice(this.offset, this.limit());
    return t2 instanceof at ? t2.forEach((t3) => {
      e.push(t3);
    }) : e.push(t2), this.construct(e);
  }
  limit() {
    return this.offset + this.length;
  }
  popFirst(t2) {
    return t2 = t2 === void 0 ? 1 : t2, this.construct(this.segments, this.offset + t2, this.length - t2);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(t2) {
    return this.segments[this.offset + t2];
  }
  isEmpty() {
    return this.length === 0;
  }
  isPrefixOf(t2) {
    if (t2.length < this.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  isImmediateParentOf(t2) {
    if (this.length + 1 !== t2.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  forEach(t2) {
    for (let e = this.offset, n = this.limit(); e < n; e++)
      t2(this.segments[e]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(t2, e) {
    const n = Math.min(t2.length, e.length);
    for (let s = 0; s < n; s++) {
      const n2 = t2.get(s), i = e.get(s);
      if (n2 < i)
        return -1;
      if (n2 > i)
        return 1;
    }
    return t2.length < e.length ? -1 : t2.length > e.length ? 1 : 0;
  }
};
var ct = class extends at {
  construct(t2, e, n) {
    return new ct(t2, e, n);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  static fromString(...t2) {
    const e = [];
    for (const n of t2) {
      if (n.indexOf("//") >= 0)
        throw new q2(U2.INVALID_ARGUMENT, `Invalid segment (${n}). Paths must not contain // in them.`);
      e.push(...n.split("/").filter((t3) => t3.length > 0));
    }
    return new ct(e);
  }
  static emptyPath() {
    return new ct([]);
  }
};
var ut = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
var ht = class extends at {
  construct(t2, e, n) {
    return new ht(t2, e, n);
  }
  static isValidIdentifier(t2) {
    return ut.test(t2);
  }
  canonicalString() {
    return this.toArray().map((t2) => (t2 = t2.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), ht.isValidIdentifier(t2) || (t2 = "`" + t2 + "`"), t2)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  isKeyField() {
    return this.length === 1 && this.get(0) === "__name__";
  }
  static keyField() {
    return new ht(["__name__"]);
  }
  static fromServerFormat(t2) {
    const e = [];
    let n = "", s = 0;
    const i = () => {
      if (n.length === 0)
        throw new q2(U2.INVALID_ARGUMENT, `Invalid field path (${t2}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      e.push(n), n = "";
    };
    let r = false;
    for (; s < t2.length; ) {
      const e2 = t2[s];
      if (e2 === "\\") {
        if (s + 1 === t2.length)
          throw new q2(U2.INVALID_ARGUMENT, "Path has trailing escape character: " + t2);
        const e3 = t2[s + 1];
        if (e3 !== "\\" && e3 !== "." && e3 !== "`")
          throw new q2(U2.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t2);
        n += e3, s += 2;
      } else
        e2 === "`" ? (r = !r, s++) : e2 !== "." || r ? (n += e2, s++) : (i(), s++);
    }
    if (i(), r)
      throw new q2(U2.INVALID_ARGUMENT, "Unterminated ` in path: " + t2);
    return new ht(e);
  }
  static emptyPath() {
    return new ht([]);
  }
};
var lt = class {
  constructor(t2) {
    this.fields = t2, t2.sort(ht.comparator);
  }
  covers(t2) {
    for (const e of this.fields)
      if (e.isPrefixOf(t2))
        return true;
    return false;
  }
  isEqual(t2) {
    return tt(this.fields, t2.fields, (t3, e) => t3.isEqual(e));
  }
};
function ft() {
  return typeof atob != "undefined";
}
var dt = class {
  constructor(t2) {
    this.binaryString = t2;
  }
  static fromBase64String(t2) {
    const e = atob(t2);
    return new dt(e);
  }
  static fromUint8Array(t2) {
    const e = function(t3) {
      let e2 = "";
      for (let n = 0; n < t3.length; ++n)
        e2 += String.fromCharCode(t3[n]);
      return e2;
    }(t2);
    return new dt(e);
  }
  toBase64() {
    return t2 = this.binaryString, btoa(t2);
    var t2;
  }
  toUint8Array() {
    return function(t2) {
      const e = new Uint8Array(t2.length);
      for (let n = 0; n < t2.length; n++)
        e[n] = t2.charCodeAt(n);
      return e;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(t2) {
    return Z2(this.binaryString, t2.binaryString);
  }
  isEqual(t2) {
    return this.binaryString === t2.binaryString;
  }
};
dt.EMPTY_BYTE_STRING = new dt("");
var wt = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function _t(t2) {
  if (M2(!!t2), typeof t2 == "string") {
    let e = 0;
    const n = wt.exec(t2);
    if (M2(!!n), n[1]) {
      let t3 = n[1];
      t3 = (t3 + "000000000").substr(0, 9), e = Number(t3);
    }
    const s = new Date(t2);
    return {
      seconds: Math.floor(s.getTime() / 1e3),
      nanos: e
    };
  }
  return {
    seconds: mt(t2.seconds),
    nanos: mt(t2.nanos)
  };
}
function mt(t2) {
  return typeof t2 == "number" ? t2 : typeof t2 == "string" ? Number(t2) : 0;
}
function gt(t2) {
  return typeof t2 == "string" ? dt.fromBase64String(t2) : dt.fromUint8Array(t2);
}
function yt(t2) {
  var e, n;
  return ((n = (((e = t2 == null ? void 0 : t2.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) === null || n === void 0 ? void 0 : n.stringValue) === "server_timestamp";
}
function pt(t2) {
  const e = t2.mapValue.fields.__previous_value__;
  return yt(e) ? pt(e) : e;
}
function Et(t2) {
  const e = _t(t2.mapValue.fields.__local_write_time__.timestampValue);
  return new nt(e.seconds, e.nanos);
}
function Tt(t2) {
  return t2 == null;
}
function It(t2) {
  return t2 === 0 && 1 / t2 == -1 / 0;
}
function At(t2) {
  return typeof t2 == "number" && Number.isInteger(t2) && !It(t2) && t2 <= Number.MAX_SAFE_INTEGER && t2 >= Number.MIN_SAFE_INTEGER;
}
var Rt = class {
  constructor(t2) {
    this.path = t2;
  }
  static fromPath(t2) {
    return new Rt(ct.fromString(t2));
  }
  static fromName(t2) {
    return new Rt(ct.fromString(t2).popFirst(5));
  }
  hasCollectionId(t2) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === t2;
  }
  isEqual(t2) {
    return t2 !== null && ct.comparator(this.path, t2.path) === 0;
  }
  toString() {
    return this.path.toString();
  }
  static comparator(t2, e) {
    return ct.comparator(t2.path, e.path);
  }
  static isDocumentKey(t2) {
    return t2.length % 2 == 0;
  }
  static fromSegments(t2) {
    return new Rt(new ct(t2.slice()));
  }
};
function bt(t2) {
  return "nullValue" in t2 ? 0 : "booleanValue" in t2 ? 1 : "integerValue" in t2 || "doubleValue" in t2 ? 2 : "timestampValue" in t2 ? 3 : "stringValue" in t2 ? 5 : "bytesValue" in t2 ? 6 : "referenceValue" in t2 ? 7 : "geoPointValue" in t2 ? 8 : "arrayValue" in t2 ? 9 : "mapValue" in t2 ? yt(t2) ? 4 : 10 : F2();
}
function Pt(t2, e) {
  const n = bt(t2);
  if (n !== bt(e))
    return false;
  switch (n) {
    case 0:
      return true;
    case 1:
      return t2.booleanValue === e.booleanValue;
    case 4:
      return Et(t2).isEqual(Et(e));
    case 3:
      return function(t3, e2) {
        if (typeof t3.timestampValue == "string" && typeof e2.timestampValue == "string" && t3.timestampValue.length === e2.timestampValue.length)
          return t3.timestampValue === e2.timestampValue;
        const n2 = _t(t3.timestampValue), s = _t(e2.timestampValue);
        return n2.seconds === s.seconds && n2.nanos === s.nanos;
      }(t2, e);
    case 5:
      return t2.stringValue === e.stringValue;
    case 6:
      return function(t3, e2) {
        return gt(t3.bytesValue).isEqual(gt(e2.bytesValue));
      }(t2, e);
    case 7:
      return t2.referenceValue === e.referenceValue;
    case 8:
      return function(t3, e2) {
        return mt(t3.geoPointValue.latitude) === mt(e2.geoPointValue.latitude) && mt(t3.geoPointValue.longitude) === mt(e2.geoPointValue.longitude);
      }(t2, e);
    case 2:
      return function(t3, e2) {
        if ("integerValue" in t3 && "integerValue" in e2)
          return mt(t3.integerValue) === mt(e2.integerValue);
        if ("doubleValue" in t3 && "doubleValue" in e2) {
          const n2 = mt(t3.doubleValue), s = mt(e2.doubleValue);
          return n2 === s ? It(n2) === It(s) : isNaN(n2) && isNaN(s);
        }
        return false;
      }(t2, e);
    case 9:
      return tt(t2.arrayValue.values || [], e.arrayValue.values || [], Pt);
    case 10:
      return function(t3, e2) {
        const n2 = t3.mapValue.fields || {}, s = e2.mapValue.fields || {};
        if (it(n2) !== it(s))
          return false;
        for (const t4 in n2)
          if (n2.hasOwnProperty(t4) && (s[t4] === void 0 || !Pt(n2[t4], s[t4])))
            return false;
        return true;
      }(t2, e);
    default:
      return F2();
  }
}
function vt(t2, e) {
  return (t2.values || []).find((t3) => Pt(t3, e)) !== void 0;
}
function Vt(t2, e) {
  const n = bt(t2), s = bt(e);
  if (n !== s)
    return Z2(n, s);
  switch (n) {
    case 0:
      return 0;
    case 1:
      return Z2(t2.booleanValue, e.booleanValue);
    case 2:
      return function(t3, e2) {
        const n2 = mt(t3.integerValue || t3.doubleValue), s2 = mt(e2.integerValue || e2.doubleValue);
        return n2 < s2 ? -1 : n2 > s2 ? 1 : n2 === s2 ? 0 : isNaN(n2) ? isNaN(s2) ? 0 : -1 : 1;
      }(t2, e);
    case 3:
      return St(t2.timestampValue, e.timestampValue);
    case 4:
      return St(Et(t2), Et(e));
    case 5:
      return Z2(t2.stringValue, e.stringValue);
    case 6:
      return function(t3, e2) {
        const n2 = gt(t3), s2 = gt(e2);
        return n2.compareTo(s2);
      }(t2.bytesValue, e.bytesValue);
    case 7:
      return function(t3, e2) {
        const n2 = t3.split("/"), s2 = e2.split("/");
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; t4++) {
          const e3 = Z2(n2[t4], s2[t4]);
          if (e3 !== 0)
            return e3;
        }
        return Z2(n2.length, s2.length);
      }(t2.referenceValue, e.referenceValue);
    case 8:
      return function(t3, e2) {
        const n2 = Z2(mt(t3.latitude), mt(e2.latitude));
        if (n2 !== 0)
          return n2;
        return Z2(mt(t3.longitude), mt(e2.longitude));
      }(t2.geoPointValue, e.geoPointValue);
    case 9:
      return function(t3, e2) {
        const n2 = t3.values || [], s2 = e2.values || [];
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; ++t4) {
          const e3 = Vt(n2[t4], s2[t4]);
          if (e3)
            return e3;
        }
        return Z2(n2.length, s2.length);
      }(t2.arrayValue, e.arrayValue);
    case 10:
      return function(t3, e2) {
        const n2 = t3.fields || {}, s2 = Object.keys(n2), i = e2.fields || {}, r = Object.keys(i);
        s2.sort(), r.sort();
        for (let t4 = 0; t4 < s2.length && t4 < r.length; ++t4) {
          const e3 = Z2(s2[t4], r[t4]);
          if (e3 !== 0)
            return e3;
          const o = Vt(n2[s2[t4]], i[r[t4]]);
          if (o !== 0)
            return o;
        }
        return Z2(s2.length, r.length);
      }(t2.mapValue, e.mapValue);
    default:
      throw F2();
  }
}
function St(t2, e) {
  if (typeof t2 == "string" && typeof e == "string" && t2.length === e.length)
    return Z2(t2, e);
  const n = _t(t2), s = _t(e), i = Z2(n.seconds, s.seconds);
  return i !== 0 ? i : Z2(n.nanos, s.nanos);
}
function Dt(t2) {
  return Ct(t2);
}
function Ct(t2) {
  return "nullValue" in t2 ? "null" : "booleanValue" in t2 ? "" + t2.booleanValue : "integerValue" in t2 ? "" + t2.integerValue : "doubleValue" in t2 ? "" + t2.doubleValue : "timestampValue" in t2 ? function(t3) {
    const e2 = _t(t3);
    return `time(${e2.seconds},${e2.nanos})`;
  }(t2.timestampValue) : "stringValue" in t2 ? t2.stringValue : "bytesValue" in t2 ? gt(t2.bytesValue).toBase64() : "referenceValue" in t2 ? (n = t2.referenceValue, Rt.fromName(n).toString()) : "geoPointValue" in t2 ? `geo(${(e = t2.geoPointValue).latitude},${e.longitude})` : "arrayValue" in t2 ? function(t3) {
    let e2 = "[", n2 = true;
    for (const s of t3.values || [])
      n2 ? n2 = false : e2 += ",", e2 += Ct(s);
    return e2 + "]";
  }(t2.arrayValue) : "mapValue" in t2 ? function(t3) {
    const e2 = Object.keys(t3.fields || {}).sort();
    let n2 = "{", s = true;
    for (const i of e2)
      s ? s = false : n2 += ",", n2 += `${i}:${Ct(t3.fields[i])}`;
    return n2 + "}";
  }(t2.mapValue) : F2();
  var e, n;
}
function Nt(t2, e) {
  return {
    referenceValue: `projects/${t2.projectId}/databases/${t2.database}/documents/${e.path.canonicalString()}`
  };
}
function xt(t2) {
  return !!t2 && "integerValue" in t2;
}
function kt(t2) {
  return !!t2 && "arrayValue" in t2;
}
function $t(t2) {
  return !!t2 && "nullValue" in t2;
}
function Ot(t2) {
  return !!t2 && "doubleValue" in t2 && isNaN(Number(t2.doubleValue));
}
function Ft(t2) {
  return !!t2 && "mapValue" in t2;
}
function Mt(t2) {
  if (t2.geoPointValue)
    return {
      geoPointValue: Object.assign({}, t2.geoPointValue)
    };
  if (t2.timestampValue && typeof t2.timestampValue == "object")
    return {
      timestampValue: Object.assign({}, t2.timestampValue)
    };
  if (t2.mapValue) {
    const e = {
      mapValue: {
        fields: {}
      }
    };
    return rt(t2.mapValue.fields, (t3, n) => e.mapValue.fields[t3] = Mt(n)), e;
  }
  if (t2.arrayValue) {
    const e = {
      arrayValue: {
        values: []
      }
    };
    for (let n = 0; n < (t2.arrayValue.values || []).length; ++n)
      e.arrayValue.values[n] = Mt(t2.arrayValue.values[n]);
    return e;
  }
  return Object.assign({}, t2);
}
var Lt = class {
  constructor(t2) {
    this.value = t2;
  }
  static empty() {
    return new Lt({
      mapValue: {}
    });
  }
  field(t2) {
    if (t2.isEmpty())
      return this.value;
    {
      let e = this.value;
      for (let n = 0; n < t2.length - 1; ++n)
        if (e = (e.mapValue.fields || {})[t2.get(n)], !Ft(e))
          return null;
      return e = (e.mapValue.fields || {})[t2.lastSegment()], e || null;
    }
  }
  set(t2, e) {
    this.getFieldsMap(t2.popLast())[t2.lastSegment()] = Mt(e);
  }
  setAll(t2) {
    let e = ht.emptyPath(), n = {}, s = [];
    t2.forEach((t3, i2) => {
      if (!e.isImmediateParentOf(i2)) {
        const t4 = this.getFieldsMap(e);
        this.applyChanges(t4, n, s), n = {}, s = [], e = i2.popLast();
      }
      t3 ? n[i2.lastSegment()] = Mt(t3) : s.push(i2.lastSegment());
    });
    const i = this.getFieldsMap(e);
    this.applyChanges(i, n, s);
  }
  delete(t2) {
    const e = this.field(t2.popLast());
    Ft(e) && e.mapValue.fields && delete e.mapValue.fields[t2.lastSegment()];
  }
  isEqual(t2) {
    return Pt(this.value, t2.value);
  }
  getFieldsMap(t2) {
    let e = this.value;
    e.mapValue.fields || (e.mapValue = {
      fields: {}
    });
    for (let n = 0; n < t2.length; ++n) {
      let s = e.mapValue.fields[t2.get(n)];
      Ft(s) && s.mapValue.fields || (s = {
        mapValue: {
          fields: {}
        }
      }, e.mapValue.fields[t2.get(n)] = s), e = s;
    }
    return e.mapValue.fields;
  }
  applyChanges(t2, e, n) {
    rt(e, (e2, n2) => t2[e2] = n2);
    for (const e2 of n)
      delete t2[e2];
  }
  clone() {
    return new Lt(Mt(this.value));
  }
};
function Bt(t2) {
  const e = [];
  return rt(t2.fields, (t3, n) => {
    const s = new ht([t3]);
    if (Ft(n)) {
      const t4 = Bt(n.mapValue).fields;
      if (t4.length === 0)
        e.push(s);
      else
        for (const n2 of t4)
          e.push(s.child(n2));
    } else
      e.push(s);
  }), new lt(e);
}
var Ut = class {
  constructor(t2, e, n, s, i) {
    this.key = t2, this.documentType = e, this.version = n, this.data = s, this.documentState = i;
  }
  static newInvalidDocument(t2) {
    return new Ut(t2, 0, st.min(), Lt.empty(), 0);
  }
  static newFoundDocument(t2, e, n) {
    return new Ut(t2, 1, e, n, 0);
  }
  static newNoDocument(t2, e) {
    return new Ut(t2, 2, e, Lt.empty(), 0);
  }
  static newUnknownDocument(t2, e) {
    return new Ut(t2, 3, e, Lt.empty(), 2);
  }
  convertToFoundDocument(t2, e) {
    return this.version = t2, this.documentType = 1, this.data = e, this.documentState = 0, this;
  }
  convertToNoDocument(t2) {
    return this.version = t2, this.documentType = 2, this.data = Lt.empty(), this.documentState = 0, this;
  }
  convertToUnknownDocument(t2) {
    return this.version = t2, this.documentType = 3, this.data = Lt.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this;
  }
  get hasLocalMutations() {
    return this.documentState === 1;
  }
  get hasCommittedMutations() {
    return this.documentState === 2;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return this.documentType !== 0;
  }
  isFoundDocument() {
    return this.documentType === 1;
  }
  isNoDocument() {
    return this.documentType === 2;
  }
  isUnknownDocument() {
    return this.documentType === 3;
  }
  isEqual(t2) {
    return t2 instanceof Ut && this.key.isEqual(t2.key) && this.version.isEqual(t2.version) && this.documentType === t2.documentType && this.documentState === t2.documentState && this.data.isEqual(t2.data);
  }
  clone() {
    return new Ut(this.key, this.documentType, this.version, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
};
var qt = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
    this.path = t2, this.collectionGroup = e, this.orderBy = n, this.filters = s, this.limit = i, this.startAt = r, this.endAt = o, this.A = null;
  }
};
function Kt(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
  return new qt(t2, e, n, s, i, r, o);
}
function jt(t2) {
  const e = B2(t2);
  if (e.A === null) {
    let t3 = e.path.canonicalString();
    e.collectionGroup !== null && (t3 += "|cg:" + e.collectionGroup), t3 += "|f:", t3 += e.filters.map((t4) => Ht(t4)).join(","), t3 += "|ob:", t3 += e.orderBy.map((t4) => function(t5) {
      return t5.field.canonicalString() + t5.dir;
    }(t4)).join(","), Tt(e.limit) || (t3 += "|l:", t3 += e.limit), e.startAt && (t3 += "|lb:", t3 += re(e.startAt)), e.endAt && (t3 += "|ub:", t3 += re(e.endAt)), e.A = t3;
  }
  return e.A;
}
function Qt(t2) {
  let e = t2.path.canonicalString();
  return t2.collectionGroup !== null && (e += " collectionGroup=" + t2.collectionGroup), t2.filters.length > 0 && (e += `, filters: [${t2.filters.map((t3) => {
    return `${(e2 = t3).field.canonicalString()} ${e2.op} ${Dt(e2.value)}`;
    var e2;
  }).join(", ")}]`), Tt(t2.limit) || (e += ", limit: " + t2.limit), t2.orderBy.length > 0 && (e += `, orderBy: [${t2.orderBy.map((t3) => function(t4) {
    return `${t4.field.canonicalString()} (${t4.dir})`;
  }(t3)).join(", ")}]`), t2.startAt && (e += ", startAt: " + re(t2.startAt)), t2.endAt && (e += ", endAt: " + re(t2.endAt)), `Target(${e})`;
}
function Wt(t2, e) {
  if (t2.limit !== e.limit)
    return false;
  if (t2.orderBy.length !== e.orderBy.length)
    return false;
  for (let n2 = 0; n2 < t2.orderBy.length; n2++)
    if (!ae(t2.orderBy[n2], e.orderBy[n2]))
      return false;
  if (t2.filters.length !== e.filters.length)
    return false;
  for (let i = 0; i < t2.filters.length; i++)
    if (n = t2.filters[i], s = e.filters[i], n.op !== s.op || !n.field.isEqual(s.field) || !Pt(n.value, s.value))
      return false;
  var n, s;
  return t2.collectionGroup === e.collectionGroup && (!!t2.path.isEqual(e.path) && (!!ue(t2.startAt, e.startAt) && ue(t2.endAt, e.endAt)));
}
function Gt(t2) {
  return Rt.isDocumentKey(t2.path) && t2.collectionGroup === null && t2.filters.length === 0;
}
var zt = class extends class {
} {
  constructor(t2, e, n) {
    super(), this.field = t2, this.op = e, this.value = n;
  }
  static create(t2, e, n) {
    return t2.isKeyField() ? e === "in" || e === "not-in" ? this.R(t2, e, n) : new Jt(t2, e, n) : e === "array-contains" ? new te(t2, n) : e === "in" ? new ee(t2, n) : e === "not-in" ? new ne(t2, n) : e === "array-contains-any" ? new se(t2, n) : new zt(t2, e, n);
  }
  static R(t2, e, n) {
    return e === "in" ? new Yt(t2, n) : new Xt(t2, n);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return this.op === "!=" ? e !== null && this.P(Vt(e, this.value)) : e !== null && bt(this.value) === bt(e) && this.P(Vt(e, this.value));
  }
  P(t2) {
    switch (this.op) {
      case "<":
        return t2 < 0;
      case "<=":
        return t2 <= 0;
      case "==":
        return t2 === 0;
      case "!=":
        return t2 !== 0;
      case ">":
        return t2 > 0;
      case ">=":
        return t2 >= 0;
      default:
        return F2();
    }
  }
  v() {
    return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0;
  }
};
function Ht(t2) {
  return t2.field.canonicalString() + t2.op.toString() + Dt(t2.value);
}
var Jt = class extends zt {
  constructor(t2, e, n) {
    super(t2, e, n), this.key = Rt.fromName(n.referenceValue);
  }
  matches(t2) {
    const e = Rt.comparator(t2.key, this.key);
    return this.P(e);
  }
};
var Yt = class extends zt {
  constructor(t2, e) {
    super(t2, "in", e), this.keys = Zt("in", e);
  }
  matches(t2) {
    return this.keys.some((e) => e.isEqual(t2.key));
  }
};
var Xt = class extends zt {
  constructor(t2, e) {
    super(t2, "not-in", e), this.keys = Zt("not-in", e);
  }
  matches(t2) {
    return !this.keys.some((e) => e.isEqual(t2.key));
  }
};
function Zt(t2, e) {
  var n;
  return (((n = e.arrayValue) === null || n === void 0 ? void 0 : n.values) || []).map((t3) => Rt.fromName(t3.referenceValue));
}
var te = class extends zt {
  constructor(t2, e) {
    super(t2, "array-contains", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return kt(e) && vt(e.arrayValue, this.value);
  }
};
var ee = class extends zt {
  constructor(t2, e) {
    super(t2, "in", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return e !== null && vt(this.value.arrayValue, e);
  }
};
var ne = class extends zt {
  constructor(t2, e) {
    super(t2, "not-in", e);
  }
  matches(t2) {
    if (vt(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    }))
      return false;
    const e = t2.data.field(this.field);
    return e !== null && !vt(this.value.arrayValue, e);
  }
};
var se = class extends zt {
  constructor(t2, e) {
    super(t2, "array-contains-any", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return !(!kt(e) || !e.arrayValue.values) && e.arrayValue.values.some((t3) => vt(this.value.arrayValue, t3));
  }
};
var ie = class {
  constructor(t2, e) {
    this.position = t2, this.before = e;
  }
};
function re(t2) {
  return `${t2.before ? "b" : "a"}:${t2.position.map((t3) => Dt(t3)).join(",")}`;
}
var oe = class {
  constructor(t2, e = "asc") {
    this.field = t2, this.dir = e;
  }
};
function ae(t2, e) {
  return t2.dir === e.dir && t2.field.isEqual(e.field);
}
function ce(t2, e, n) {
  let s = 0;
  for (let i = 0; i < t2.position.length; i++) {
    const r = e[i], o = t2.position[i];
    if (r.field.isKeyField())
      s = Rt.comparator(Rt.fromName(o.referenceValue), n.key);
    else {
      s = Vt(o, n.data.field(r.field));
    }
    if (r.dir === "desc" && (s *= -1), s !== 0)
      break;
  }
  return t2.before ? s <= 0 : s < 0;
}
function ue(t2, e) {
  if (t2 === null)
    return e === null;
  if (e === null)
    return false;
  if (t2.before !== e.before || t2.position.length !== e.position.length)
    return false;
  for (let n = 0; n < t2.position.length; n++) {
    if (!Pt(t2.position[n], e.position[n]))
      return false;
  }
  return true;
}
var he = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = "F", o = null, a = null) {
    this.path = t2, this.collectionGroup = e, this.explicitOrderBy = n, this.filters = s, this.limit = i, this.limitType = r, this.startAt = o, this.endAt = a, this.V = null, this.S = null, this.startAt, this.endAt;
  }
};
function le(t2, e, n, s, i, r, o, a) {
  return new he(t2, e, n, s, i, r, o, a);
}
function fe(t2) {
  return new he(t2);
}
function de(t2) {
  return !Tt(t2.limit) && t2.limitType === "F";
}
function we(t2) {
  return !Tt(t2.limit) && t2.limitType === "L";
}
function _e(t2) {
  return t2.explicitOrderBy.length > 0 ? t2.explicitOrderBy[0].field : null;
}
function me(t2) {
  for (const e of t2.filters)
    if (e.v())
      return e.field;
  return null;
}
function ge(t2) {
  return t2.collectionGroup !== null;
}
function ye(t2) {
  const e = B2(t2);
  if (e.V === null) {
    e.V = [];
    const t3 = me(e), n = _e(e);
    if (t3 !== null && n === null)
      t3.isKeyField() || e.V.push(new oe(t3)), e.V.push(new oe(ht.keyField(), "asc"));
    else {
      let t4 = false;
      for (const n2 of e.explicitOrderBy)
        e.V.push(n2), n2.field.isKeyField() && (t4 = true);
      if (!t4) {
        const t5 = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
        e.V.push(new oe(ht.keyField(), t5));
      }
    }
  }
  return e.V;
}
function pe(t2) {
  const e = B2(t2);
  if (!e.S)
    if (e.limitType === "F")
      e.S = Kt(e.path, e.collectionGroup, ye(e), e.filters, e.limit, e.startAt, e.endAt);
    else {
      const t3 = [];
      for (const n2 of ye(e)) {
        const e2 = n2.dir === "desc" ? "asc" : "desc";
        t3.push(new oe(n2.field, e2));
      }
      const n = e.endAt ? new ie(e.endAt.position, !e.endAt.before) : null, s = e.startAt ? new ie(e.startAt.position, !e.startAt.before) : null;
      e.S = Kt(e.path, e.collectionGroup, t3, e.filters, e.limit, n, s);
    }
  return e.S;
}
function Ee(t2, e, n) {
  return new he(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), t2.filters.slice(), e, n, t2.startAt, t2.endAt);
}
function Te(t2, e) {
  return Wt(pe(t2), pe(e)) && t2.limitType === e.limitType;
}
function Ie(t2) {
  return `${jt(pe(t2))}|lt:${t2.limitType}`;
}
function Ae(t2) {
  return `Query(target=${Qt(pe(t2))}; limitType=${t2.limitType})`;
}
function Re(t2, e) {
  return e.isFoundDocument() && function(t3, e2) {
    const n = e2.key.path;
    return t3.collectionGroup !== null ? e2.key.hasCollectionId(t3.collectionGroup) && t3.path.isPrefixOf(n) : Rt.isDocumentKey(t3.path) ? t3.path.isEqual(n) : t3.path.isImmediateParentOf(n);
  }(t2, e) && function(t3, e2) {
    for (const n of t3.explicitOrderBy)
      if (!n.field.isKeyField() && e2.data.field(n.field) === null)
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    for (const n of t3.filters)
      if (!n.matches(e2))
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    if (t3.startAt && !ce(t3.startAt, ye(t3), e2))
      return false;
    if (t3.endAt && ce(t3.endAt, ye(t3), e2))
      return false;
    return true;
  }(t2, e);
}
function be(t2) {
  return (e, n) => {
    let s = false;
    for (const i of ye(t2)) {
      const t3 = Pe(i, e, n);
      if (t3 !== 0)
        return t3;
      s = s || i.field.isKeyField();
    }
    return 0;
  };
}
function Pe(t2, e, n) {
  const s = t2.field.isKeyField() ? Rt.comparator(e.key, n.key) : function(t3, e2, n2) {
    const s2 = e2.data.field(t3), i = n2.data.field(t3);
    return s2 !== null && i !== null ? Vt(s2, i) : F2();
  }(t2.field, e, n);
  switch (t2.dir) {
    case "asc":
      return s;
    case "desc":
      return -1 * s;
    default:
      return F2();
  }
}
function ve(t2, e) {
  if (t2.D) {
    if (isNaN(e))
      return {
        doubleValue: "NaN"
      };
    if (e === 1 / 0)
      return {
        doubleValue: "Infinity"
      };
    if (e === -1 / 0)
      return {
        doubleValue: "-Infinity"
      };
  }
  return {
    doubleValue: It(e) ? "-0" : e
  };
}
function Ve(t2) {
  return {
    integerValue: "" + t2
  };
}
function Se(t2, e) {
  return At(e) ? Ve(e) : ve(t2, e);
}
var De = class {
  constructor() {
    this._ = void 0;
  }
};
function Ce(t2, e, n) {
  return t2 instanceof ke ? function(t3, e2) {
    const n2 = {
      fields: {
        __type__: {
          stringValue: "server_timestamp"
        },
        __local_write_time__: {
          timestampValue: {
            seconds: t3.seconds,
            nanos: t3.nanoseconds
          }
        }
      }
    };
    return e2 && (n2.fields.__previous_value__ = e2), {
      mapValue: n2
    };
  }(n, e) : t2 instanceof $e ? Oe(t2, e) : t2 instanceof Fe ? Me(t2, e) : function(t3, e2) {
    const n2 = xe(t3, e2), s = Be(n2) + Be(t3.C);
    return xt(n2) && xt(t3.C) ? Ve(s) : ve(t3.N, s);
  }(t2, e);
}
function Ne(t2, e, n) {
  return t2 instanceof $e ? Oe(t2, e) : t2 instanceof Fe ? Me(t2, e) : n;
}
function xe(t2, e) {
  return t2 instanceof Le ? xt(n = e) || function(t3) {
    return !!t3 && "doubleValue" in t3;
  }(n) ? e : {
    integerValue: 0
  } : null;
  var n;
}
var ke = class extends De {
};
var $e = class extends De {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function Oe(t2, e) {
  const n = Ue(e);
  for (const e2 of t2.elements)
    n.some((t3) => Pt(t3, e2)) || n.push(e2);
  return {
    arrayValue: {
      values: n
    }
  };
}
var Fe = class extends De {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function Me(t2, e) {
  let n = Ue(e);
  for (const e2 of t2.elements)
    n = n.filter((t3) => !Pt(t3, e2));
  return {
    arrayValue: {
      values: n
    }
  };
}
var Le = class extends De {
  constructor(t2, e) {
    super(), this.N = t2, this.C = e;
  }
};
function Be(t2) {
  return mt(t2.integerValue || t2.doubleValue);
}
function Ue(t2) {
  return kt(t2) && t2.arrayValue.values ? t2.arrayValue.values.slice() : [];
}
var qe = class {
  constructor(t2, e) {
    this.field = t2, this.transform = e;
  }
};
function Ke(t2, e) {
  return t2.field.isEqual(e.field) && function(t3, e2) {
    return t3 instanceof $e && e2 instanceof $e || t3 instanceof Fe && e2 instanceof Fe ? tt(t3.elements, e2.elements, Pt) : t3 instanceof Le && e2 instanceof Le ? Pt(t3.C, e2.C) : t3 instanceof ke && e2 instanceof ke;
  }(t2.transform, e.transform);
}
var je = class {
  constructor(t2, e) {
    this.version = t2, this.transformResults = e;
  }
};
var Qe = class {
  constructor(t2, e) {
    this.updateTime = t2, this.exists = e;
  }
  static none() {
    return new Qe();
  }
  static exists(t2) {
    return new Qe(void 0, t2);
  }
  static updateTime(t2) {
    return new Qe(t2);
  }
  get isNone() {
    return this.updateTime === void 0 && this.exists === void 0;
  }
  isEqual(t2) {
    return this.exists === t2.exists && (this.updateTime ? !!t2.updateTime && this.updateTime.isEqual(t2.updateTime) : !t2.updateTime);
  }
};
function We(t2, e) {
  return t2.updateTime !== void 0 ? e.isFoundDocument() && e.version.isEqual(t2.updateTime) : t2.exists === void 0 || t2.exists === e.isFoundDocument();
}
var Ge = class {
};
function ze(t2, e, n) {
  t2 instanceof Ze ? function(t3, e2, n2) {
    const s = t3.value.clone(), i = nn(t3.fieldTransforms, e2, n2.transformResults);
    s.setAll(i), e2.convertToFoundDocument(n2.version, s).setHasCommittedMutations();
  }(t2, e, n) : t2 instanceof tn ? function(t3, e2, n2) {
    if (!We(t3.precondition, e2))
      return void e2.convertToUnknownDocument(n2.version);
    const s = nn(t3.fieldTransforms, e2, n2.transformResults), i = e2.data;
    i.setAll(en(t3)), i.setAll(s), e2.convertToFoundDocument(n2.version, i).setHasCommittedMutations();
  }(t2, e, n) : function(t3, e2, n2) {
    e2.convertToNoDocument(n2.version).setHasCommittedMutations();
  }(0, e, n);
}
function He(t2, e, n) {
  t2 instanceof Ze ? function(t3, e2, n2) {
    if (!We(t3.precondition, e2))
      return;
    const s = t3.value.clone(), i = sn(t3.fieldTransforms, n2, e2);
    s.setAll(i), e2.convertToFoundDocument(Xe(e2), s).setHasLocalMutations();
  }(t2, e, n) : t2 instanceof tn ? function(t3, e2, n2) {
    if (!We(t3.precondition, e2))
      return;
    const s = sn(t3.fieldTransforms, n2, e2), i = e2.data;
    i.setAll(en(t3)), i.setAll(s), e2.convertToFoundDocument(Xe(e2), i).setHasLocalMutations();
  }(t2, e, n) : function(t3, e2) {
    We(t3.precondition, e2) && e2.convertToNoDocument(st.min());
  }(t2, e);
}
function Je(t2, e) {
  let n = null;
  for (const s of t2.fieldTransforms) {
    const t3 = e.data.field(s.field), i = xe(s.transform, t3 || null);
    i != null && (n == null && (n = Lt.empty()), n.set(s.field, i));
  }
  return n || null;
}
function Ye(t2, e) {
  return t2.type === e.type && (!!t2.key.isEqual(e.key) && (!!t2.precondition.isEqual(e.precondition) && (!!function(t3, e2) {
    return t3 === void 0 && e2 === void 0 || !(!t3 || !e2) && tt(t3, e2, (t4, e3) => Ke(t4, e3));
  }(t2.fieldTransforms, e.fieldTransforms) && (t2.type === 0 ? t2.value.isEqual(e.value) : t2.type !== 1 || t2.data.isEqual(e.data) && t2.fieldMask.isEqual(e.fieldMask)))));
}
function Xe(t2) {
  return t2.isFoundDocument() ? t2.version : st.min();
}
var Ze = class extends Ge {
  constructor(t2, e, n, s = []) {
    super(), this.key = t2, this.value = e, this.precondition = n, this.fieldTransforms = s, this.type = 0;
  }
};
var tn = class extends Ge {
  constructor(t2, e, n, s, i = []) {
    super(), this.key = t2, this.data = e, this.fieldMask = n, this.precondition = s, this.fieldTransforms = i, this.type = 1;
  }
};
function en(t2) {
  const e = new Map();
  return t2.fieldMask.fields.forEach((n) => {
    if (!n.isEmpty()) {
      const s = t2.data.field(n);
      e.set(n, s);
    }
  }), e;
}
function nn(t2, e, n) {
  const s = new Map();
  M2(t2.length === n.length);
  for (let i = 0; i < n.length; i++) {
    const r = t2[i], o = r.transform, a = e.data.field(r.field);
    s.set(r.field, Ne(o, a, n[i]));
  }
  return s;
}
function sn(t2, e, n) {
  const s = new Map();
  for (const i of t2) {
    const t3 = i.transform, r = n.data.field(i.field);
    s.set(i.field, Ce(t3, r, e));
  }
  return s;
}
var rn = class extends Ge {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 2, this.fieldTransforms = [];
  }
};
var on = class extends Ge {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 3, this.fieldTransforms = [];
  }
};
var an = class {
  constructor(t2) {
    this.count = t2;
  }
};
var cn;
var un;
function hn(t2) {
  switch (t2) {
    case U2.OK:
      return F2();
    case U2.CANCELLED:
    case U2.UNKNOWN:
    case U2.DEADLINE_EXCEEDED:
    case U2.RESOURCE_EXHAUSTED:
    case U2.INTERNAL:
    case U2.UNAVAILABLE:
    case U2.UNAUTHENTICATED:
      return false;
    case U2.INVALID_ARGUMENT:
    case U2.NOT_FOUND:
    case U2.ALREADY_EXISTS:
    case U2.PERMISSION_DENIED:
    case U2.FAILED_PRECONDITION:
    case U2.ABORTED:
    case U2.OUT_OF_RANGE:
    case U2.UNIMPLEMENTED:
    case U2.DATA_LOSS:
      return true;
    default:
      return F2();
  }
}
function ln(t2) {
  if (t2 === void 0)
    return k2("GRPC error has no .code"), U2.UNKNOWN;
  switch (t2) {
    case cn.OK:
      return U2.OK;
    case cn.CANCELLED:
      return U2.CANCELLED;
    case cn.UNKNOWN:
      return U2.UNKNOWN;
    case cn.DEADLINE_EXCEEDED:
      return U2.DEADLINE_EXCEEDED;
    case cn.RESOURCE_EXHAUSTED:
      return U2.RESOURCE_EXHAUSTED;
    case cn.INTERNAL:
      return U2.INTERNAL;
    case cn.UNAVAILABLE:
      return U2.UNAVAILABLE;
    case cn.UNAUTHENTICATED:
      return U2.UNAUTHENTICATED;
    case cn.INVALID_ARGUMENT:
      return U2.INVALID_ARGUMENT;
    case cn.NOT_FOUND:
      return U2.NOT_FOUND;
    case cn.ALREADY_EXISTS:
      return U2.ALREADY_EXISTS;
    case cn.PERMISSION_DENIED:
      return U2.PERMISSION_DENIED;
    case cn.FAILED_PRECONDITION:
      return U2.FAILED_PRECONDITION;
    case cn.ABORTED:
      return U2.ABORTED;
    case cn.OUT_OF_RANGE:
      return U2.OUT_OF_RANGE;
    case cn.UNIMPLEMENTED:
      return U2.UNIMPLEMENTED;
    case cn.DATA_LOSS:
      return U2.DATA_LOSS;
    default:
      return F2();
  }
}
(un = cn || (cn = {}))[un.OK = 0] = "OK", un[un.CANCELLED = 1] = "CANCELLED", un[un.UNKNOWN = 2] = "UNKNOWN", un[un.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", un[un.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", un[un.NOT_FOUND = 5] = "NOT_FOUND", un[un.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", un[un.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", un[un.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", un[un.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", un[un.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", un[un.ABORTED = 10] = "ABORTED", un[un.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", un[un.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", un[un.INTERNAL = 13] = "INTERNAL", un[un.UNAVAILABLE = 14] = "UNAVAILABLE", un[un.DATA_LOSS = 15] = "DATA_LOSS";
var fn = class {
  constructor(t2, e) {
    this.comparator = t2, this.root = e || wn.EMPTY;
  }
  insert(t2, e) {
    return new fn(this.comparator, this.root.insert(t2, e, this.comparator).copy(null, null, wn.BLACK, null, null));
  }
  remove(t2) {
    return new fn(this.comparator, this.root.remove(t2, this.comparator).copy(null, null, wn.BLACK, null, null));
  }
  get(t2) {
    let e = this.root;
    for (; !e.isEmpty(); ) {
      const n = this.comparator(t2, e.key);
      if (n === 0)
        return e.value;
      n < 0 ? e = e.left : n > 0 && (e = e.right);
    }
    return null;
  }
  indexOf(t2) {
    let e = 0, n = this.root;
    for (; !n.isEmpty(); ) {
      const s = this.comparator(t2, n.key);
      if (s === 0)
        return e + n.left.size;
      s < 0 ? n = n.left : (e += n.left.size + 1, n = n.right);
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  get size() {
    return this.root.size;
  }
  minKey() {
    return this.root.minKey();
  }
  maxKey() {
    return this.root.maxKey();
  }
  inorderTraversal(t2) {
    return this.root.inorderTraversal(t2);
  }
  forEach(t2) {
    this.inorderTraversal((e, n) => (t2(e, n), false));
  }
  toString() {
    const t2 = [];
    return this.inorderTraversal((e, n) => (t2.push(`${e}:${n}`), false)), `{${t2.join(", ")}}`;
  }
  reverseTraversal(t2) {
    return this.root.reverseTraversal(t2);
  }
  getIterator() {
    return new dn(this.root, null, this.comparator, false);
  }
  getIteratorFrom(t2) {
    return new dn(this.root, t2, this.comparator, false);
  }
  getReverseIterator() {
    return new dn(this.root, null, this.comparator, true);
  }
  getReverseIteratorFrom(t2) {
    return new dn(this.root, t2, this.comparator, true);
  }
};
var dn = class {
  constructor(t2, e, n, s) {
    this.isReverse = s, this.nodeStack = [];
    let i = 1;
    for (; !t2.isEmpty(); )
      if (i = e ? n(t2.key, e) : 1, s && (i *= -1), i < 0)
        t2 = this.isReverse ? t2.left : t2.right;
      else {
        if (i === 0) {
          this.nodeStack.push(t2);
          break;
        }
        this.nodeStack.push(t2), t2 = this.isReverse ? t2.right : t2.left;
      }
  }
  getNext() {
    let t2 = this.nodeStack.pop();
    const e = {
      key: t2.key,
      value: t2.value
    };
    if (this.isReverse)
      for (t2 = t2.left; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.right;
    else
      for (t2 = t2.right; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.left;
    return e;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (this.nodeStack.length === 0)
      return null;
    const t2 = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: t2.key,
      value: t2.value
    };
  }
};
var wn = class {
  constructor(t2, e, n, s, i) {
    this.key = t2, this.value = e, this.color = n != null ? n : wn.RED, this.left = s != null ? s : wn.EMPTY, this.right = i != null ? i : wn.EMPTY, this.size = this.left.size + 1 + this.right.size;
  }
  copy(t2, e, n, s, i) {
    return new wn(t2 != null ? t2 : this.key, e != null ? e : this.value, n != null ? n : this.color, s != null ? s : this.left, i != null ? i : this.right);
  }
  isEmpty() {
    return false;
  }
  inorderTraversal(t2) {
    return this.left.inorderTraversal(t2) || t2(this.key, this.value) || this.right.inorderTraversal(t2);
  }
  reverseTraversal(t2) {
    return this.right.reverseTraversal(t2) || t2(this.key, this.value) || this.left.reverseTraversal(t2);
  }
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  minKey() {
    return this.min().key;
  }
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  insert(t2, e, n) {
    let s = this;
    const i = n(t2, s.key);
    return s = i < 0 ? s.copy(null, null, null, s.left.insert(t2, e, n), null) : i === 0 ? s.copy(null, e, null, null, null) : s.copy(null, null, null, null, s.right.insert(t2, e, n)), s.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty())
      return wn.EMPTY;
    let t2 = this;
    return t2.left.isRed() || t2.left.left.isRed() || (t2 = t2.moveRedLeft()), t2 = t2.copy(null, null, null, t2.left.removeMin(), null), t2.fixUp();
  }
  remove(t2, e) {
    let n, s = this;
    if (e(t2, s.key) < 0)
      s.left.isEmpty() || s.left.isRed() || s.left.left.isRed() || (s = s.moveRedLeft()), s = s.copy(null, null, null, s.left.remove(t2, e), null);
    else {
      if (s.left.isRed() && (s = s.rotateRight()), s.right.isEmpty() || s.right.isRed() || s.right.left.isRed() || (s = s.moveRedRight()), e(t2, s.key) === 0) {
        if (s.right.isEmpty())
          return wn.EMPTY;
        n = s.right.min(), s = s.copy(n.key, n.value, null, null, s.right.removeMin());
      }
      s = s.copy(null, null, null, null, s.right.remove(t2, e));
    }
    return s.fixUp();
  }
  isRed() {
    return this.color;
  }
  fixUp() {
    let t2 = this;
    return t2.right.isRed() && !t2.left.isRed() && (t2 = t2.rotateLeft()), t2.left.isRed() && t2.left.left.isRed() && (t2 = t2.rotateRight()), t2.left.isRed() && t2.right.isRed() && (t2 = t2.colorFlip()), t2;
  }
  moveRedLeft() {
    let t2 = this.colorFlip();
    return t2.right.left.isRed() && (t2 = t2.copy(null, null, null, null, t2.right.rotateRight()), t2 = t2.rotateLeft(), t2 = t2.colorFlip()), t2;
  }
  moveRedRight() {
    let t2 = this.colorFlip();
    return t2.left.left.isRed() && (t2 = t2.rotateRight(), t2 = t2.colorFlip()), t2;
  }
  rotateLeft() {
    const t2 = this.copy(null, null, wn.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, t2, null);
  }
  rotateRight() {
    const t2 = this.copy(null, null, wn.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, t2);
  }
  colorFlip() {
    const t2 = this.left.copy(null, null, !this.left.color, null, null), e = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, t2, e);
  }
  checkMaxDepth() {
    const t2 = this.check();
    return Math.pow(2, t2) <= this.size + 1;
  }
  check() {
    if (this.isRed() && this.left.isRed())
      throw F2();
    if (this.right.isRed())
      throw F2();
    const t2 = this.left.check();
    if (t2 !== this.right.check())
      throw F2();
    return t2 + (this.isRed() ? 0 : 1);
  }
};
wn.EMPTY = null, wn.RED = true, wn.BLACK = false;
wn.EMPTY = new class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw F2();
  }
  get value() {
    throw F2();
  }
  get color() {
    throw F2();
  }
  get left() {
    throw F2();
  }
  get right() {
    throw F2();
  }
  copy(t2, e, n, s, i) {
    return this;
  }
  insert(t2, e, n) {
    return new wn(t2, e);
  }
  remove(t2, e) {
    return this;
  }
  isEmpty() {
    return true;
  }
  inorderTraversal(t2) {
    return false;
  }
  reverseTraversal(t2) {
    return false;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return false;
  }
  checkMaxDepth() {
    return true;
  }
  check() {
    return 0;
  }
}();
var _n = class {
  constructor(t2) {
    this.comparator = t2, this.data = new fn(this.comparator);
  }
  has(t2) {
    return this.data.get(t2) !== null;
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(t2) {
    return this.data.indexOf(t2);
  }
  forEach(t2) {
    this.data.inorderTraversal((e, n) => (t2(e), false));
  }
  forEachInRange(t2, e) {
    const n = this.data.getIteratorFrom(t2[0]);
    for (; n.hasNext(); ) {
      const s = n.getNext();
      if (this.comparator(s.key, t2[1]) >= 0)
        return;
      e(s.key);
    }
  }
  forEachWhile(t2, e) {
    let n;
    for (n = e !== void 0 ? this.data.getIteratorFrom(e) : this.data.getIterator(); n.hasNext(); ) {
      if (!t2(n.getNext().key))
        return;
    }
  }
  firstAfterOrEqual(t2) {
    const e = this.data.getIteratorFrom(t2);
    return e.hasNext() ? e.getNext().key : null;
  }
  getIterator() {
    return new mn(this.data.getIterator());
  }
  getIteratorFrom(t2) {
    return new mn(this.data.getIteratorFrom(t2));
  }
  add(t2) {
    return this.copy(this.data.remove(t2).insert(t2, true));
  }
  delete(t2) {
    return this.has(t2) ? this.copy(this.data.remove(t2)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(t2) {
    let e = this;
    return e.size < t2.size && (e = t2, t2 = this), t2.forEach((t3) => {
      e = e.add(t3);
    }), e;
  }
  isEqual(t2) {
    if (!(t2 instanceof _n))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.data.getIterator(), n = t2.data.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (this.comparator(t3, s) !== 0)
        return false;
    }
    return true;
  }
  toArray() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e);
    }), t2;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), "SortedSet(" + t2.toString() + ")";
  }
  copy(t2) {
    const e = new _n(this.comparator);
    return e.data = t2, e;
  }
};
var mn = class {
  constructor(t2) {
    this.iter = t2;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
};
var gn = new fn(Rt.comparator);
function yn() {
  return gn;
}
var pn = new fn(Rt.comparator);
function En() {
  return pn;
}
var Tn = new fn(Rt.comparator);
function In() {
  return Tn;
}
var An = new _n(Rt.comparator);
function Rn(...t2) {
  let e = An;
  for (const n of t2)
    e = e.add(n);
  return e;
}
var bn = new _n(Z2);
function Pn() {
  return bn;
}
var vn = class {
  constructor(t2, e, n, s, i) {
    this.snapshotVersion = t2, this.targetChanges = e, this.targetMismatches = n, this.documentUpdates = s, this.resolvedLimboDocuments = i;
  }
  static createSynthesizedRemoteEventForCurrentChange(t2, e) {
    const n = new Map();
    return n.set(t2, Vn.createSynthesizedTargetChangeForCurrentChange(t2, e)), new vn(st.min(), n, Pn(), yn(), Rn());
  }
};
var Vn = class {
  constructor(t2, e, n, s, i) {
    this.resumeToken = t2, this.current = e, this.addedDocuments = n, this.modifiedDocuments = s, this.removedDocuments = i;
  }
  static createSynthesizedTargetChangeForCurrentChange(t2, e) {
    return new Vn(dt.EMPTY_BYTE_STRING, e, Rn(), Rn(), Rn());
  }
};
var Sn = class {
  constructor(t2, e, n, s) {
    this.k = t2, this.removedTargetIds = e, this.key = n, this.$ = s;
  }
};
var Dn = class {
  constructor(t2, e) {
    this.targetId = t2, this.O = e;
  }
};
var Cn = class {
  constructor(t2, e, n = dt.EMPTY_BYTE_STRING, s = null) {
    this.state = t2, this.targetIds = e, this.resumeToken = n, this.cause = s;
  }
};
var Nn = class {
  constructor() {
    this.F = 0, this.M = $n(), this.L = dt.EMPTY_BYTE_STRING, this.B = false, this.U = true;
  }
  get current() {
    return this.B;
  }
  get resumeToken() {
    return this.L;
  }
  get q() {
    return this.F !== 0;
  }
  get K() {
    return this.U;
  }
  j(t2) {
    t2.approximateByteSize() > 0 && (this.U = true, this.L = t2);
  }
  W() {
    let t2 = Rn(), e = Rn(), n = Rn();
    return this.M.forEach((s, i) => {
      switch (i) {
        case 0:
          t2 = t2.add(s);
          break;
        case 2:
          e = e.add(s);
          break;
        case 1:
          n = n.add(s);
          break;
        default:
          F2();
      }
    }), new Vn(this.L, this.B, t2, e, n);
  }
  G() {
    this.U = false, this.M = $n();
  }
  H(t2, e) {
    this.U = true, this.M = this.M.insert(t2, e);
  }
  J(t2) {
    this.U = true, this.M = this.M.remove(t2);
  }
  Y() {
    this.F += 1;
  }
  X() {
    this.F -= 1;
  }
  Z() {
    this.U = true, this.B = true;
  }
};
var xn = class {
  constructor(t2) {
    this.tt = t2, this.et = new Map(), this.nt = yn(), this.st = kn(), this.it = new _n(Z2);
  }
  rt(t2) {
    for (const e of t2.k)
      t2.$ && t2.$.isFoundDocument() ? this.ot(e, t2.$) : this.at(e, t2.key, t2.$);
    for (const e of t2.removedTargetIds)
      this.at(e, t2.key, t2.$);
  }
  ct(t2) {
    this.forEachTarget(t2, (e) => {
      const n = this.ut(e);
      switch (t2.state) {
        case 0:
          this.ht(e) && n.j(t2.resumeToken);
          break;
        case 1:
          n.X(), n.q || n.G(), n.j(t2.resumeToken);
          break;
        case 2:
          n.X(), n.q || this.removeTarget(e);
          break;
        case 3:
          this.ht(e) && (n.Z(), n.j(t2.resumeToken));
          break;
        case 4:
          this.ht(e) && (this.lt(e), n.j(t2.resumeToken));
          break;
        default:
          F2();
      }
    });
  }
  forEachTarget(t2, e) {
    t2.targetIds.length > 0 ? t2.targetIds.forEach(e) : this.et.forEach((t3, n) => {
      this.ht(n) && e(n);
    });
  }
  ft(t2) {
    const e = t2.targetId, n = t2.O.count, s = this.dt(e);
    if (s) {
      const t3 = s.target;
      if (Gt(t3))
        if (n === 0) {
          const n2 = new Rt(t3.path);
          this.at(e, n2, Ut.newNoDocument(n2, st.min()));
        } else
          M2(n === 1);
      else {
        this.wt(e) !== n && (this.lt(e), this.it = this.it.add(e));
      }
    }
  }
  _t(t2) {
    const e = new Map();
    this.et.forEach((n2, s2) => {
      const i = this.dt(s2);
      if (i) {
        if (n2.current && Gt(i.target)) {
          const e2 = new Rt(i.target.path);
          this.nt.get(e2) !== null || this.gt(s2, e2) || this.at(s2, e2, Ut.newNoDocument(e2, t2));
        }
        n2.K && (e.set(s2, n2.W()), n2.G());
      }
    });
    let n = Rn();
    this.st.forEach((t3, e2) => {
      let s2 = true;
      e2.forEachWhile((t4) => {
        const e3 = this.dt(t4);
        return !e3 || e3.purpose === 2 || (s2 = false, false);
      }), s2 && (n = n.add(t3));
    });
    const s = new vn(t2, e, this.it, this.nt, n);
    return this.nt = yn(), this.st = kn(), this.it = new _n(Z2), s;
  }
  ot(t2, e) {
    if (!this.ht(t2))
      return;
    const n = this.gt(t2, e.key) ? 2 : 0;
    this.ut(t2).H(e.key, n), this.nt = this.nt.insert(e.key, e), this.st = this.st.insert(e.key, this.yt(e.key).add(t2));
  }
  at(t2, e, n) {
    if (!this.ht(t2))
      return;
    const s = this.ut(t2);
    this.gt(t2, e) ? s.H(e, 1) : s.J(e), this.st = this.st.insert(e, this.yt(e).delete(t2)), n && (this.nt = this.nt.insert(e, n));
  }
  removeTarget(t2) {
    this.et.delete(t2);
  }
  wt(t2) {
    const e = this.ut(t2).W();
    return this.tt.getRemoteKeysForTarget(t2).size + e.addedDocuments.size - e.removedDocuments.size;
  }
  Y(t2) {
    this.ut(t2).Y();
  }
  ut(t2) {
    let e = this.et.get(t2);
    return e || (e = new Nn(), this.et.set(t2, e)), e;
  }
  yt(t2) {
    let e = this.st.get(t2);
    return e || (e = new _n(Z2), this.st = this.st.insert(t2, e)), e;
  }
  ht(t2) {
    const e = this.dt(t2) !== null;
    return e || x2("WatchChangeAggregator", "Detected inactive target", t2), e;
  }
  dt(t2) {
    const e = this.et.get(t2);
    return e && e.q ? null : this.tt.Et(t2);
  }
  lt(t2) {
    this.et.set(t2, new Nn());
    this.tt.getRemoteKeysForTarget(t2).forEach((e) => {
      this.at(t2, e, null);
    });
  }
  gt(t2, e) {
    return this.tt.getRemoteKeysForTarget(t2).has(e);
  }
};
function kn() {
  return new fn(Rt.comparator);
}
function $n() {
  return new fn(Rt.comparator);
}
var On = (() => {
  const t2 = {
    asc: "ASCENDING",
    desc: "DESCENDING"
  };
  return t2;
})();
var Fn = (() => {
  const t2 = {
    "<": "LESS_THAN",
    "<=": "LESS_THAN_OR_EQUAL",
    ">": "GREATER_THAN",
    ">=": "GREATER_THAN_OR_EQUAL",
    "==": "EQUAL",
    "!=": "NOT_EQUAL",
    "array-contains": "ARRAY_CONTAINS",
    in: "IN",
    "not-in": "NOT_IN",
    "array-contains-any": "ARRAY_CONTAINS_ANY"
  };
  return t2;
})();
var Mn = class {
  constructor(t2, e) {
    this.databaseId = t2, this.D = e;
  }
};
function Ln(t2, e) {
  if (t2.D) {
    return `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z`;
  }
  return {
    seconds: "" + e.seconds,
    nanos: e.nanoseconds
  };
}
function Bn(t2, e) {
  return t2.D ? e.toBase64() : e.toUint8Array();
}
function Un(t2, e) {
  return Ln(t2, e.toTimestamp());
}
function qn(t2) {
  return M2(!!t2), st.fromTimestamp(function(t3) {
    const e = _t(t3);
    return new nt(e.seconds, e.nanos);
  }(t2));
}
function Kn(t2, e) {
  return function(t3) {
    return new ct(["projects", t3.projectId, "databases", t3.database]);
  }(t2).child("documents").child(e).canonicalString();
}
function jn(t2) {
  const e = ct.fromString(t2);
  return M2(ys(e)), e;
}
function Qn(t2, e) {
  return Kn(t2.databaseId, e.path);
}
function Wn(t2, e) {
  const n = jn(e);
  if (n.get(1) !== t2.databaseId.projectId)
    throw new q2(U2.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n.get(1) + " vs " + t2.databaseId.projectId);
  if (n.get(3) !== t2.databaseId.database)
    throw new q2(U2.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n.get(3) + " vs " + t2.databaseId.database);
  return new Rt(Jn(n));
}
function Gn(t2, e) {
  return Kn(t2.databaseId, e);
}
function zn(t2) {
  const e = jn(t2);
  return e.length === 4 ? ct.emptyPath() : Jn(e);
}
function Hn(t2) {
  return new ct(["projects", t2.databaseId.projectId, "databases", t2.databaseId.database]).canonicalString();
}
function Jn(t2) {
  return M2(t2.length > 4 && t2.get(4) === "documents"), t2.popFirst(5);
}
function Yn(t2, e, n) {
  return {
    name: Qn(t2, e),
    fields: n.value.mapValue.fields
  };
}
function Xn(t2, e, n) {
  const s = Wn(t2, e.name), i = qn(e.updateTime), r = new Lt({
    mapValue: {
      fields: e.fields
    }
  }), o = Ut.newFoundDocument(s, i, r);
  return n && o.setHasCommittedMutations(), n ? o.setHasCommittedMutations() : o;
}
function Zn(t2, e) {
  return "found" in e ? function(t3, e2) {
    M2(!!e2.found), e2.found.name, e2.found.updateTime;
    const n = Wn(t3, e2.found.name), s = qn(e2.found.updateTime), i = new Lt({
      mapValue: {
        fields: e2.found.fields
      }
    });
    return Ut.newFoundDocument(n, s, i);
  }(t2, e) : "missing" in e ? function(t3, e2) {
    M2(!!e2.missing), M2(!!e2.readTime);
    const n = Wn(t3, e2.missing), s = qn(e2.readTime);
    return Ut.newNoDocument(n, s);
  }(t2, e) : F2();
}
function ts(t2, e) {
  let n;
  if ("targetChange" in e) {
    e.targetChange;
    const s = function(t3) {
      return t3 === "NO_CHANGE" ? 0 : t3 === "ADD" ? 1 : t3 === "REMOVE" ? 2 : t3 === "CURRENT" ? 3 : t3 === "RESET" ? 4 : F2();
    }(e.targetChange.targetChangeType || "NO_CHANGE"), i = e.targetChange.targetIds || [], r = function(t3, e2) {
      return t3.D ? (M2(e2 === void 0 || typeof e2 == "string"), dt.fromBase64String(e2 || "")) : (M2(e2 === void 0 || e2 instanceof Uint8Array), dt.fromUint8Array(e2 || new Uint8Array()));
    }(t2, e.targetChange.resumeToken), o = e.targetChange.cause, a = o && function(t3) {
      const e2 = t3.code === void 0 ? U2.UNKNOWN : ln(t3.code);
      return new q2(e2, t3.message || "");
    }(o);
    n = new Cn(s, i, r, a || null);
  } else if ("documentChange" in e) {
    e.documentChange;
    const s = e.documentChange;
    s.document, s.document.name, s.document.updateTime;
    const i = Wn(t2, s.document.name), r = qn(s.document.updateTime), o = new Lt({
      mapValue: {
        fields: s.document.fields
      }
    }), a = Ut.newFoundDocument(i, r, o), c = s.targetIds || [], u = s.removedTargetIds || [];
    n = new Sn(c, u, a.key, a);
  } else if ("documentDelete" in e) {
    e.documentDelete;
    const s = e.documentDelete;
    s.document;
    const i = Wn(t2, s.document), r = s.readTime ? qn(s.readTime) : st.min(), o = Ut.newNoDocument(i, r), a = s.removedTargetIds || [];
    n = new Sn([], a, o.key, o);
  } else if ("documentRemove" in e) {
    e.documentRemove;
    const s = e.documentRemove;
    s.document;
    const i = Wn(t2, s.document), r = s.removedTargetIds || [];
    n = new Sn([], r, i, null);
  } else {
    if (!("filter" in e))
      return F2();
    {
      e.filter;
      const t3 = e.filter;
      t3.targetId;
      const s = t3.count || 0, i = new an(s), r = t3.targetId;
      n = new Dn(r, i);
    }
  }
  return n;
}
function es(t2, e) {
  let n;
  if (e instanceof Ze)
    n = {
      update: Yn(t2, e.key, e.value)
    };
  else if (e instanceof rn)
    n = {
      delete: Qn(t2, e.key)
    };
  else if (e instanceof tn)
    n = {
      update: Yn(t2, e.key, e.data),
      updateMask: gs(e.fieldMask)
    };
  else {
    if (!(e instanceof on))
      return F2();
    n = {
      verify: Qn(t2, e.key)
    };
  }
  return e.fieldTransforms.length > 0 && (n.updateTransforms = e.fieldTransforms.map((t3) => function(t4, e2) {
    const n2 = e2.transform;
    if (n2 instanceof ke)
      return {
        fieldPath: e2.field.canonicalString(),
        setToServerValue: "REQUEST_TIME"
      };
    if (n2 instanceof $e)
      return {
        fieldPath: e2.field.canonicalString(),
        appendMissingElements: {
          values: n2.elements
        }
      };
    if (n2 instanceof Fe)
      return {
        fieldPath: e2.field.canonicalString(),
        removeAllFromArray: {
          values: n2.elements
        }
      };
    if (n2 instanceof Le)
      return {
        fieldPath: e2.field.canonicalString(),
        increment: n2.C
      };
    throw F2();
  }(0, t3))), e.precondition.isNone || (n.currentDocument = function(t3, e2) {
    return e2.updateTime !== void 0 ? {
      updateTime: Un(t3, e2.updateTime)
    } : e2.exists !== void 0 ? {
      exists: e2.exists
    } : F2();
  }(t2, e.precondition)), n;
}
function ns(t2, e) {
  const n = e.currentDocument ? function(t3) {
    return t3.updateTime !== void 0 ? Qe.updateTime(qn(t3.updateTime)) : t3.exists !== void 0 ? Qe.exists(t3.exists) : Qe.none();
  }(e.currentDocument) : Qe.none(), s = e.updateTransforms ? e.updateTransforms.map((e2) => function(t3, e3) {
    let n2 = null;
    if ("setToServerValue" in e3)
      M2(e3.setToServerValue === "REQUEST_TIME"), n2 = new ke();
    else if ("appendMissingElements" in e3) {
      const t4 = e3.appendMissingElements.values || [];
      n2 = new $e(t4);
    } else if ("removeAllFromArray" in e3) {
      const t4 = e3.removeAllFromArray.values || [];
      n2 = new Fe(t4);
    } else
      "increment" in e3 ? n2 = new Le(t3, e3.increment) : F2();
    const s2 = ht.fromServerFormat(e3.fieldPath);
    return new qe(s2, n2);
  }(t2, e2)) : [];
  if (e.update) {
    e.update.name;
    const i = Wn(t2, e.update.name), r = new Lt({
      mapValue: {
        fields: e.update.fields
      }
    });
    if (e.updateMask) {
      const t3 = function(t4) {
        const e2 = t4.fieldPaths || [];
        return new lt(e2.map((t5) => ht.fromServerFormat(t5)));
      }(e.updateMask);
      return new tn(i, r, t3, n, s);
    }
    return new Ze(i, r, n, s);
  }
  if (e.delete) {
    const s2 = Wn(t2, e.delete);
    return new rn(s2, n);
  }
  if (e.verify) {
    const s2 = Wn(t2, e.verify);
    return new on(s2, n);
  }
  return F2();
}
function ss(t2, e) {
  return t2 && t2.length > 0 ? (M2(e !== void 0), t2.map((t3) => function(t4, e2) {
    let n = t4.updateTime ? qn(t4.updateTime) : qn(e2);
    return n.isEqual(st.min()) && (n = qn(e2)), new je(n, t4.transformResults || []);
  }(t3, e))) : [];
}
function is(t2, e) {
  return {
    documents: [Gn(t2, e.path)]
  };
}
function rs(t2, e) {
  const n = {
    structuredQuery: {}
  }, s = e.path;
  e.collectionGroup !== null ? (n.parent = Gn(t2, s), n.structuredQuery.from = [{
    collectionId: e.collectionGroup,
    allDescendants: true
  }]) : (n.parent = Gn(t2, s.popLast()), n.structuredQuery.from = [{
    collectionId: s.lastSegment()
  }]);
  const i = function(t3) {
    if (t3.length === 0)
      return;
    const e2 = t3.map((t4) => function(t5) {
      if (t5.op === "==") {
        if (Ot(t5.value))
          return {
            unaryFilter: {
              field: ds(t5.field),
              op: "IS_NAN"
            }
          };
        if ($t(t5.value))
          return {
            unaryFilter: {
              field: ds(t5.field),
              op: "IS_NULL"
            }
          };
      } else if (t5.op === "!=") {
        if (Ot(t5.value))
          return {
            unaryFilter: {
              field: ds(t5.field),
              op: "IS_NOT_NAN"
            }
          };
        if ($t(t5.value))
          return {
            unaryFilter: {
              field: ds(t5.field),
              op: "IS_NOT_NULL"
            }
          };
      }
      return {
        fieldFilter: {
          field: ds(t5.field),
          op: fs(t5.op),
          value: t5.value
        }
      };
    }(t4));
    if (e2.length === 1)
      return e2[0];
    return {
      compositeFilter: {
        op: "AND",
        filters: e2
      }
    };
  }(e.filters);
  i && (n.structuredQuery.where = i);
  const r = function(t3) {
    if (t3.length === 0)
      return;
    return t3.map((t4) => function(t5) {
      return {
        field: ds(t5.field),
        direction: ls(t5.dir)
      };
    }(t4));
  }(e.orderBy);
  r && (n.structuredQuery.orderBy = r);
  const o = function(t3, e2) {
    return t3.D || Tt(e2) ? e2 : {
      value: e2
    };
  }(t2, e.limit);
  return o !== null && (n.structuredQuery.limit = o), e.startAt && (n.structuredQuery.startAt = us(e.startAt)), e.endAt && (n.structuredQuery.endAt = us(e.endAt)), n;
}
function os(t2) {
  let e = zn(t2.parent);
  const n = t2.structuredQuery, s = n.from ? n.from.length : 0;
  let i = null;
  if (s > 0) {
    M2(s === 1);
    const t3 = n.from[0];
    t3.allDescendants ? i = t3.collectionId : e = e.child(t3.collectionId);
  }
  let r = [];
  n.where && (r = cs(n.where));
  let o = [];
  n.orderBy && (o = n.orderBy.map((t3) => function(t4) {
    return new oe(ws(t4.field), function(t5) {
      switch (t5) {
        case "ASCENDING":
          return "asc";
        case "DESCENDING":
          return "desc";
        default:
          return;
      }
    }(t4.direction));
  }(t3)));
  let a = null;
  n.limit && (a = function(t3) {
    let e2;
    return e2 = typeof t3 == "object" ? t3.value : t3, Tt(e2) ? null : e2;
  }(n.limit));
  let c = null;
  n.startAt && (c = hs(n.startAt));
  let u = null;
  return n.endAt && (u = hs(n.endAt)), le(e, i, o, r, a, "F", c, u);
}
function as(t2, e) {
  const n = function(t3, e2) {
    switch (e2) {
      case 0:
        return null;
      case 1:
        return "existence-filter-mismatch";
      case 2:
        return "limbo-document";
      default:
        return F2();
    }
  }(0, e.purpose);
  return n == null ? null : {
    "goog-listen-tags": n
  };
}
function cs(t2) {
  return t2 ? t2.unaryFilter !== void 0 ? [ms(t2)] : t2.fieldFilter !== void 0 ? [_s(t2)] : t2.compositeFilter !== void 0 ? t2.compositeFilter.filters.map((t3) => cs(t3)).reduce((t3, e) => t3.concat(e)) : F2() : [];
}
function us(t2) {
  return {
    before: t2.before,
    values: t2.position
  };
}
function hs(t2) {
  const e = !!t2.before, n = t2.values || [];
  return new ie(n, e);
}
function ls(t2) {
  return On[t2];
}
function fs(t2) {
  return Fn[t2];
}
function ds(t2) {
  return {
    fieldPath: t2.canonicalString()
  };
}
function ws(t2) {
  return ht.fromServerFormat(t2.fieldPath);
}
function _s(t2) {
  return zt.create(ws(t2.fieldFilter.field), function(t3) {
    switch (t3) {
      case "EQUAL":
        return "==";
      case "NOT_EQUAL":
        return "!=";
      case "GREATER_THAN":
        return ">";
      case "GREATER_THAN_OR_EQUAL":
        return ">=";
      case "LESS_THAN":
        return "<";
      case "LESS_THAN_OR_EQUAL":
        return "<=";
      case "ARRAY_CONTAINS":
        return "array-contains";
      case "IN":
        return "in";
      case "NOT_IN":
        return "not-in";
      case "ARRAY_CONTAINS_ANY":
        return "array-contains-any";
      case "OPERATOR_UNSPECIFIED":
      default:
        return F2();
    }
  }(t2.fieldFilter.op), t2.fieldFilter.value);
}
function ms(t2) {
  switch (t2.unaryFilter.op) {
    case "IS_NAN":
      const e = ws(t2.unaryFilter.field);
      return zt.create(e, "==", {
        doubleValue: NaN
      });
    case "IS_NULL":
      const n = ws(t2.unaryFilter.field);
      return zt.create(n, "==", {
        nullValue: "NULL_VALUE"
      });
    case "IS_NOT_NAN":
      const s = ws(t2.unaryFilter.field);
      return zt.create(s, "!=", {
        doubleValue: NaN
      });
    case "IS_NOT_NULL":
      const i = ws(t2.unaryFilter.field);
      return zt.create(i, "!=", {
        nullValue: "NULL_VALUE"
      });
    case "OPERATOR_UNSPECIFIED":
    default:
      return F2();
  }
}
function gs(t2) {
  const e = [];
  return t2.fields.forEach((t3) => e.push(t3.canonicalString())), {
    fieldPaths: e
  };
}
function ys(t2) {
  return t2.length >= 4 && t2.get(0) === "projects" && t2.get(2) === "databases";
}
function ps(t2) {
  let e = "";
  for (let n = 0; n < t2.length; n++)
    e.length > 0 && (e = Ts(e)), e = Es(t2.get(n), e);
  return Ts(e);
}
function Es(t2, e) {
  let n = e;
  const s = t2.length;
  for (let e2 = 0; e2 < s; e2++) {
    const s2 = t2.charAt(e2);
    switch (s2) {
      case "\0":
        n += "";
        break;
      case "":
        n += "";
        break;
      default:
        n += s2;
    }
  }
  return n;
}
function Ts(t2) {
  return t2 + "";
}
function Is(t2) {
  const e = t2.length;
  if (M2(e >= 2), e === 2)
    return M2(t2.charAt(0) === "" && t2.charAt(1) === ""), ct.emptyPath();
  const n = e - 2, s = [];
  let i = "";
  for (let r = 0; r < e; ) {
    const e2 = t2.indexOf("", r);
    (e2 < 0 || e2 > n) && F2();
    switch (t2.charAt(e2 + 1)) {
      case "":
        const n2 = t2.substring(r, e2);
        let o;
        i.length === 0 ? o = n2 : (i += n2, o = i, i = ""), s.push(o);
        break;
      case "":
        i += t2.substring(r, e2), i += "\0";
        break;
      case "":
        i += t2.substring(r, e2 + 1);
        break;
      default:
        F2();
    }
    r = e2 + 2;
  }
  return new ct(s);
}
var As = class {
  constructor(t2, e) {
    this.seconds = t2, this.nanoseconds = e;
  }
};
var Rs = class {
  constructor(t2, e, n) {
    this.ownerId = t2, this.allowTabSynchronization = e, this.leaseTimestampMs = n;
  }
};
Rs.store = "owner", Rs.key = "owner";
var bs = class {
  constructor(t2, e, n) {
    this.userId = t2, this.lastAcknowledgedBatchId = e, this.lastStreamToken = n;
  }
};
bs.store = "mutationQueues", bs.keyPath = "userId";
var Ps = class {
  constructor(t2, e, n, s, i) {
    this.userId = t2, this.batchId = e, this.localWriteTimeMs = n, this.baseMutations = s, this.mutations = i;
  }
};
Ps.store = "mutations", Ps.keyPath = "batchId", Ps.userMutationsIndex = "userMutationsIndex", Ps.userMutationsKeyPath = ["userId", "batchId"];
var vs = class {
  constructor() {
  }
  static prefixForUser(t2) {
    return [t2];
  }
  static prefixForPath(t2, e) {
    return [t2, ps(e)];
  }
  static key(t2, e, n) {
    return [t2, ps(e), n];
  }
};
vs.store = "documentMutations", vs.PLACEHOLDER = new vs();
var Vs = class {
  constructor(t2, e) {
    this.path = t2, this.readTime = e;
  }
};
var Ss = class {
  constructor(t2, e) {
    this.path = t2, this.version = e;
  }
};
var Ds = class {
  constructor(t2, e, n, s, i, r) {
    this.unknownDocument = t2, this.noDocument = e, this.document = n, this.hasCommittedMutations = s, this.readTime = i, this.parentPath = r;
  }
};
Ds.store = "remoteDocuments", Ds.readTimeIndex = "readTimeIndex", Ds.readTimeIndexPath = "readTime", Ds.collectionReadTimeIndex = "collectionReadTimeIndex", Ds.collectionReadTimeIndexPath = ["parentPath", "readTime"];
var Cs = class {
  constructor(t2) {
    this.byteSize = t2;
  }
};
Cs.store = "remoteDocumentGlobal", Cs.key = "remoteDocumentGlobalKey";
var Ns = class {
  constructor(t2, e, n, s, i, r, o) {
    this.targetId = t2, this.canonicalId = e, this.readTime = n, this.resumeToken = s, this.lastListenSequenceNumber = i, this.lastLimboFreeSnapshotVersion = r, this.query = o;
  }
};
Ns.store = "targets", Ns.keyPath = "targetId", Ns.queryTargetsIndexName = "queryTargetsIndex", Ns.queryTargetsKeyPath = ["canonicalId", "targetId"];
var xs = class {
  constructor(t2, e, n) {
    this.targetId = t2, this.path = e, this.sequenceNumber = n;
  }
};
xs.store = "targetDocuments", xs.keyPath = ["targetId", "path"], xs.documentTargetsIndex = "documentTargetsIndex", xs.documentTargetsKeyPath = ["path", "targetId"];
var ks = class {
  constructor(t2, e, n, s) {
    this.highestTargetId = t2, this.highestListenSequenceNumber = e, this.lastRemoteSnapshotVersion = n, this.targetCount = s;
  }
};
ks.key = "targetGlobalKey", ks.store = "targetGlobal";
var $s = class {
  constructor(t2, e) {
    this.collectionId = t2, this.parent = e;
  }
};
$s.store = "collectionParents", $s.keyPath = ["collectionId", "parent"];
var Os = class {
  constructor(t2, e, n, s) {
    this.clientId = t2, this.updateTimeMs = e, this.networkEnabled = n, this.inForeground = s;
  }
};
Os.store = "clientMetadata", Os.keyPath = "clientId";
var Fs = class {
  constructor(t2, e, n) {
    this.bundleId = t2, this.createTime = e, this.version = n;
  }
};
Fs.store = "bundles", Fs.keyPath = "bundleId";
var Ms = class {
  constructor(t2, e, n) {
    this.name = t2, this.readTime = e, this.bundledQuery = n;
  }
};
Ms.store = "namedQueries", Ms.keyPath = "name";
var Ls = [...[...[...[...[bs.store, Ps.store, vs.store, Ds.store, Ns.store, Rs.store, ks.store, xs.store], Os.store], Cs.store], $s.store], Fs.store, Ms.store];
var Bs = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
var Us = class {
  constructor() {
    this.onCommittedListeners = [];
  }
  addOnCommittedListener(t2) {
    this.onCommittedListeners.push(t2);
  }
  raiseOnCommittedEvent() {
    this.onCommittedListeners.forEach((t2) => t2());
  }
};
var qs = class {
  constructor(t2) {
    this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = false, this.callbackAttached = false, t2((t3) => {
      this.isDone = true, this.result = t3, this.nextCallback && this.nextCallback(t3);
    }, (t3) => {
      this.isDone = true, this.error = t3, this.catchCallback && this.catchCallback(t3);
    });
  }
  catch(t2) {
    return this.next(void 0, t2);
  }
  next(t2, e) {
    return this.callbackAttached && F2(), this.callbackAttached = true, this.isDone ? this.error ? this.wrapFailure(e, this.error) : this.wrapSuccess(t2, this.result) : new qs((n, s) => {
      this.nextCallback = (e2) => {
        this.wrapSuccess(t2, e2).next(n, s);
      }, this.catchCallback = (t3) => {
        this.wrapFailure(e, t3).next(n, s);
      };
    });
  }
  toPromise() {
    return new Promise((t2, e) => {
      this.next(t2, e);
    });
  }
  wrapUserFunction(t2) {
    try {
      const e = t2();
      return e instanceof qs ? e : qs.resolve(e);
    } catch (t3) {
      return qs.reject(t3);
    }
  }
  wrapSuccess(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : qs.resolve(e);
  }
  wrapFailure(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : qs.reject(e);
  }
  static resolve(t2) {
    return new qs((e, n) => {
      e(t2);
    });
  }
  static reject(t2) {
    return new qs((e, n) => {
      n(t2);
    });
  }
  static waitFor(t2) {
    return new qs((e, n) => {
      let s = 0, i = 0, r = false;
      t2.forEach((t3) => {
        ++s, t3.next(() => {
          ++i, r && i === s && e();
        }, (t4) => n(t4));
      }), r = true, i === s && e();
    });
  }
  static or(t2) {
    let e = qs.resolve(false);
    for (const n of t2)
      e = e.next((t3) => t3 ? qs.resolve(t3) : n());
    return e;
  }
  static forEach(t2, e) {
    const n = [];
    return t2.forEach((t3, s) => {
      n.push(e.call(this, t3, s));
    }), this.waitFor(n);
  }
};
var Ks = class {
  constructor(t2, e) {
    this.action = t2, this.transaction = e, this.aborted = false, this.Tt = new K2(), this.transaction.oncomplete = () => {
      this.Tt.resolve();
    }, this.transaction.onabort = () => {
      e.error ? this.Tt.reject(new Ws(t2, e.error)) : this.Tt.resolve();
    }, this.transaction.onerror = (e2) => {
      const n = Ys(e2.target.error);
      this.Tt.reject(new Ws(t2, n));
    };
  }
  static open(t2, e, n, s) {
    try {
      return new Ks(e, t2.transaction(s, n));
    } catch (t3) {
      throw new Ws(e, t3);
    }
  }
  get It() {
    return this.Tt.promise;
  }
  abort(t2) {
    t2 && this.Tt.reject(t2), this.aborted || (x2("SimpleDb", "Aborting transaction:", t2 ? t2.message : "Client-initiated abort"), this.aborted = true, this.transaction.abort());
  }
  store(t2) {
    const e = this.transaction.objectStore(t2);
    return new zs(e);
  }
};
var js = class {
  constructor(t2, e, n) {
    this.name = t2, this.version = e, this.At = n;
    js.Rt(getUA()) === 12.2 && k2("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
  }
  static delete(t2) {
    return x2("SimpleDb", "Removing database:", t2), Hs(window.indexedDB.deleteDatabase(t2)).toPromise();
  }
  static bt() {
    if (typeof indexedDB == "undefined")
      return false;
    if (js.Pt())
      return true;
    const t2 = getUA(), e = js.Rt(t2), n = 0 < e && e < 10, s = js.vt(t2), i = 0 < s && s < 4.5;
    return !(t2.indexOf("MSIE ") > 0 || t2.indexOf("Trident/") > 0 || t2.indexOf("Edge/") > 0 || n || i);
  }
  static Pt() {
    var t2;
    return typeof process != "undefined" && ((t2 = process.env) === null || t2 === void 0 ? void 0 : t2.Vt) === "YES";
  }
  static St(t2, e) {
    return t2.store(e);
  }
  static Rt(t2) {
    const e = t2.match(/i(?:phone|pad|pod) os ([\d_]+)/i), n = e ? e[1].split("_").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  static vt(t2) {
    const e = t2.match(/Android ([\d.]+)/i), n = e ? e[1].split(".").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  async Dt(t2) {
    return this.db || (x2("SimpleDb", "Opening database:", this.name), this.db = await new Promise((e, n) => {
      const s = indexedDB.open(this.name, this.version);
      s.onsuccess = (t3) => {
        const n2 = t3.target.result;
        e(n2);
      }, s.onblocked = () => {
        n(new Ws(t2, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."));
      }, s.onerror = (e2) => {
        const s2 = e2.target.error;
        s2.name === "VersionError" ? n(new q2(U2.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.")) : s2.name === "InvalidStateError" ? n(new q2(U2.FAILED_PRECONDITION, "Unable to open an IndexedDB connection. This could be due to running in a private browsing session on a browser whose private browsing sessions do not support IndexedDB: " + s2)) : n(new Ws(t2, s2));
      }, s.onupgradeneeded = (t3) => {
        x2("SimpleDb", 'Database "' + this.name + '" requires upgrade from version:', t3.oldVersion);
        const e2 = t3.target.result;
        this.At.Ct(e2, s.transaction, t3.oldVersion, this.version).next(() => {
          x2("SimpleDb", "Database upgrade to version " + this.version + " complete");
        });
      };
    })), this.Nt && (this.db.onversionchange = (t3) => this.Nt(t3)), this.db;
  }
  xt(t2) {
    this.Nt = t2, this.db && (this.db.onversionchange = (e) => t2(e));
  }
  async runTransaction(t2, e, n, s) {
    const i = e === "readonly";
    let r = 0;
    for (; ; ) {
      ++r;
      try {
        this.db = await this.Dt(t2);
        const e2 = Ks.open(this.db, t2, i ? "readonly" : "readwrite", n), r2 = s(e2).catch((t3) => (e2.abort(t3), qs.reject(t3))).toPromise();
        return r2.catch(() => {
        }), await e2.It, r2;
      } catch (t3) {
        const e2 = t3.name !== "FirebaseError" && r < 3;
        if (x2("SimpleDb", "Transaction failed with error:", t3.message, "Retrying:", e2), this.close(), !e2)
          return Promise.reject(t3);
      }
    }
  }
  close() {
    this.db && this.db.close(), this.db = void 0;
  }
};
var Qs = class {
  constructor(t2) {
    this.kt = t2, this.$t = false, this.Ot = null;
  }
  get isDone() {
    return this.$t;
  }
  get Ft() {
    return this.Ot;
  }
  set cursor(t2) {
    this.kt = t2;
  }
  done() {
    this.$t = true;
  }
  Mt(t2) {
    this.Ot = t2;
  }
  delete() {
    return Hs(this.kt.delete());
  }
};
var Ws = class extends q2 {
  constructor(t2, e) {
    super(U2.UNAVAILABLE, `IndexedDB transaction '${t2}' failed: ${e}`), this.name = "IndexedDbTransactionError";
  }
};
function Gs(t2) {
  return t2.name === "IndexedDbTransactionError";
}
var zs = class {
  constructor(t2) {
    this.store = t2;
  }
  put(t2, e) {
    let n;
    return e !== void 0 ? (x2("SimpleDb", "PUT", this.store.name, t2, e), n = this.store.put(e, t2)) : (x2("SimpleDb", "PUT", this.store.name, "<auto-key>", t2), n = this.store.put(t2)), Hs(n);
  }
  add(t2) {
    x2("SimpleDb", "ADD", this.store.name, t2, t2);
    return Hs(this.store.add(t2));
  }
  get(t2) {
    return Hs(this.store.get(t2)).next((e) => (e === void 0 && (e = null), x2("SimpleDb", "GET", this.store.name, t2, e), e));
  }
  delete(t2) {
    x2("SimpleDb", "DELETE", this.store.name, t2);
    return Hs(this.store.delete(t2));
  }
  count() {
    x2("SimpleDb", "COUNT", this.store.name);
    return Hs(this.store.count());
  }
  Lt(t2, e) {
    const n = this.cursor(this.options(t2, e)), s = [];
    return this.Bt(n, (t3, e2) => {
      s.push(e2);
    }).next(() => s);
  }
  Ut(t2, e) {
    x2("SimpleDb", "DELETE ALL", this.store.name);
    const n = this.options(t2, e);
    n.qt = false;
    const s = this.cursor(n);
    return this.Bt(s, (t3, e2, n2) => n2.delete());
  }
  Kt(t2, e) {
    let n;
    e ? n = t2 : (n = {}, e = t2);
    const s = this.cursor(n);
    return this.Bt(s, e);
  }
  jt(t2) {
    const e = this.cursor({});
    return new qs((n, s) => {
      e.onerror = (t3) => {
        const e2 = Ys(t3.target.error);
        s(e2);
      }, e.onsuccess = (e2) => {
        const s2 = e2.target.result;
        s2 ? t2(s2.primaryKey, s2.value).next((t3) => {
          t3 ? s2.continue() : n();
        }) : n();
      };
    });
  }
  Bt(t2, e) {
    const n = [];
    return new qs((s, i) => {
      t2.onerror = (t3) => {
        i(t3.target.error);
      }, t2.onsuccess = (t3) => {
        const i2 = t3.target.result;
        if (!i2)
          return void s();
        const r = new Qs(i2), o = e(i2.primaryKey, i2.value, r);
        if (o instanceof qs) {
          const t4 = o.catch((t5) => (r.done(), qs.reject(t5)));
          n.push(t4);
        }
        r.isDone ? s() : r.Ft === null ? i2.continue() : i2.continue(r.Ft);
      };
    }).next(() => qs.waitFor(n));
  }
  options(t2, e) {
    let n;
    return t2 !== void 0 && (typeof t2 == "string" ? n = t2 : e = t2), {
      index: n,
      range: e
    };
  }
  cursor(t2) {
    let e = "next";
    if (t2.reverse && (e = "prev"), t2.index) {
      const n = this.store.index(t2.index);
      return t2.qt ? n.openKeyCursor(t2.range, e) : n.openCursor(t2.range, e);
    }
    return this.store.openCursor(t2.range, e);
  }
};
function Hs(t2) {
  return new qs((e, n) => {
    t2.onsuccess = (t3) => {
      const n2 = t3.target.result;
      e(n2);
    }, t2.onerror = (t3) => {
      const e2 = Ys(t3.target.error);
      n(e2);
    };
  });
}
var Js = false;
function Ys(t2) {
  const e = js.Rt(getUA());
  if (e >= 12.2 && e < 13) {
    const e2 = "An internal error was encountered in the Indexed Database server";
    if (t2.message.indexOf(e2) >= 0) {
      const t3 = new q2("internal", `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${e2}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`);
      return Js || (Js = true, setTimeout(() => {
        throw t3;
      }, 0)), t3;
    }
  }
  return t2;
}
var Xs = class extends Us {
  constructor(t2, e) {
    super(), this.Qt = t2, this.currentSequenceNumber = e;
  }
};
function Zs(t2, e) {
  const n = B2(t2);
  return js.St(n.Qt, e);
}
var ti = class {
  constructor(t2, e, n, s) {
    this.batchId = t2, this.localWriteTime = e, this.baseMutations = n, this.mutations = s;
  }
  applyToRemoteDocument(t2, e) {
    const n = e.mutationResults;
    for (let e2 = 0; e2 < this.mutations.length; e2++) {
      const s = this.mutations[e2];
      if (s.key.isEqual(t2.key)) {
        ze(s, t2, n[e2]);
      }
    }
  }
  applyToLocalView(t2) {
    for (const e of this.baseMutations)
      e.key.isEqual(t2.key) && He(e, t2, this.localWriteTime);
    for (const e of this.mutations)
      e.key.isEqual(t2.key) && He(e, t2, this.localWriteTime);
  }
  applyToLocalDocumentSet(t2) {
    this.mutations.forEach((e) => {
      const n = t2.get(e.key), s = n;
      this.applyToLocalView(s), n.isValidDocument() || s.convertToNoDocument(st.min());
    });
  }
  keys() {
    return this.mutations.reduce((t2, e) => t2.add(e.key), Rn());
  }
  isEqual(t2) {
    return this.batchId === t2.batchId && tt(this.mutations, t2.mutations, (t3, e) => Ye(t3, e)) && tt(this.baseMutations, t2.baseMutations, (t3, e) => Ye(t3, e));
  }
};
var ei = class {
  constructor(t2, e, n, s) {
    this.batch = t2, this.commitVersion = e, this.mutationResults = n, this.docVersions = s;
  }
  static from(t2, e, n) {
    M2(t2.mutations.length === n.length);
    let s = In();
    const i = t2.mutations;
    for (let t3 = 0; t3 < i.length; t3++)
      s = s.insert(i[t3].key, n[t3].version);
    return new ei(t2, e, n, s);
  }
};
var ni = class {
  constructor(t2, e, n, s, i = st.min(), r = st.min(), o = dt.EMPTY_BYTE_STRING) {
    this.target = t2, this.targetId = e, this.purpose = n, this.sequenceNumber = s, this.snapshotVersion = i, this.lastLimboFreeSnapshotVersion = r, this.resumeToken = o;
  }
  withSequenceNumber(t2) {
    return new ni(this.target, this.targetId, this.purpose, t2, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken);
  }
  withResumeToken(t2, e) {
    return new ni(this.target, this.targetId, this.purpose, this.sequenceNumber, e, this.lastLimboFreeSnapshotVersion, t2);
  }
  withLastLimboFreeSnapshotVersion(t2) {
    return new ni(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, t2, this.resumeToken);
  }
};
var si = class {
  constructor(t2) {
    this.Wt = t2;
  }
};
function ii(t2, e) {
  if (e.document)
    return Xn(t2.Wt, e.document, !!e.hasCommittedMutations);
  if (e.noDocument) {
    const t3 = Rt.fromSegments(e.noDocument.path), n = ui(e.noDocument.readTime), s = Ut.newNoDocument(t3, n);
    return e.hasCommittedMutations ? s.setHasCommittedMutations() : s;
  }
  if (e.unknownDocument) {
    const t3 = Rt.fromSegments(e.unknownDocument.path), n = ui(e.unknownDocument.version);
    return Ut.newUnknownDocument(t3, n);
  }
  return F2();
}
function ri(t2, e, n) {
  const s = oi(n), i = e.key.path.popLast().toArray();
  if (e.isFoundDocument()) {
    const n2 = function(t3, e2) {
      return {
        name: Qn(t3, e2.key),
        fields: e2.data.value.mapValue.fields,
        updateTime: Ln(t3, e2.version.toTimestamp())
      };
    }(t2.Wt, e), r = e.hasCommittedMutations;
    return new Ds(null, null, n2, r, s, i);
  }
  if (e.isNoDocument()) {
    const t3 = e.key.path.toArray(), n2 = ci(e.version), r = e.hasCommittedMutations;
    return new Ds(null, new Vs(t3, n2), null, r, s, i);
  }
  if (e.isUnknownDocument()) {
    const t3 = e.key.path.toArray(), n2 = ci(e.version);
    return new Ds(new Ss(t3, n2), null, null, true, s, i);
  }
  return F2();
}
function oi(t2) {
  const e = t2.toTimestamp();
  return [e.seconds, e.nanoseconds];
}
function ai(t2) {
  const e = new nt(t2[0], t2[1]);
  return st.fromTimestamp(e);
}
function ci(t2) {
  const e = t2.toTimestamp();
  return new As(e.seconds, e.nanoseconds);
}
function ui(t2) {
  const e = new nt(t2.seconds, t2.nanoseconds);
  return st.fromTimestamp(e);
}
function hi(t2, e) {
  const n = (e.baseMutations || []).map((e2) => ns(t2.Wt, e2));
  for (let t3 = 0; t3 < e.mutations.length - 1; ++t3) {
    const n2 = e.mutations[t3];
    if (t3 + 1 < e.mutations.length && e.mutations[t3 + 1].transform !== void 0) {
      const s2 = e.mutations[t3 + 1];
      n2.updateTransforms = s2.transform.fieldTransforms, e.mutations.splice(t3 + 1, 1), ++t3;
    }
  }
  const s = e.mutations.map((e2) => ns(t2.Wt, e2)), i = nt.fromMillis(e.localWriteTimeMs);
  return new ti(e.batchId, i, n, s);
}
function li(t2) {
  const e = ui(t2.readTime), n = t2.lastLimboFreeSnapshotVersion !== void 0 ? ui(t2.lastLimboFreeSnapshotVersion) : st.min();
  let s;
  var i;
  return t2.query.documents !== void 0 ? (M2((i = t2.query).documents.length === 1), s = pe(fe(zn(i.documents[0])))) : s = function(t3) {
    return pe(os(t3));
  }(t2.query), new ni(s, t2.targetId, 0, t2.lastListenSequenceNumber, e, n, dt.fromBase64String(t2.resumeToken));
}
function fi(t2, e) {
  const n = ci(e.snapshotVersion), s = ci(e.lastLimboFreeSnapshotVersion);
  let i;
  i = Gt(e.target) ? is(t2.Wt, e.target) : rs(t2.Wt, e.target);
  const r = e.resumeToken.toBase64();
  return new Ns(e.targetId, jt(e.target), n, r, e.sequenceNumber, s, i);
}
function di(t2) {
  const e = os({
    parent: t2.parent,
    structuredQuery: t2.structuredQuery
  });
  return t2.limitType === "LAST" ? Ee(e, e.limit, "L") : e;
}
var wi = class {
  getBundleMetadata(t2, e) {
    return _i(t2).get(e).next((t3) => {
      if (t3)
        return {
          id: (e2 = t3).bundleId,
          createTime: ui(e2.createTime),
          version: e2.version
        };
      var e2;
    });
  }
  saveBundleMetadata(t2, e) {
    return _i(t2).put({
      bundleId: (n = e).id,
      createTime: ci(qn(n.createTime)),
      version: n.version
    });
    var n;
  }
  getNamedQuery(t2, e) {
    return mi(t2).get(e).next((t3) => {
      if (t3)
        return {
          name: (e2 = t3).name,
          query: di(e2.bundledQuery),
          readTime: ui(e2.readTime)
        };
      var e2;
    });
  }
  saveNamedQuery(t2, e) {
    return mi(t2).put(function(t3) {
      return {
        name: t3.name,
        readTime: ci(qn(t3.readTime)),
        bundledQuery: t3.bundledQuery
      };
    }(e));
  }
};
function _i(t2) {
  return Zs(t2, Fs.store);
}
function mi(t2) {
  return Zs(t2, Ms.store);
}
var gi = class {
  constructor() {
    this.Gt = new yi();
  }
  addToCollectionParentIndex(t2, e) {
    return this.Gt.add(e), qs.resolve();
  }
  getCollectionParents(t2, e) {
    return qs.resolve(this.Gt.getEntries(e));
  }
};
var yi = class {
  constructor() {
    this.index = {};
  }
  add(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e] || new _n(ct.comparator), i = !s.has(n);
    return this.index[e] = s.add(n), i;
  }
  has(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e];
    return s && s.has(n);
  }
  getEntries(t2) {
    return (this.index[t2] || new _n(ct.comparator)).toArray();
  }
};
var pi = class {
  constructor() {
    this.zt = new yi();
  }
  addToCollectionParentIndex(t2, e) {
    if (!this.zt.has(e)) {
      const n = e.lastSegment(), s = e.popLast();
      t2.addOnCommittedListener(() => {
        this.zt.add(e);
      });
      const i = {
        collectionId: n,
        parent: ps(s)
      };
      return Ei(t2).put(i);
    }
    return qs.resolve();
  }
  getCollectionParents(t2, e) {
    const n = [], s = IDBKeyRange.bound([e, ""], [et(e), ""], false, true);
    return Ei(t2).Lt(s).next((t3) => {
      for (const s2 of t3) {
        if (s2.collectionId !== e)
          break;
        n.push(Is(s2.parent));
      }
      return n;
    });
  }
};
function Ei(t2) {
  return Zs(t2, $s.store);
}
var Ti = {
  didRun: false,
  sequenceNumbersCollected: 0,
  targetsRemoved: 0,
  documentsRemoved: 0
};
var Ii = class {
  constructor(t2, e, n) {
    this.cacheSizeCollectionThreshold = t2, this.percentileToCollect = e, this.maximumSequenceNumbersToCollect = n;
  }
  static withCacheSize(t2) {
    return new Ii(t2, Ii.DEFAULT_COLLECTION_PERCENTILE, Ii.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
  }
};
function Ai(t2, e, n) {
  const s = t2.store(Ps.store), i = t2.store(vs.store), r = [], o = IDBKeyRange.only(n.batchId);
  let a = 0;
  const c = s.Kt({
    range: o
  }, (t3, e2, n2) => (a++, n2.delete()));
  r.push(c.next(() => {
    M2(a === 1);
  }));
  const u = [];
  for (const t3 of n.mutations) {
    const s2 = vs.key(e, t3.key.path, n.batchId);
    r.push(i.delete(s2)), u.push(t3.key);
  }
  return qs.waitFor(r).next(() => u);
}
function Ri(t2) {
  if (!t2)
    return 0;
  let e;
  if (t2.document)
    e = t2.document;
  else if (t2.unknownDocument)
    e = t2.unknownDocument;
  else {
    if (!t2.noDocument)
      throw F2();
    e = t2.noDocument;
  }
  return JSON.stringify(e).length;
}
Ii.DEFAULT_COLLECTION_PERCENTILE = 10, Ii.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, Ii.DEFAULT = new Ii(41943040, Ii.DEFAULT_COLLECTION_PERCENTILE, Ii.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), Ii.DISABLED = new Ii(-1, 0, 0);
var bi = class {
  constructor(t2, e, n, s) {
    this.userId = t2, this.N = e, this.Ht = n, this.referenceDelegate = s, this.Jt = {};
  }
  static Yt(t2, e, n, s) {
    M2(t2.uid !== "");
    const i = t2.isAuthenticated() ? t2.uid : "";
    return new bi(i, e, n, s);
  }
  checkEmpty(t2) {
    let e = true;
    const n = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
    return vi(t2).Kt({
      index: Ps.userMutationsIndex,
      range: n
    }, (t3, n2, s) => {
      e = false, s.done();
    }).next(() => e);
  }
  addMutationBatch(t2, e, n, s) {
    const i = Vi(t2), r = vi(t2);
    return r.add({}).next((o) => {
      M2(typeof o == "number");
      const a = new ti(o, e, n, s), c = function(t3, e2, n2) {
        const s2 = n2.baseMutations.map((e3) => es(t3.Wt, e3)), i2 = n2.mutations.map((e3) => es(t3.Wt, e3));
        return new Ps(e2, n2.batchId, n2.localWriteTime.toMillis(), s2, i2);
      }(this.N, this.userId, a), u = [];
      let h = new _n((t3, e2) => Z2(t3.canonicalString(), e2.canonicalString()));
      for (const t3 of s) {
        const e2 = vs.key(this.userId, t3.key.path, o);
        h = h.add(t3.key.path.popLast()), u.push(r.put(c)), u.push(i.put(e2, vs.PLACEHOLDER));
      }
      return h.forEach((e2) => {
        u.push(this.Ht.addToCollectionParentIndex(t2, e2));
      }), t2.addOnCommittedListener(() => {
        this.Jt[o] = a.keys();
      }), qs.waitFor(u).next(() => a);
    });
  }
  lookupMutationBatch(t2, e) {
    return vi(t2).get(e).next((t3) => t3 ? (M2(t3.userId === this.userId), hi(this.N, t3)) : null);
  }
  Xt(t2, e) {
    return this.Jt[e] ? qs.resolve(this.Jt[e]) : this.lookupMutationBatch(t2, e).next((t3) => {
      if (t3) {
        const n = t3.keys();
        return this.Jt[e] = n, n;
      }
      return null;
    });
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = IDBKeyRange.lowerBound([this.userId, n]);
    let i = null;
    return vi(t2).Kt({
      index: Ps.userMutationsIndex,
      range: s
    }, (t3, e2, s2) => {
      e2.userId === this.userId && (M2(e2.batchId >= n), i = hi(this.N, e2)), s2.done();
    }).next(() => i);
  }
  getHighestUnacknowledgedBatchId(t2) {
    const e = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]);
    let n = -1;
    return vi(t2).Kt({
      index: Ps.userMutationsIndex,
      range: e,
      reverse: true
    }, (t3, e2, s) => {
      n = e2.batchId, s.done();
    }).next(() => n);
  }
  getAllMutationBatches(t2) {
    const e = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);
    return vi(t2).Lt(Ps.userMutationsIndex, e).next((t3) => t3.map((t4) => hi(this.N, t4)));
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = vs.prefixForPath(this.userId, e.path), s = IDBKeyRange.lowerBound(n), i = [];
    return Vi(t2).Kt({
      range: s
    }, (n2, s2, r) => {
      const [o, a, c] = n2, u = Is(a);
      if (o === this.userId && e.path.isEqual(u))
        return vi(t2).get(c).next((t3) => {
          if (!t3)
            throw F2();
          M2(t3.userId === this.userId), i.push(hi(this.N, t3));
        });
      r.done();
    }).next(() => i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new _n(Z2);
    const s = [];
    return e.forEach((e2) => {
      const i = vs.prefixForPath(this.userId, e2.path), r = IDBKeyRange.lowerBound(i), o = Vi(t2).Kt({
        range: r
      }, (t3, s2, i2) => {
        const [r2, o2, a] = t3, c = Is(o2);
        r2 === this.userId && e2.path.isEqual(c) ? n = n.add(a) : i2.done();
      });
      s.push(o);
    }), qs.waitFor(s).next(() => this.Zt(t2, n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1, i = vs.prefixForPath(this.userId, n), r = IDBKeyRange.lowerBound(i);
    let o = new _n(Z2);
    return Vi(t2).Kt({
      range: r
    }, (t3, e2, i2) => {
      const [r2, a, c] = t3, u = Is(a);
      r2 === this.userId && n.isPrefixOf(u) ? u.length === s && (o = o.add(c)) : i2.done();
    }).next(() => this.Zt(t2, o));
  }
  Zt(t2, e) {
    const n = [], s = [];
    return e.forEach((e2) => {
      s.push(vi(t2).get(e2).next((t3) => {
        if (t3 === null)
          throw F2();
        M2(t3.userId === this.userId), n.push(hi(this.N, t3));
      }));
    }), qs.waitFor(s).next(() => n);
  }
  removeMutationBatch(t2, e) {
    return Ai(t2.Qt, this.userId, e).next((n) => (t2.addOnCommittedListener(() => {
      this.te(e.batchId);
    }), qs.forEach(n, (e2) => this.referenceDelegate.markPotentiallyOrphaned(t2, e2))));
  }
  te(t2) {
    delete this.Jt[t2];
  }
  performConsistencyCheck(t2) {
    return this.checkEmpty(t2).next((e) => {
      if (!e)
        return qs.resolve();
      const n = IDBKeyRange.lowerBound(vs.prefixForUser(this.userId)), s = [];
      return Vi(t2).Kt({
        range: n
      }, (t3, e2, n2) => {
        if (t3[0] === this.userId) {
          const e3 = Is(t3[1]);
          s.push(e3);
        } else
          n2.done();
      }).next(() => {
        M2(s.length === 0);
      });
    });
  }
  containsKey(t2, e) {
    return Pi(t2, this.userId, e);
  }
  ee(t2) {
    return Si(t2).get(this.userId).next((t3) => t3 || new bs(this.userId, -1, ""));
  }
};
function Pi(t2, e, n) {
  const s = vs.prefixForPath(e, n.path), i = s[1], r = IDBKeyRange.lowerBound(s);
  let o = false;
  return Vi(t2).Kt({
    range: r,
    qt: true
  }, (t3, n2, s2) => {
    const [r2, a, c] = t3;
    r2 === e && a === i && (o = true), s2.done();
  }).next(() => o);
}
function vi(t2) {
  return Zs(t2, Ps.store);
}
function Vi(t2) {
  return Zs(t2, vs.store);
}
function Si(t2) {
  return Zs(t2, bs.store);
}
var Di = class {
  constructor(t2) {
    this.ne = t2;
  }
  next() {
    return this.ne += 2, this.ne;
  }
  static se() {
    return new Di(0);
  }
  static ie() {
    return new Di(-1);
  }
};
var Ci = class {
  constructor(t2, e) {
    this.referenceDelegate = t2, this.N = e;
  }
  allocateTargetId(t2) {
    return this.re(t2).next((e) => {
      const n = new Di(e.highestTargetId);
      return e.highestTargetId = n.next(), this.oe(t2, e).next(() => e.highestTargetId);
    });
  }
  getLastRemoteSnapshotVersion(t2) {
    return this.re(t2).next((t3) => st.fromTimestamp(new nt(t3.lastRemoteSnapshotVersion.seconds, t3.lastRemoteSnapshotVersion.nanoseconds)));
  }
  getHighestSequenceNumber(t2) {
    return this.re(t2).next((t3) => t3.highestListenSequenceNumber);
  }
  setTargetsMetadata(t2, e, n) {
    return this.re(t2).next((s) => (s.highestListenSequenceNumber = e, n && (s.lastRemoteSnapshotVersion = n.toTimestamp()), e > s.highestListenSequenceNumber && (s.highestListenSequenceNumber = e), this.oe(t2, s)));
  }
  addTargetData(t2, e) {
    return this.ae(t2, e).next(() => this.re(t2).next((n) => (n.targetCount += 1, this.ce(e, n), this.oe(t2, n))));
  }
  updateTargetData(t2, e) {
    return this.ae(t2, e);
  }
  removeTargetData(t2, e) {
    return this.removeMatchingKeysForTargetId(t2, e.targetId).next(() => Ni(t2).delete(e.targetId)).next(() => this.re(t2)).next((e2) => (M2(e2.targetCount > 0), e2.targetCount -= 1, this.oe(t2, e2)));
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return Ni(t2).Kt((r, o) => {
      const a = li(o);
      a.sequenceNumber <= e && n.get(a.targetId) === null && (s++, i.push(this.removeTargetData(t2, a)));
    }).next(() => qs.waitFor(i)).next(() => s);
  }
  forEachTarget(t2, e) {
    return Ni(t2).Kt((t3, n) => {
      const s = li(n);
      e(s);
    });
  }
  re(t2) {
    return xi(t2).get(ks.key).next((t3) => (M2(t3 !== null), t3));
  }
  oe(t2, e) {
    return xi(t2).put(ks.key, e);
  }
  ae(t2, e) {
    return Ni(t2).put(fi(this.N, e));
  }
  ce(t2, e) {
    let n = false;
    return t2.targetId > e.highestTargetId && (e.highestTargetId = t2.targetId, n = true), t2.sequenceNumber > e.highestListenSequenceNumber && (e.highestListenSequenceNumber = t2.sequenceNumber, n = true), n;
  }
  getTargetCount(t2) {
    return this.re(t2).next((t3) => t3.targetCount);
  }
  getTargetData(t2, e) {
    const n = jt(e), s = IDBKeyRange.bound([n, Number.NEGATIVE_INFINITY], [n, Number.POSITIVE_INFINITY]);
    let i = null;
    return Ni(t2).Kt({
      range: s,
      index: Ns.queryTargetsIndexName
    }, (t3, n2, s2) => {
      const r = li(n2);
      Wt(e, r.target) && (i = r, s2.done());
    }).next(() => i);
  }
  addMatchingKeys(t2, e, n) {
    const s = [], i = ki(t2);
    return e.forEach((e2) => {
      const r = ps(e2.path);
      s.push(i.put(new xs(n, r))), s.push(this.referenceDelegate.addReference(t2, n, e2));
    }), qs.waitFor(s);
  }
  removeMatchingKeys(t2, e, n) {
    const s = ki(t2);
    return qs.forEach(e, (e2) => {
      const i = ps(e2.path);
      return qs.waitFor([s.delete([n, i]), this.referenceDelegate.removeReference(t2, n, e2)]);
    });
  }
  removeMatchingKeysForTargetId(t2, e) {
    const n = ki(t2), s = IDBKeyRange.bound([e], [e + 1], false, true);
    return n.delete(s);
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = IDBKeyRange.bound([e], [e + 1], false, true), s = ki(t2);
    let i = Rn();
    return s.Kt({
      range: n,
      qt: true
    }, (t3, e2, n2) => {
      const s2 = Is(t3[1]), r = new Rt(s2);
      i = i.add(r);
    }).next(() => i);
  }
  containsKey(t2, e) {
    const n = ps(e.path), s = IDBKeyRange.bound([n], [et(n)], false, true);
    let i = 0;
    return ki(t2).Kt({
      index: xs.documentTargetsIndex,
      qt: true,
      range: s
    }, ([t3, e2], n2, s2) => {
      t3 !== 0 && (i++, s2.done());
    }).next(() => i > 0);
  }
  Et(t2, e) {
    return Ni(t2).get(e).next((t3) => t3 ? li(t3) : null);
  }
};
function Ni(t2) {
  return Zs(t2, Ns.store);
}
function xi(t2) {
  return Zs(t2, ks.store);
}
function ki(t2) {
  return Zs(t2, xs.store);
}
async function $i(t2) {
  if (t2.code !== U2.FAILED_PRECONDITION || t2.message !== Bs)
    throw t2;
  x2("LocalStore", "Unexpectedly lost primary lease");
}
function Oi([t2, e], [n, s]) {
  const i = Z2(t2, n);
  return i === 0 ? Z2(e, s) : i;
}
var Fi = class {
  constructor(t2) {
    this.ue = t2, this.buffer = new _n(Oi), this.he = 0;
  }
  le() {
    return ++this.he;
  }
  fe(t2) {
    const e = [t2, this.le()];
    if (this.buffer.size < this.ue)
      this.buffer = this.buffer.add(e);
    else {
      const t3 = this.buffer.last();
      Oi(e, t3) < 0 && (this.buffer = this.buffer.delete(t3).add(e));
    }
  }
  get maxValue() {
    return this.buffer.last()[0];
  }
};
var Mi = class {
  constructor(t2, e) {
    this.garbageCollector = t2, this.asyncQueue = e, this.de = false, this.we = null;
  }
  start(t2) {
    this.garbageCollector.params.cacheSizeCollectionThreshold !== -1 && this._e(t2);
  }
  stop() {
    this.we && (this.we.cancel(), this.we = null);
  }
  get started() {
    return this.we !== null;
  }
  _e(t2) {
    const e = this.de ? 3e5 : 6e4;
    x2("LruGarbageCollector", `Garbage collection scheduled in ${e}ms`), this.we = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", e, async () => {
      this.we = null, this.de = true;
      try {
        await t2.collectGarbage(this.garbageCollector);
      } catch (t3) {
        Gs(t3) ? x2("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", t3) : await $i(t3);
      }
      await this._e(t2);
    });
  }
};
var Li = class {
  constructor(t2, e) {
    this.me = t2, this.params = e;
  }
  calculateTargetCount(t2, e) {
    return this.me.ge(t2).next((t3) => Math.floor(e / 100 * t3));
  }
  nthSequenceNumber(t2, e) {
    if (e === 0)
      return qs.resolve(J2.T);
    const n = new Fi(e);
    return this.me.forEachTarget(t2, (t3) => n.fe(t3.sequenceNumber)).next(() => this.me.ye(t2, (t3) => n.fe(t3))).next(() => n.maxValue);
  }
  removeTargets(t2, e, n) {
    return this.me.removeTargets(t2, e, n);
  }
  removeOrphanedDocuments(t2, e) {
    return this.me.removeOrphanedDocuments(t2, e);
  }
  collect(t2, e) {
    return this.params.cacheSizeCollectionThreshold === -1 ? (x2("LruGarbageCollector", "Garbage collection skipped; disabled"), qs.resolve(Ti)) : this.getCacheSize(t2).next((n) => n < this.params.cacheSizeCollectionThreshold ? (x2("LruGarbageCollector", `Garbage collection skipped; Cache size ${n} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`), Ti) : this.pe(t2, e));
  }
  getCacheSize(t2) {
    return this.me.getCacheSize(t2);
  }
  pe(t2, e) {
    let n, s, i, r, o, c, u;
    const h = Date.now();
    return this.calculateTargetCount(t2, this.params.percentileToCollect).next((e2) => (e2 > this.params.maximumSequenceNumbersToCollect ? (x2("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${e2}`), s = this.params.maximumSequenceNumbersToCollect) : s = e2, r = Date.now(), this.nthSequenceNumber(t2, s))).next((s2) => (n = s2, o = Date.now(), this.removeTargets(t2, n, e))).next((e2) => (i = e2, c = Date.now(), this.removeOrphanedDocuments(t2, n))).next((t3) => {
      if (u = Date.now(), C2() <= LogLevel.DEBUG) {
        x2("LruGarbageCollector", `LRU Garbage Collection
	Counted targets in ${r - h}ms
	Determined least recently used ${s} in ` + (o - r) + `ms
	Removed ${i} targets in ` + (c - o) + `ms
	Removed ${t3} documents in ` + (u - c) + `ms
Total Duration: ${u - h}ms`);
      }
      return qs.resolve({
        didRun: true,
        sequenceNumbersCollected: s,
        targetsRemoved: i,
        documentsRemoved: t3
      });
    });
  }
};
var Bi = class {
  constructor(t2, e) {
    this.db = t2, this.garbageCollector = function(t3, e2) {
      return new Li(t3, e2);
    }(this, e);
  }
  ge(t2) {
    const e = this.Ee(t2);
    return this.db.getTargetCache().getTargetCount(t2).next((t3) => e.next((e2) => t3 + e2));
  }
  Ee(t2) {
    let e = 0;
    return this.ye(t2, (t3) => {
      e++;
    }).next(() => e);
  }
  forEachTarget(t2, e) {
    return this.db.getTargetCache().forEachTarget(t2, e);
  }
  ye(t2, e) {
    return this.Te(t2, (t3, n) => e(n));
  }
  addReference(t2, e, n) {
    return Ui(t2, n);
  }
  removeReference(t2, e, n) {
    return Ui(t2, n);
  }
  removeTargets(t2, e, n) {
    return this.db.getTargetCache().removeTargets(t2, e, n);
  }
  markPotentiallyOrphaned(t2, e) {
    return Ui(t2, e);
  }
  Ie(t2, e) {
    return function(t3, e2) {
      let n = false;
      return Si(t3).jt((s) => Pi(t3, s, e2).next((t4) => (t4 && (n = true), qs.resolve(!t4)))).next(() => n);
    }(t2, e);
  }
  removeOrphanedDocuments(t2, e) {
    const n = this.db.getRemoteDocumentCache().newChangeBuffer(), s = [];
    let i = 0;
    return this.Te(t2, (r, o) => {
      if (o <= e) {
        const e2 = this.Ie(t2, r).next((e3) => {
          if (!e3)
            return i++, n.getEntry(t2, r).next(() => (n.removeEntry(r), ki(t2).delete([0, ps(r.path)])));
        });
        s.push(e2);
      }
    }).next(() => qs.waitFor(s)).next(() => n.apply(t2)).next(() => i);
  }
  removeTarget(t2, e) {
    const n = e.withSequenceNumber(t2.currentSequenceNumber);
    return this.db.getTargetCache().updateTargetData(t2, n);
  }
  updateLimboDocument(t2, e) {
    return Ui(t2, e);
  }
  Te(t2, e) {
    const n = ki(t2);
    let s, i = J2.T;
    return n.Kt({
      index: xs.documentTargetsIndex
    }, ([t3, n2], { path: r, sequenceNumber: o }) => {
      t3 === 0 ? (i !== J2.T && e(new Rt(Is(s)), i), i = o, s = r) : i = J2.T;
    }).next(() => {
      i !== J2.T && e(new Rt(Is(s)), i);
    });
  }
  getCacheSize(t2) {
    return this.db.getRemoteDocumentCache().getSize(t2);
  }
};
function Ui(t2, e) {
  return ki(t2).put(function(t3, e2) {
    return new xs(0, ps(t3.path), e2);
  }(e, t2.currentSequenceNumber));
}
var qi = class {
  constructor(t2, e) {
    this.mapKeyFn = t2, this.equalsFn = e, this.inner = {};
  }
  get(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (n !== void 0) {
      for (const [e2, s] of n)
        if (this.equalsFn(e2, t2))
          return s;
    }
  }
  has(t2) {
    return this.get(t2) !== void 0;
  }
  set(t2, e) {
    const n = this.mapKeyFn(t2), s = this.inner[n];
    if (s !== void 0) {
      for (let n2 = 0; n2 < s.length; n2++)
        if (this.equalsFn(s[n2][0], t2))
          return void (s[n2] = [t2, e]);
      s.push([t2, e]);
    } else
      this.inner[n] = [[t2, e]];
  }
  delete(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (n === void 0)
      return false;
    for (let s = 0; s < n.length; s++)
      if (this.equalsFn(n[s][0], t2))
        return n.length === 1 ? delete this.inner[e] : n.splice(s, 1), true;
    return false;
  }
  forEach(t2) {
    rt(this.inner, (e, n) => {
      for (const [e2, s] of n)
        t2(e2, s);
    });
  }
  isEmpty() {
    return ot(this.inner);
  }
};
var Ki = class {
  constructor() {
    this.changes = new qi((t2) => t2.toString(), (t2, e) => t2.isEqual(e)), this.changesApplied = false;
  }
  getReadTime(t2) {
    const e = this.changes.get(t2);
    return e ? e.readTime : st.min();
  }
  addEntry(t2, e) {
    this.assertNotApplied(), this.changes.set(t2.key, {
      document: t2,
      readTime: e
    });
  }
  removeEntry(t2, e = null) {
    this.assertNotApplied(), this.changes.set(t2, {
      document: Ut.newInvalidDocument(t2),
      readTime: e
    });
  }
  getEntry(t2, e) {
    this.assertNotApplied();
    const n = this.changes.get(e);
    return n !== void 0 ? qs.resolve(n.document) : this.getFromCache(t2, e);
  }
  getEntries(t2, e) {
    return this.getAllFromCache(t2, e);
  }
  apply(t2) {
    return this.assertNotApplied(), this.changesApplied = true, this.applyChanges(t2);
  }
  assertNotApplied() {
  }
};
var ji = class {
  constructor(t2, e) {
    this.N = t2, this.Ht = e;
  }
  addEntry(t2, e, n) {
    return Gi(t2).put(zi(e), n);
  }
  removeEntry(t2, e) {
    const n = Gi(t2), s = zi(e);
    return n.delete(s);
  }
  updateMetadata(t2, e) {
    return this.getMetadata(t2).next((n) => (n.byteSize += e, this.Ae(t2, n)));
  }
  getEntry(t2, e) {
    return Gi(t2).get(zi(e)).next((t3) => this.Re(e, t3));
  }
  be(t2, e) {
    return Gi(t2).get(zi(e)).next((t3) => ({
      document: this.Re(e, t3),
      size: Ri(t3)
    }));
  }
  getEntries(t2, e) {
    let n = yn();
    return this.Pe(t2, e, (t3, e2) => {
      const s = this.Re(t3, e2);
      n = n.insert(t3, s);
    }).next(() => n);
  }
  ve(t2, e) {
    let n = yn(), s = new fn(Rt.comparator);
    return this.Pe(t2, e, (t3, e2) => {
      const i = this.Re(t3, e2);
      n = n.insert(t3, i), s = s.insert(t3, Ri(e2));
    }).next(() => ({
      documents: n,
      Ve: s
    }));
  }
  Pe(t2, e, n) {
    if (e.isEmpty())
      return qs.resolve();
    const s = IDBKeyRange.bound(e.first().path.toArray(), e.last().path.toArray()), i = e.getIterator();
    let r = i.getNext();
    return Gi(t2).Kt({
      range: s
    }, (t3, e2, s2) => {
      const o = Rt.fromSegments(t3);
      for (; r && Rt.comparator(r, o) < 0; )
        n(r, null), r = i.getNext();
      r && r.isEqual(o) && (n(r, e2), r = i.hasNext() ? i.getNext() : null), r ? s2.Mt(r.path.toArray()) : s2.done();
    }).next(() => {
      for (; r; )
        n(r, null), r = i.hasNext() ? i.getNext() : null;
    });
  }
  getDocumentsMatchingQuery(t2, e, n) {
    let s = yn();
    const i = e.path.length + 1, r = {};
    if (n.isEqual(st.min())) {
      const t3 = e.path.toArray();
      r.range = IDBKeyRange.lowerBound(t3);
    } else {
      const t3 = e.path.toArray(), s2 = oi(n);
      r.range = IDBKeyRange.lowerBound([t3, s2], true), r.index = Ds.collectionReadTimeIndex;
    }
    return Gi(t2).Kt(r, (t3, n2, r2) => {
      if (t3.length !== i)
        return;
      const o = ii(this.N, n2);
      e.path.isPrefixOf(o.key.path) ? Re(e, o) && (s = s.insert(o.key, o)) : r2.done();
    }).next(() => s);
  }
  newChangeBuffer(t2) {
    return new Qi(this, !!t2 && t2.trackRemovals);
  }
  getSize(t2) {
    return this.getMetadata(t2).next((t3) => t3.byteSize);
  }
  getMetadata(t2) {
    return Wi(t2).get(Cs.key).next((t3) => (M2(!!t3), t3));
  }
  Ae(t2, e) {
    return Wi(t2).put(Cs.key, e);
  }
  Re(t2, e) {
    if (e) {
      const t3 = ii(this.N, e);
      if (!(t3.isNoDocument() && t3.version.isEqual(st.min())))
        return t3;
    }
    return Ut.newInvalidDocument(t2);
  }
};
var Qi = class extends Ki {
  constructor(t2, e) {
    super(), this.Se = t2, this.trackRemovals = e, this.De = new qi((t3) => t3.toString(), (t3, e2) => t3.isEqual(e2));
  }
  applyChanges(t2) {
    const e = [];
    let n = 0, s = new _n((t3, e2) => Z2(t3.canonicalString(), e2.canonicalString()));
    return this.changes.forEach((i, r) => {
      const o = this.De.get(i);
      if (r.document.isValidDocument()) {
        const a = ri(this.Se.N, r.document, this.getReadTime(i));
        s = s.add(i.path.popLast());
        const c = Ri(a);
        n += c - o, e.push(this.Se.addEntry(t2, i, a));
      } else if (n -= o, this.trackRemovals) {
        const n2 = ri(this.Se.N, Ut.newNoDocument(i, st.min()), this.getReadTime(i));
        e.push(this.Se.addEntry(t2, i, n2));
      } else
        e.push(this.Se.removeEntry(t2, i));
    }), s.forEach((n2) => {
      e.push(this.Se.Ht.addToCollectionParentIndex(t2, n2));
    }), e.push(this.Se.updateMetadata(t2, n)), qs.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.Se.be(t2, e).next((t3) => (this.De.set(e, t3.size), t3.document));
  }
  getAllFromCache(t2, e) {
    return this.Se.ve(t2, e).next(({ documents: t3, Ve: e2 }) => (e2.forEach((t4, e3) => {
      this.De.set(t4, e3);
    }), t3));
  }
};
function Wi(t2) {
  return Zs(t2, Cs.store);
}
function Gi(t2) {
  return Zs(t2, Ds.store);
}
function zi(t2) {
  return t2.path.toArray();
}
var Hi = class {
  constructor(t2) {
    this.N = t2;
  }
  Ct(t2, e, n, s) {
    M2(n < s && n >= 0 && s <= 11);
    const i = new Ks("createOrUpgrade", e);
    n < 1 && s >= 1 && (function(t3) {
      t3.createObjectStore(Rs.store);
    }(t2), function(t3) {
      t3.createObjectStore(bs.store, {
        keyPath: bs.keyPath
      });
      t3.createObjectStore(Ps.store, {
        keyPath: Ps.keyPath,
        autoIncrement: true
      }).createIndex(Ps.userMutationsIndex, Ps.userMutationsKeyPath, {
        unique: true
      }), t3.createObjectStore(vs.store);
    }(t2), Ji(t2), function(t3) {
      t3.createObjectStore(Ds.store);
    }(t2));
    let r = qs.resolve();
    return n < 3 && s >= 3 && (n !== 0 && (!function(t3) {
      t3.deleteObjectStore(xs.store), t3.deleteObjectStore(Ns.store), t3.deleteObjectStore(ks.store);
    }(t2), Ji(t2)), r = r.next(() => function(t3) {
      const e2 = t3.store(ks.store), n2 = new ks(0, 0, st.min().toTimestamp(), 0);
      return e2.put(ks.key, n2);
    }(i))), n < 4 && s >= 4 && (n !== 0 && (r = r.next(() => function(t3, e2) {
      return e2.store(Ps.store).Lt().next((n2) => {
        t3.deleteObjectStore(Ps.store);
        t3.createObjectStore(Ps.store, {
          keyPath: Ps.keyPath,
          autoIncrement: true
        }).createIndex(Ps.userMutationsIndex, Ps.userMutationsKeyPath, {
          unique: true
        });
        const s2 = e2.store(Ps.store), i2 = n2.map((t4) => s2.put(t4));
        return qs.waitFor(i2);
      });
    }(t2, i))), r = r.next(() => {
      !function(t3) {
        t3.createObjectStore(Os.store, {
          keyPath: Os.keyPath
        });
      }(t2);
    })), n < 5 && s >= 5 && (r = r.next(() => this.Ce(i))), n < 6 && s >= 6 && (r = r.next(() => (function(t3) {
      t3.createObjectStore(Cs.store);
    }(t2), this.Ne(i)))), n < 7 && s >= 7 && (r = r.next(() => this.xe(i))), n < 8 && s >= 8 && (r = r.next(() => this.ke(t2, i))), n < 9 && s >= 9 && (r = r.next(() => {
      !function(t3) {
        t3.objectStoreNames.contains("remoteDocumentChanges") && t3.deleteObjectStore("remoteDocumentChanges");
      }(t2), function(t3) {
        const e2 = t3.objectStore(Ds.store);
        e2.createIndex(Ds.readTimeIndex, Ds.readTimeIndexPath, {
          unique: false
        }), e2.createIndex(Ds.collectionReadTimeIndex, Ds.collectionReadTimeIndexPath, {
          unique: false
        });
      }(e);
    })), n < 10 && s >= 10 && (r = r.next(() => this.$e(i))), n < 11 && s >= 11 && (r = r.next(() => {
      !function(t3) {
        t3.createObjectStore(Fs.store, {
          keyPath: Fs.keyPath
        });
      }(t2), function(t3) {
        t3.createObjectStore(Ms.store, {
          keyPath: Ms.keyPath
        });
      }(t2);
    })), r;
  }
  Ne(t2) {
    let e = 0;
    return t2.store(Ds.store).Kt((t3, n) => {
      e += Ri(n);
    }).next(() => {
      const n = new Cs(e);
      return t2.store(Cs.store).put(Cs.key, n);
    });
  }
  Ce(t2) {
    const e = t2.store(bs.store), n = t2.store(Ps.store);
    return e.Lt().next((e2) => qs.forEach(e2, (e3) => {
      const s = IDBKeyRange.bound([e3.userId, -1], [e3.userId, e3.lastAcknowledgedBatchId]);
      return n.Lt(Ps.userMutationsIndex, s).next((n2) => qs.forEach(n2, (n3) => {
        M2(n3.userId === e3.userId);
        const s2 = hi(this.N, n3);
        return Ai(t2, e3.userId, s2).next(() => {
        });
      }));
    }));
  }
  xe(t2) {
    const e = t2.store(xs.store), n = t2.store(Ds.store);
    return t2.store(ks.store).get(ks.key).next((t3) => {
      const s = [];
      return n.Kt((n2, i) => {
        const r = new ct(n2), o = function(t4) {
          return [0, ps(t4)];
        }(r);
        s.push(e.get(o).next((n3) => n3 ? qs.resolve() : ((n4) => e.put(new xs(0, ps(n4), t3.highestListenSequenceNumber)))(r)));
      }).next(() => qs.waitFor(s));
    });
  }
  ke(t2, e) {
    t2.createObjectStore($s.store, {
      keyPath: $s.keyPath
    });
    const n = e.store($s.store), s = new yi(), i = (t3) => {
      if (s.add(t3)) {
        const e2 = t3.lastSegment(), s2 = t3.popLast();
        return n.put({
          collectionId: e2,
          parent: ps(s2)
        });
      }
    };
    return e.store(Ds.store).Kt({
      qt: true
    }, (t3, e2) => {
      const n2 = new ct(t3);
      return i(n2.popLast());
    }).next(() => e.store(vs.store).Kt({
      qt: true
    }, ([t3, e2, n2], s2) => {
      const r = Is(e2);
      return i(r.popLast());
    }));
  }
  $e(t2) {
    const e = t2.store(Ns.store);
    return e.Kt((t3, n) => {
      const s = li(n), i = fi(this.N, s);
      return e.put(i);
    });
  }
};
function Ji(t2) {
  t2.createObjectStore(xs.store, {
    keyPath: xs.keyPath
  }).createIndex(xs.documentTargetsIndex, xs.documentTargetsKeyPath, {
    unique: true
  });
  t2.createObjectStore(Ns.store, {
    keyPath: Ns.keyPath
  }).createIndex(Ns.queryTargetsIndexName, Ns.queryTargetsKeyPath, {
    unique: true
  }), t2.createObjectStore(ks.store);
}
var Yi = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.";
var Xi = class {
  constructor(t2, e, n, s, i, r, o, a, c, u) {
    if (this.allowTabSynchronization = t2, this.persistenceKey = e, this.clientId = n, this.Oe = i, this.window = r, this.document = o, this.Fe = c, this.Me = u, this.Le = null, this.Be = false, this.isPrimary = false, this.networkEnabled = true, this.Ue = null, this.inForeground = false, this.qe = null, this.Ke = null, this.je = Number.NEGATIVE_INFINITY, this.Qe = (t3) => Promise.resolve(), !Xi.bt())
      throw new q2(U2.UNIMPLEMENTED, "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.");
    this.referenceDelegate = new Bi(this, s), this.We = e + "main", this.N = new si(a), this.Ge = new js(this.We, 11, new Hi(this.N)), this.ze = new Ci(this.referenceDelegate, this.N), this.Ht = new pi(), this.He = function(t3, e2) {
      return new ji(t3, e2);
    }(this.N, this.Ht), this.Je = new wi(), this.window && this.window.localStorage ? this.Ye = this.window.localStorage : (this.Ye = null, u === false && k2("IndexedDbPersistence", "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page."));
  }
  start() {
    return this.Xe().then(() => {
      if (!this.isPrimary && !this.allowTabSynchronization)
        throw new q2(U2.FAILED_PRECONDITION, Yi);
      return this.Ze(), this.tn(), this.en(), this.runTransaction("getHighestListenSequenceNumber", "readonly", (t2) => this.ze.getHighestSequenceNumber(t2));
    }).then((t2) => {
      this.Le = new J2(t2, this.Fe);
    }).then(() => {
      this.Be = true;
    }).catch((t2) => (this.Ge && this.Ge.close(), Promise.reject(t2)));
  }
  nn(t2) {
    return this.Qe = async (e) => {
      if (this.started)
        return t2(e);
    }, t2(this.isPrimary);
  }
  setDatabaseDeletedListener(t2) {
    this.Ge.xt(async (e) => {
      e.newVersion === null && await t2();
    });
  }
  setNetworkEnabled(t2) {
    this.networkEnabled !== t2 && (this.networkEnabled = t2, this.Oe.enqueueAndForget(async () => {
      this.started && await this.Xe();
    }));
  }
  Xe() {
    return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", (t2) => tr(t2).put(new Os(this.clientId, Date.now(), this.networkEnabled, this.inForeground)).next(() => {
      if (this.isPrimary)
        return this.sn(t2).next((t3) => {
          t3 || (this.isPrimary = false, this.Oe.enqueueRetryable(() => this.Qe(false)));
        });
    }).next(() => this.rn(t2)).next((e) => this.isPrimary && !e ? this.on(t2).next(() => false) : !!e && this.an(t2).next(() => true))).catch((t2) => {
      if (Gs(t2))
        return x2("IndexedDbPersistence", "Failed to extend owner lease: ", t2), this.isPrimary;
      if (!this.allowTabSynchronization)
        throw t2;
      return x2("IndexedDbPersistence", "Releasing owner lease after error during lease refresh", t2), false;
    }).then((t2) => {
      this.isPrimary !== t2 && this.Oe.enqueueRetryable(() => this.Qe(t2)), this.isPrimary = t2;
    });
  }
  sn(t2) {
    return Zi(t2).get(Rs.key).next((t3) => qs.resolve(this.cn(t3)));
  }
  un(t2) {
    return tr(t2).delete(this.clientId);
  }
  async hn() {
    if (this.isPrimary && !this.ln(this.je, 18e5)) {
      this.je = Date.now();
      const t2 = await this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", (t3) => {
        const e = Zs(t3, Os.store);
        return e.Lt().next((t4) => {
          const n = this.fn(t4, 18e5), s = t4.filter((t5) => n.indexOf(t5) === -1);
          return qs.forEach(s, (t5) => e.delete(t5.clientId)).next(() => s);
        });
      }).catch(() => []);
      if (this.Ye)
        for (const e of t2)
          this.Ye.removeItem(this.dn(e.clientId));
    }
  }
  en() {
    this.Ke = this.Oe.enqueueAfterDelay("client_metadata_refresh", 4e3, () => this.Xe().then(() => this.hn()).then(() => this.en()));
  }
  cn(t2) {
    return !!t2 && t2.ownerId === this.clientId;
  }
  rn(t2) {
    if (this.Me)
      return qs.resolve(true);
    return Zi(t2).get(Rs.key).next((e) => {
      if (e !== null && this.ln(e.leaseTimestampMs, 5e3) && !this.wn(e.ownerId)) {
        if (this.cn(e) && this.networkEnabled)
          return true;
        if (!this.cn(e)) {
          if (!e.allowTabSynchronization)
            throw new q2(U2.FAILED_PRECONDITION, Yi);
          return false;
        }
      }
      return !(!this.networkEnabled || !this.inForeground) || tr(t2).Lt().next((t3) => this.fn(t3, 5e3).find((t4) => {
        if (this.clientId !== t4.clientId) {
          const e2 = !this.networkEnabled && t4.networkEnabled, n = !this.inForeground && t4.inForeground, s = this.networkEnabled === t4.networkEnabled;
          if (e2 || n && s)
            return true;
        }
        return false;
      }) === void 0);
    }).next((t3) => (this.isPrimary !== t3 && x2("IndexedDbPersistence", `Client ${t3 ? "is" : "is not"} eligible for a primary lease.`), t3));
  }
  async shutdown() {
    this.Be = false, this._n(), this.Ke && (this.Ke.cancel(), this.Ke = null), this.mn(), this.gn(), await this.Ge.runTransaction("shutdown", "readwrite", [Rs.store, Os.store], (t2) => {
      const e = new Xs(t2, J2.T);
      return this.on(e).next(() => this.un(e));
    }), this.Ge.close(), this.yn();
  }
  fn(t2, e) {
    return t2.filter((t3) => this.ln(t3.updateTimeMs, e) && !this.wn(t3.clientId));
  }
  pn() {
    return this.runTransaction("getActiveClients", "readonly", (t2) => tr(t2).Lt().next((t3) => this.fn(t3, 18e5).map((t4) => t4.clientId)));
  }
  get started() {
    return this.Be;
  }
  getMutationQueue(t2) {
    return bi.Yt(t2, this.N, this.Ht, this.referenceDelegate);
  }
  getTargetCache() {
    return this.ze;
  }
  getRemoteDocumentCache() {
    return this.He;
  }
  getIndexManager() {
    return this.Ht;
  }
  getBundleCache() {
    return this.Je;
  }
  runTransaction(t2, e, n) {
    x2("IndexedDbPersistence", "Starting transaction:", t2);
    const s = e === "readonly" ? "readonly" : "readwrite";
    let i;
    return this.Ge.runTransaction(t2, s, Ls, (s2) => (i = new Xs(s2, this.Le ? this.Le.next() : J2.T), e === "readwrite-primary" ? this.sn(i).next((t3) => !!t3 || this.rn(i)).next((e2) => {
      if (!e2)
        throw k2(`Failed to obtain primary lease for action '${t2}'.`), this.isPrimary = false, this.Oe.enqueueRetryable(() => this.Qe(false)), new q2(U2.FAILED_PRECONDITION, Bs);
      return n(i);
    }).next((t3) => this.an(i).next(() => t3)) : this.En(i).next(() => n(i)))).then((t3) => (i.raiseOnCommittedEvent(), t3));
  }
  En(t2) {
    return Zi(t2).get(Rs.key).next((t3) => {
      if (t3 !== null && this.ln(t3.leaseTimestampMs, 5e3) && !this.wn(t3.ownerId) && !this.cn(t3) && !(this.Me || this.allowTabSynchronization && t3.allowTabSynchronization))
        throw new q2(U2.FAILED_PRECONDITION, Yi);
    });
  }
  an(t2) {
    const e = new Rs(this.clientId, this.allowTabSynchronization, Date.now());
    return Zi(t2).put(Rs.key, e);
  }
  static bt() {
    return js.bt();
  }
  on(t2) {
    const e = Zi(t2);
    return e.get(Rs.key).next((t3) => this.cn(t3) ? (x2("IndexedDbPersistence", "Releasing primary lease."), e.delete(Rs.key)) : qs.resolve());
  }
  ln(t2, e) {
    const n = Date.now();
    return !(t2 < n - e) && (!(t2 > n) || (k2(`Detected an update time that is in the future: ${t2} > ${n}`), false));
  }
  Ze() {
    this.document !== null && typeof this.document.addEventListener == "function" && (this.qe = () => {
      this.Oe.enqueueAndForget(() => (this.inForeground = this.document.visibilityState === "visible", this.Xe()));
    }, this.document.addEventListener("visibilitychange", this.qe), this.inForeground = this.document.visibilityState === "visible");
  }
  mn() {
    this.qe && (this.document.removeEventListener("visibilitychange", this.qe), this.qe = null);
  }
  tn() {
    var t2;
    typeof ((t2 = this.window) === null || t2 === void 0 ? void 0 : t2.addEventListener) == "function" && (this.Ue = () => {
      this._n(), isSafari() && navigator.appVersion.match("Version/14") && this.Oe.enterRestrictedMode(true), this.Oe.enqueueAndForget(() => this.shutdown());
    }, this.window.addEventListener("pagehide", this.Ue));
  }
  gn() {
    this.Ue && (this.window.removeEventListener("pagehide", this.Ue), this.Ue = null);
  }
  wn(t2) {
    var e;
    try {
      const n = ((e = this.Ye) === null || e === void 0 ? void 0 : e.getItem(this.dn(t2))) !== null;
      return x2("IndexedDbPersistence", `Client '${t2}' ${n ? "is" : "is not"} zombied in LocalStorage`), n;
    } catch (t3) {
      return k2("IndexedDbPersistence", "Failed to get zombied client id.", t3), false;
    }
  }
  _n() {
    if (this.Ye)
      try {
        this.Ye.setItem(this.dn(this.clientId), String(Date.now()));
      } catch (t2) {
        k2("Failed to set zombie client id.", t2);
      }
  }
  yn() {
    if (this.Ye)
      try {
        this.Ye.removeItem(this.dn(this.clientId));
      } catch (t2) {
      }
  }
  dn(t2) {
    return `firestore_zombie_${this.persistenceKey}_${t2}`;
  }
};
function Zi(t2) {
  return Zs(t2, Rs.store);
}
function tr(t2) {
  return Zs(t2, Os.store);
}
function er(t2, e) {
  let n = t2.projectId;
  return t2.isDefaultDatabase || (n += "." + t2.database), "firestore/" + e + "/" + n + "/";
}
var nr = class {
  constructor(t2, e) {
    this.progress = t2, this.Tn = e;
  }
};
var sr = class {
  constructor(t2, e, n) {
    this.He = t2, this.In = e, this.Ht = n;
  }
  An(t2, e) {
    return this.In.getAllMutationBatchesAffectingDocumentKey(t2, e).next((n) => this.Rn(t2, e, n));
  }
  Rn(t2, e, n) {
    return this.He.getEntry(t2, e).next((t3) => {
      for (const e2 of n)
        e2.applyToLocalView(t3);
      return t3;
    });
  }
  bn(t2, e) {
    t2.forEach((t3, n) => {
      for (const t4 of e)
        t4.applyToLocalView(n);
    });
  }
  Pn(t2, e) {
    return this.He.getEntries(t2, e).next((e2) => this.vn(t2, e2).next(() => e2));
  }
  vn(t2, e) {
    return this.In.getAllMutationBatchesAffectingDocumentKeys(t2, e).next((t3) => this.bn(e, t3));
  }
  getDocumentsMatchingQuery(t2, e, n) {
    return function(t3) {
      return Rt.isDocumentKey(t3.path) && t3.collectionGroup === null && t3.filters.length === 0;
    }(e) ? this.Vn(t2, e.path) : ge(e) ? this.Sn(t2, e, n) : this.Dn(t2, e, n);
  }
  Vn(t2, e) {
    return this.An(t2, new Rt(e)).next((t3) => {
      let e2 = En();
      return t3.isFoundDocument() && (e2 = e2.insert(t3.key, t3)), e2;
    });
  }
  Sn(t2, e, n) {
    const s = e.collectionGroup;
    let i = En();
    return this.Ht.getCollectionParents(t2, s).next((r) => qs.forEach(r, (r2) => {
      const o = function(t3, e2) {
        return new he(e2, null, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
      }(e, r2.child(s));
      return this.Dn(t2, o, n).next((t3) => {
        t3.forEach((t4, e2) => {
          i = i.insert(t4, e2);
        });
      });
    }).next(() => i));
  }
  Dn(t2, e, n) {
    let s, i;
    return this.He.getDocumentsMatchingQuery(t2, e, n).next((n2) => (s = n2, this.In.getAllMutationBatchesAffectingQuery(t2, e))).next((e2) => (i = e2, this.Cn(t2, i, s).next((t3) => {
      s = t3;
      for (const t4 of i)
        for (const e3 of t4.mutations) {
          const n2 = e3.key;
          let i2 = s.get(n2);
          i2 == null && (i2 = Ut.newInvalidDocument(n2), s = s.insert(n2, i2)), He(e3, i2, t4.localWriteTime), i2.isFoundDocument() || (s = s.remove(n2));
        }
    }))).next(() => (s.forEach((t3, n2) => {
      Re(e, n2) || (s = s.remove(t3));
    }), s));
  }
  Cn(t2, e, n) {
    let s = Rn();
    for (const t3 of e)
      for (const e2 of t3.mutations)
        e2 instanceof tn && n.get(e2.key) === null && (s = s.add(e2.key));
    let i = n;
    return this.He.getEntries(t2, s).next((t3) => (t3.forEach((t4, e2) => {
      e2.isFoundDocument() && (i = i.insert(t4, e2));
    }), i));
  }
};
var ir = class {
  constructor(t2, e, n, s) {
    this.targetId = t2, this.fromCache = e, this.Nn = n, this.xn = s;
  }
  static kn(t2, e) {
    let n = Rn(), s = Rn();
    for (const t3 of e.docChanges)
      switch (t3.type) {
        case 0:
          n = n.add(t3.doc.key);
          break;
        case 1:
          s = s.add(t3.doc.key);
      }
    return new ir(t2, e.fromCache, n, s);
  }
};
var rr = class {
  $n(t2) {
    this.On = t2;
  }
  getDocumentsMatchingQuery(t2, e, n, s) {
    return function(t3) {
      return t3.filters.length === 0 && t3.limit === null && t3.startAt == null && t3.endAt == null && (t3.explicitOrderBy.length === 0 || t3.explicitOrderBy.length === 1 && t3.explicitOrderBy[0].field.isKeyField());
    }(e) || n.isEqual(st.min()) ? this.Fn(t2, e) : this.On.Pn(t2, s).next((i) => {
      const r = this.Mn(e, i);
      return (de(e) || we(e)) && this.Ln(e.limitType, r, s, n) ? this.Fn(t2, e) : (C2() <= LogLevel.DEBUG && x2("QueryEngine", "Re-using previous result from %s to execute query: %s", n.toString(), Ae(e)), this.On.getDocumentsMatchingQuery(t2, e, n).next((t3) => (r.forEach((e2) => {
        t3 = t3.insert(e2.key, e2);
      }), t3)));
    });
  }
  Mn(t2, e) {
    let n = new _n(be(t2));
    return e.forEach((e2, s) => {
      Re(t2, s) && (n = n.add(s));
    }), n;
  }
  Ln(t2, e, n, s) {
    if (n.size !== e.size)
      return true;
    const i = t2 === "F" ? e.last() : e.first();
    return !!i && (i.hasPendingWrites || i.version.compareTo(s) > 0);
  }
  Fn(t2, e) {
    return C2() <= LogLevel.DEBUG && x2("QueryEngine", "Using full collection scan to execute query:", Ae(e)), this.On.getDocumentsMatchingQuery(t2, e, st.min());
  }
};
var or = class {
  constructor(t2, e, n, s) {
    this.persistence = t2, this.Bn = e, this.N = s, this.Un = new fn(Z2), this.qn = new qi((t3) => jt(t3), Wt), this.Kn = st.min(), this.In = t2.getMutationQueue(n), this.jn = t2.getRemoteDocumentCache(), this.ze = t2.getTargetCache(), this.Qn = new sr(this.jn, this.In, this.persistence.getIndexManager()), this.Je = t2.getBundleCache(), this.Bn.$n(this.Qn);
  }
  collectGarbage(t2) {
    return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (e) => t2.collect(e, this.Un));
  }
};
function ar(t2, e, n, s) {
  return new or(t2, e, n, s);
}
async function cr(t2, e) {
  const n = B2(t2);
  let s = n.In, i = n.Qn;
  const r = await n.persistence.runTransaction("Handle user change", "readonly", (t3) => {
    let r2;
    return n.In.getAllMutationBatches(t3).next((o) => (r2 = o, s = n.persistence.getMutationQueue(e), i = new sr(n.jn, s, n.persistence.getIndexManager()), s.getAllMutationBatches(t3))).next((e2) => {
      const n2 = [], s2 = [];
      let o = Rn();
      for (const t4 of r2) {
        n2.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      for (const t4 of e2) {
        s2.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      return i.Pn(t3, o).next((t4) => ({
        Wn: t4,
        removedBatchIds: n2,
        addedBatchIds: s2
      }));
    });
  });
  return n.In = s, n.Qn = i, n.Bn.$n(n.Qn), r;
}
function ur(t2, e) {
  const n = B2(t2);
  return n.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (t3) => {
    const s = e.batch.keys(), i = n.jn.newChangeBuffer({
      trackRemovals: true
    });
    return function(t4, e2, n2, s2) {
      const i2 = n2.batch, r = i2.keys();
      let o = qs.resolve();
      return r.forEach((t5) => {
        o = o.next(() => s2.getEntry(e2, t5)).next((e3) => {
          const r2 = n2.docVersions.get(t5);
          M2(r2 !== null), e3.version.compareTo(r2) < 0 && (i2.applyToRemoteDocument(e3, n2), e3.isValidDocument() && s2.addEntry(e3, n2.commitVersion));
        });
      }), o.next(() => t4.In.removeMutationBatch(e2, i2));
    }(n, t3, e, i).next(() => i.apply(t3)).next(() => n.In.performConsistencyCheck(t3)).next(() => n.Qn.Pn(t3, s));
  });
}
function hr(t2) {
  const e = B2(t2);
  return e.persistence.runTransaction("Get last remote snapshot version", "readonly", (t3) => e.ze.getLastRemoteSnapshotVersion(t3));
}
function lr(t2, e) {
  const n = B2(t2), s = e.snapshotVersion;
  let i = n.Un;
  return n.persistence.runTransaction("Apply remote event", "readwrite-primary", (t3) => {
    const r = n.jn.newChangeBuffer({
      trackRemovals: true
    });
    i = n.Un;
    const o = [];
    e.targetChanges.forEach((e2, r2) => {
      const a2 = i.get(r2);
      if (!a2)
        return;
      o.push(n.ze.removeMatchingKeys(t3, e2.removedDocuments, r2).next(() => n.ze.addMatchingKeys(t3, e2.addedDocuments, r2)));
      const c = e2.resumeToken;
      if (c.approximateByteSize() > 0) {
        const u = a2.withResumeToken(c, s).withSequenceNumber(t3.currentSequenceNumber);
        i = i.insert(r2, u), function(t4, e3, n2) {
          if (M2(e3.resumeToken.approximateByteSize() > 0), t4.resumeToken.approximateByteSize() === 0)
            return true;
          if (e3.snapshotVersion.toMicroseconds() - t4.snapshotVersion.toMicroseconds() >= 3e8)
            return true;
          return n2.addedDocuments.size + n2.modifiedDocuments.size + n2.removedDocuments.size > 0;
        }(a2, u, e2) && o.push(n.ze.updateTargetData(t3, u));
      }
    });
    let a = yn();
    if (e.documentUpdates.forEach((s2, i2) => {
      e.resolvedLimboDocuments.has(s2) && o.push(n.persistence.referenceDelegate.updateLimboDocument(t3, s2));
    }), o.push(fr(t3, r, e.documentUpdates, s, void 0).next((t4) => {
      a = t4;
    })), !s.isEqual(st.min())) {
      const e2 = n.ze.getLastRemoteSnapshotVersion(t3).next((e3) => n.ze.setTargetsMetadata(t3, t3.currentSequenceNumber, s));
      o.push(e2);
    }
    return qs.waitFor(o).next(() => r.apply(t3)).next(() => n.Qn.vn(t3, a)).next(() => a);
  }).then((t3) => (n.Un = i, t3));
}
function fr(t2, e, n, s, i) {
  let r = Rn();
  return n.forEach((t3) => r = r.add(t3)), e.getEntries(t2, r).next((t3) => {
    let r2 = yn();
    return n.forEach((n2, o) => {
      const a = t3.get(n2), c = (i == null ? void 0 : i.get(n2)) || s;
      o.isNoDocument() && o.version.isEqual(st.min()) ? (e.removeEntry(n2, c), r2 = r2.insert(n2, o)) : !a.isValidDocument() || o.version.compareTo(a.version) > 0 || o.version.compareTo(a.version) === 0 && a.hasPendingWrites ? (e.addEntry(o, c), r2 = r2.insert(n2, o)) : x2("LocalStore", "Ignoring outdated watch update for ", n2, ". Current version:", a.version, " Watch version:", o.version);
    }), r2;
  });
}
function dr(t2, e) {
  const n = B2(t2);
  return n.persistence.runTransaction("Get next mutation batch", "readonly", (t3) => (e === void 0 && (e = -1), n.In.getNextMutationBatchAfterBatchId(t3, e)));
}
function wr(t2, e) {
  const n = B2(t2);
  return n.persistence.runTransaction("Allocate target", "readwrite", (t3) => {
    let s;
    return n.ze.getTargetData(t3, e).next((i) => i ? (s = i, qs.resolve(s)) : n.ze.allocateTargetId(t3).next((i2) => (s = new ni(e, i2, 0, t3.currentSequenceNumber), n.ze.addTargetData(t3, s).next(() => s))));
  }).then((t3) => {
    const s = n.Un.get(t3.targetId);
    return (s === null || t3.snapshotVersion.compareTo(s.snapshotVersion) > 0) && (n.Un = n.Un.insert(t3.targetId, t3), n.qn.set(e, t3.targetId)), t3;
  });
}
async function _r(t2, e, n) {
  const s = B2(t2), i = s.Un.get(e), r = n ? "readwrite" : "readwrite-primary";
  try {
    n || await s.persistence.runTransaction("Release target", r, (t3) => s.persistence.referenceDelegate.removeTarget(t3, i));
  } catch (t3) {
    if (!Gs(t3))
      throw t3;
    x2("LocalStore", `Failed to update sequence numbers for target ${e}: ${t3}`);
  }
  s.Un = s.Un.remove(e), s.qn.delete(i.target);
}
function mr(t2, e, n) {
  const s = B2(t2);
  let i = st.min(), r = Rn();
  return s.persistence.runTransaction("Execute query", "readonly", (t3) => function(t4, e2, n2) {
    const s2 = B2(t4), i2 = s2.qn.get(n2);
    return i2 !== void 0 ? qs.resolve(s2.Un.get(i2)) : s2.ze.getTargetData(e2, n2);
  }(s, t3, pe(e)).next((e2) => {
    if (e2)
      return i = e2.lastLimboFreeSnapshotVersion, s.ze.getMatchingKeysForTargetId(t3, e2.targetId).next((t4) => {
        r = t4;
      });
  }).next(() => s.Bn.getDocumentsMatchingQuery(t3, e, n ? i : st.min(), n ? r : Rn())).next((t4) => ({
    documents: t4,
    Gn: r
  })));
}
function gr(t2, e) {
  const n = B2(t2), s = B2(n.ze), i = n.Un.get(e);
  return i ? Promise.resolve(i.target) : n.persistence.runTransaction("Get target data", "readonly", (t3) => s.Et(t3, e).next((t4) => t4 ? t4.target : null));
}
function yr(t2) {
  const e = B2(t2);
  return e.persistence.runTransaction("Get new document changes", "readonly", (t3) => function(t4, e2, n) {
    const s = B2(t4);
    let i = yn(), r = oi(n);
    const o = Gi(e2), a = IDBKeyRange.lowerBound(r, true);
    return o.Kt({
      index: Ds.readTimeIndex,
      range: a
    }, (t5, e3) => {
      const n2 = ii(s.N, e3);
      i = i.insert(n2.key, n2), r = e3.readTime;
    }).next(() => ({
      Tn: i,
      readTime: ai(r)
    }));
  }(e.jn, t3, e.Kn)).then(({ Tn: t3, readTime: n }) => (e.Kn = n, t3));
}
async function pr(t2) {
  const e = B2(t2);
  return e.persistence.runTransaction("Synchronize last document change read time", "readonly", (t3) => function(t4) {
    const e2 = Gi(t4);
    let n = st.min();
    return e2.Kt({
      index: Ds.readTimeIndex,
      reverse: true
    }, (t5, e3, s) => {
      e3.readTime && (n = ai(e3.readTime)), s.done();
    }).next(() => n);
  }(t3)).then((t3) => {
    e.Kn = t3;
  });
}
async function Er(t2, e, n, s) {
  const i = B2(t2);
  let r = Rn(), o = yn(), a = In();
  for (const t3 of n) {
    const n2 = e.zn(t3.metadata.name);
    t3.document && (r = r.add(n2)), o = o.insert(n2, e.Hn(t3)), a = a.insert(n2, e.Jn(t3.metadata.readTime));
  }
  const c = i.jn.newChangeBuffer({
    trackRemovals: true
  }), u = await wr(i, function(t3) {
    return pe(fe(ct.fromString(`__bundle__/docs/${t3}`)));
  }(s));
  return i.persistence.runTransaction("Apply bundle documents", "readwrite", (t3) => fr(t3, c, o, st.min(), a).next((e2) => (c.apply(t3), e2)).next((e2) => i.ze.removeMatchingKeysForTargetId(t3, u.targetId).next(() => i.ze.addMatchingKeys(t3, r, u.targetId)).next(() => i.Qn.vn(t3, e2)).next(() => e2)));
}
async function Tr(t2, e, n = Rn()) {
  const s = await wr(t2, pe(di(e.bundledQuery))), i = B2(t2);
  return i.persistence.runTransaction("Save named query", "readwrite", (t3) => {
    const r = qn(e.readTime);
    if (s.snapshotVersion.compareTo(r) >= 0)
      return i.Je.saveNamedQuery(t3, e);
    const o = s.withResumeToken(dt.EMPTY_BYTE_STRING, r);
    return i.Un = i.Un.insert(o.targetId, o), i.ze.updateTargetData(t3, o).next(() => i.ze.removeMatchingKeysForTargetId(t3, s.targetId)).next(() => i.ze.addMatchingKeys(t3, n, s.targetId)).next(() => i.Je.saveNamedQuery(t3, e));
  });
}
var Ir = class {
  constructor(t2) {
    this.N = t2, this.Yn = new Map(), this.Xn = new Map();
  }
  getBundleMetadata(t2, e) {
    return qs.resolve(this.Yn.get(e));
  }
  saveBundleMetadata(t2, e) {
    var n;
    return this.Yn.set(e.id, {
      id: (n = e).id,
      version: n.version,
      createTime: qn(n.createTime)
    }), qs.resolve();
  }
  getNamedQuery(t2, e) {
    return qs.resolve(this.Xn.get(e));
  }
  saveNamedQuery(t2, e) {
    return this.Xn.set(e.name, function(t3) {
      return {
        name: t3.name,
        query: di(t3.bundledQuery),
        readTime: qn(t3.readTime)
      };
    }(e)), qs.resolve();
  }
};
var Ar = class {
  constructor() {
    this.Zn = new _n(Rr.ts), this.es = new _n(Rr.ns);
  }
  isEmpty() {
    return this.Zn.isEmpty();
  }
  addReference(t2, e) {
    const n = new Rr(t2, e);
    this.Zn = this.Zn.add(n), this.es = this.es.add(n);
  }
  ss(t2, e) {
    t2.forEach((t3) => this.addReference(t3, e));
  }
  removeReference(t2, e) {
    this.rs(new Rr(t2, e));
  }
  os(t2, e) {
    t2.forEach((t3) => this.removeReference(t3, e));
  }
  cs(t2) {
    const e = new Rt(new ct([])), n = new Rr(e, t2), s = new Rr(e, t2 + 1), i = [];
    return this.es.forEachInRange([n, s], (t3) => {
      this.rs(t3), i.push(t3.key);
    }), i;
  }
  us() {
    this.Zn.forEach((t2) => this.rs(t2));
  }
  rs(t2) {
    this.Zn = this.Zn.delete(t2), this.es = this.es.delete(t2);
  }
  hs(t2) {
    const e = new Rt(new ct([])), n = new Rr(e, t2), s = new Rr(e, t2 + 1);
    let i = Rn();
    return this.es.forEachInRange([n, s], (t3) => {
      i = i.add(t3.key);
    }), i;
  }
  containsKey(t2) {
    const e = new Rr(t2, 0), n = this.Zn.firstAfterOrEqual(e);
    return n !== null && t2.isEqual(n.key);
  }
};
var Rr = class {
  constructor(t2, e) {
    this.key = t2, this.ls = e;
  }
  static ts(t2, e) {
    return Rt.comparator(t2.key, e.key) || Z2(t2.ls, e.ls);
  }
  static ns(t2, e) {
    return Z2(t2.ls, e.ls) || Rt.comparator(t2.key, e.key);
  }
};
var br = class {
  constructor(t2, e) {
    this.Ht = t2, this.referenceDelegate = e, this.In = [], this.fs = 1, this.ds = new _n(Rr.ts);
  }
  checkEmpty(t2) {
    return qs.resolve(this.In.length === 0);
  }
  addMutationBatch(t2, e, n, s) {
    const i = this.fs;
    this.fs++, this.In.length > 0 && this.In[this.In.length - 1];
    const r = new ti(i, e, n, s);
    this.In.push(r);
    for (const e2 of s)
      this.ds = this.ds.add(new Rr(e2.key, i)), this.Ht.addToCollectionParentIndex(t2, e2.key.path.popLast());
    return qs.resolve(r);
  }
  lookupMutationBatch(t2, e) {
    return qs.resolve(this.ws(e));
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = this._s(n), i = s < 0 ? 0 : s;
    return qs.resolve(this.In.length > i ? this.In[i] : null);
  }
  getHighestUnacknowledgedBatchId() {
    return qs.resolve(this.In.length === 0 ? -1 : this.fs - 1);
  }
  getAllMutationBatches(t2) {
    return qs.resolve(this.In.slice());
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = new Rr(e, 0), s = new Rr(e, Number.POSITIVE_INFINITY), i = [];
    return this.ds.forEachInRange([n, s], (t3) => {
      const e2 = this.ws(t3.ls);
      i.push(e2);
    }), qs.resolve(i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new _n(Z2);
    return e.forEach((t3) => {
      const e2 = new Rr(t3, 0), s = new Rr(t3, Number.POSITIVE_INFINITY);
      this.ds.forEachInRange([e2, s], (t4) => {
        n = n.add(t4.ls);
      });
    }), qs.resolve(this.gs(n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1;
    let i = n;
    Rt.isDocumentKey(i) || (i = i.child(""));
    const r = new Rr(new Rt(i), 0);
    let o = new _n(Z2);
    return this.ds.forEachWhile((t3) => {
      const e2 = t3.key.path;
      return !!n.isPrefixOf(e2) && (e2.length === s && (o = o.add(t3.ls)), true);
    }, r), qs.resolve(this.gs(o));
  }
  gs(t2) {
    const e = [];
    return t2.forEach((t3) => {
      const n = this.ws(t3);
      n !== null && e.push(n);
    }), e;
  }
  removeMutationBatch(t2, e) {
    M2(this.ys(e.batchId, "removed") === 0), this.In.shift();
    let n = this.ds;
    return qs.forEach(e.mutations, (s) => {
      const i = new Rr(s.key, e.batchId);
      return n = n.delete(i), this.referenceDelegate.markPotentiallyOrphaned(t2, s.key);
    }).next(() => {
      this.ds = n;
    });
  }
  te(t2) {
  }
  containsKey(t2, e) {
    const n = new Rr(e, 0), s = this.ds.firstAfterOrEqual(n);
    return qs.resolve(e.isEqual(s && s.key));
  }
  performConsistencyCheck(t2) {
    return this.In.length, qs.resolve();
  }
  ys(t2, e) {
    return this._s(t2);
  }
  _s(t2) {
    if (this.In.length === 0)
      return 0;
    return t2 - this.In[0].batchId;
  }
  ws(t2) {
    const e = this._s(t2);
    if (e < 0 || e >= this.In.length)
      return null;
    return this.In[e];
  }
};
var Pr = class {
  constructor(t2, e) {
    this.Ht = t2, this.ps = e, this.docs = new fn(Rt.comparator), this.size = 0;
  }
  addEntry(t2, e, n) {
    const s = e.key, i = this.docs.get(s), r = i ? i.size : 0, o = this.ps(e);
    return this.docs = this.docs.insert(s, {
      document: e.clone(),
      size: o,
      readTime: n
    }), this.size += o - r, this.Ht.addToCollectionParentIndex(t2, s.path.popLast());
  }
  removeEntry(t2) {
    const e = this.docs.get(t2);
    e && (this.docs = this.docs.remove(t2), this.size -= e.size);
  }
  getEntry(t2, e) {
    const n = this.docs.get(e);
    return qs.resolve(n ? n.document.clone() : Ut.newInvalidDocument(e));
  }
  getEntries(t2, e) {
    let n = yn();
    return e.forEach((t3) => {
      const e2 = this.docs.get(t3);
      n = n.insert(t3, e2 ? e2.document.clone() : Ut.newInvalidDocument(t3));
    }), qs.resolve(n);
  }
  getDocumentsMatchingQuery(t2, e, n) {
    let s = yn();
    const i = new Rt(e.path.child("")), r = this.docs.getIteratorFrom(i);
    for (; r.hasNext(); ) {
      const { key: t3, value: { document: i2, readTime: o } } = r.getNext();
      if (!e.path.isPrefixOf(t3.path))
        break;
      o.compareTo(n) <= 0 || Re(e, i2) && (s = s.insert(i2.key, i2.clone()));
    }
    return qs.resolve(s);
  }
  Es(t2, e) {
    return qs.forEach(this.docs, (t3) => e(t3));
  }
  newChangeBuffer(t2) {
    return new vr(this);
  }
  getSize(t2) {
    return qs.resolve(this.size);
  }
};
var vr = class extends Ki {
  constructor(t2) {
    super(), this.Se = t2;
  }
  applyChanges(t2) {
    const e = [];
    return this.changes.forEach((n, s) => {
      s.document.isValidDocument() ? e.push(this.Se.addEntry(t2, s.document, this.getReadTime(n))) : this.Se.removeEntry(n);
    }), qs.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.Se.getEntry(t2, e);
  }
  getAllFromCache(t2, e) {
    return this.Se.getEntries(t2, e);
  }
};
var Vr = class {
  constructor(t2) {
    this.persistence = t2, this.Ts = new qi((t3) => jt(t3), Wt), this.lastRemoteSnapshotVersion = st.min(), this.highestTargetId = 0, this.Is = 0, this.As = new Ar(), this.targetCount = 0, this.Rs = Di.se();
  }
  forEachTarget(t2, e) {
    return this.Ts.forEach((t3, n) => e(n)), qs.resolve();
  }
  getLastRemoteSnapshotVersion(t2) {
    return qs.resolve(this.lastRemoteSnapshotVersion);
  }
  getHighestSequenceNumber(t2) {
    return qs.resolve(this.Is);
  }
  allocateTargetId(t2) {
    return this.highestTargetId = this.Rs.next(), qs.resolve(this.highestTargetId);
  }
  setTargetsMetadata(t2, e, n) {
    return n && (this.lastRemoteSnapshotVersion = n), e > this.Is && (this.Is = e), qs.resolve();
  }
  ae(t2) {
    this.Ts.set(t2.target, t2);
    const e = t2.targetId;
    e > this.highestTargetId && (this.Rs = new Di(e), this.highestTargetId = e), t2.sequenceNumber > this.Is && (this.Is = t2.sequenceNumber);
  }
  addTargetData(t2, e) {
    return this.ae(e), this.targetCount += 1, qs.resolve();
  }
  updateTargetData(t2, e) {
    return this.ae(e), qs.resolve();
  }
  removeTargetData(t2, e) {
    return this.Ts.delete(e.target), this.As.cs(e.targetId), this.targetCount -= 1, qs.resolve();
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return this.Ts.forEach((r, o) => {
      o.sequenceNumber <= e && n.get(o.targetId) === null && (this.Ts.delete(r), i.push(this.removeMatchingKeysForTargetId(t2, o.targetId)), s++);
    }), qs.waitFor(i).next(() => s);
  }
  getTargetCount(t2) {
    return qs.resolve(this.targetCount);
  }
  getTargetData(t2, e) {
    const n = this.Ts.get(e) || null;
    return qs.resolve(n);
  }
  addMatchingKeys(t2, e, n) {
    return this.As.ss(e, n), qs.resolve();
  }
  removeMatchingKeys(t2, e, n) {
    this.As.os(e, n);
    const s = this.persistence.referenceDelegate, i = [];
    return s && e.forEach((e2) => {
      i.push(s.markPotentiallyOrphaned(t2, e2));
    }), qs.waitFor(i);
  }
  removeMatchingKeysForTargetId(t2, e) {
    return this.As.cs(e), qs.resolve();
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = this.As.hs(e);
    return qs.resolve(n);
  }
  containsKey(t2, e) {
    return qs.resolve(this.As.containsKey(e));
  }
};
var Sr = class {
  constructor(t2, e) {
    this.bs = {}, this.Le = new J2(0), this.Be = false, this.Be = true, this.referenceDelegate = t2(this), this.ze = new Vr(this);
    this.Ht = new gi(), this.He = function(t3, e2) {
      return new Pr(t3, e2);
    }(this.Ht, (t3) => this.referenceDelegate.Ps(t3)), this.N = new si(e), this.Je = new Ir(this.N);
  }
  start() {
    return Promise.resolve();
  }
  shutdown() {
    return this.Be = false, Promise.resolve();
  }
  get started() {
    return this.Be;
  }
  setDatabaseDeletedListener() {
  }
  setNetworkEnabled() {
  }
  getIndexManager() {
    return this.Ht;
  }
  getMutationQueue(t2) {
    let e = this.bs[t2.toKey()];
    return e || (e = new br(this.Ht, this.referenceDelegate), this.bs[t2.toKey()] = e), e;
  }
  getTargetCache() {
    return this.ze;
  }
  getRemoteDocumentCache() {
    return this.He;
  }
  getBundleCache() {
    return this.Je;
  }
  runTransaction(t2, e, n) {
    x2("MemoryPersistence", "Starting transaction:", t2);
    const s = new Dr(this.Le.next());
    return this.referenceDelegate.vs(), n(s).next((t3) => this.referenceDelegate.Vs(s).next(() => t3)).toPromise().then((t3) => (s.raiseOnCommittedEvent(), t3));
  }
  Ss(t2, e) {
    return qs.or(Object.values(this.bs).map((n) => () => n.containsKey(t2, e)));
  }
};
var Dr = class extends Us {
  constructor(t2) {
    super(), this.currentSequenceNumber = t2;
  }
};
var Cr = class {
  constructor(t2) {
    this.persistence = t2, this.Ds = new Ar(), this.Cs = null;
  }
  static Ns(t2) {
    return new Cr(t2);
  }
  get xs() {
    if (this.Cs)
      return this.Cs;
    throw F2();
  }
  addReference(t2, e, n) {
    return this.Ds.addReference(n, e), this.xs.delete(n.toString()), qs.resolve();
  }
  removeReference(t2, e, n) {
    return this.Ds.removeReference(n, e), this.xs.add(n.toString()), qs.resolve();
  }
  markPotentiallyOrphaned(t2, e) {
    return this.xs.add(e.toString()), qs.resolve();
  }
  removeTarget(t2, e) {
    this.Ds.cs(e.targetId).forEach((t3) => this.xs.add(t3.toString()));
    const n = this.persistence.getTargetCache();
    return n.getMatchingKeysForTargetId(t2, e.targetId).next((t3) => {
      t3.forEach((t4) => this.xs.add(t4.toString()));
    }).next(() => n.removeTargetData(t2, e));
  }
  vs() {
    this.Cs = new Set();
  }
  Vs(t2) {
    const e = this.persistence.getRemoteDocumentCache().newChangeBuffer();
    return qs.forEach(this.xs, (n) => {
      const s = Rt.fromPath(n);
      return this.ks(t2, s).next((t3) => {
        t3 || e.removeEntry(s);
      });
    }).next(() => (this.Cs = null, e.apply(t2)));
  }
  updateLimboDocument(t2, e) {
    return this.ks(t2, e).next((t3) => {
      t3 ? this.xs.delete(e.toString()) : this.xs.add(e.toString());
    });
  }
  Ps(t2) {
    return 0;
  }
  ks(t2, e) {
    return qs.or([() => qs.resolve(this.Ds.containsKey(e)), () => this.persistence.getTargetCache().containsKey(t2, e), () => this.persistence.Ss(t2, e)]);
  }
};
function Nr(t2, e) {
  return `firestore_clients_${t2}_${e}`;
}
function xr(t2, e, n) {
  let s = `firestore_mutations_${t2}_${n}`;
  return e.isAuthenticated() && (s += `_${e.uid}`), s;
}
function kr(t2, e) {
  return `firestore_targets_${t2}_${e}`;
}
var $r = class {
  constructor(t2, e, n, s) {
    this.user = t2, this.batchId = e, this.state = n, this.error = s;
  }
  static $s(t2, e, n) {
    const s = JSON.parse(n);
    let i, r = typeof s == "object" && ["pending", "acknowledged", "rejected"].indexOf(s.state) !== -1 && (s.error === void 0 || typeof s.error == "object");
    return r && s.error && (r = typeof s.error.message == "string" && typeof s.error.code == "string", r && (i = new q2(s.error.code, s.error.message))), r ? new $r(t2, e, s.state, i) : (k2("SharedClientState", `Failed to parse mutation state for ID '${e}': ${n}`), null);
  }
  Os() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var Or = class {
  constructor(t2, e, n) {
    this.targetId = t2, this.state = e, this.error = n;
  }
  static $s(t2, e) {
    const n = JSON.parse(e);
    let s, i = typeof n == "object" && ["not-current", "current", "rejected"].indexOf(n.state) !== -1 && (n.error === void 0 || typeof n.error == "object");
    return i && n.error && (i = typeof n.error.message == "string" && typeof n.error.code == "string", i && (s = new q2(n.error.code, n.error.message))), i ? new Or(t2, n.state, s) : (k2("SharedClientState", `Failed to parse target state for ID '${t2}': ${e}`), null);
  }
  Os() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var Fr = class {
  constructor(t2, e) {
    this.clientId = t2, this.activeTargetIds = e;
  }
  static $s(t2, e) {
    const n = JSON.parse(e);
    let s = typeof n == "object" && n.activeTargetIds instanceof Array, i = Pn();
    for (let t3 = 0; s && t3 < n.activeTargetIds.length; ++t3)
      s = At(n.activeTargetIds[t3]), i = i.add(n.activeTargetIds[t3]);
    return s ? new Fr(t2, i) : (k2("SharedClientState", `Failed to parse client data for instance '${t2}': ${e}`), null);
  }
};
var Mr = class {
  constructor(t2, e) {
    this.clientId = t2, this.onlineState = e;
  }
  static $s(t2) {
    const e = JSON.parse(t2);
    return typeof e == "object" && ["Unknown", "Online", "Offline"].indexOf(e.onlineState) !== -1 && typeof e.clientId == "string" ? new Mr(e.clientId, e.onlineState) : (k2("SharedClientState", `Failed to parse online state: ${t2}`), null);
  }
};
var Lr = class {
  constructor() {
    this.activeTargetIds = Pn();
  }
  Fs(t2) {
    this.activeTargetIds = this.activeTargetIds.add(t2);
  }
  Ms(t2) {
    this.activeTargetIds = this.activeTargetIds.delete(t2);
  }
  Os() {
    const t2 = {
      activeTargetIds: this.activeTargetIds.toArray(),
      updateTimeMs: Date.now()
    };
    return JSON.stringify(t2);
  }
};
var Br = class {
  constructor(t2, e, n, s, i) {
    this.window = t2, this.Oe = e, this.persistenceKey = n, this.Ls = s, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this.Bs = this.Us.bind(this), this.qs = new fn(Z2), this.started = false, this.Ks = [];
    const r = n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    this.storage = this.window.localStorage, this.currentUser = i, this.js = Nr(this.persistenceKey, this.Ls), this.Qs = function(t3) {
      return `firestore_sequence_number_${t3}`;
    }(this.persistenceKey), this.qs = this.qs.insert(this.Ls, new Lr()), this.Ws = new RegExp(`^firestore_clients_${r}_([^_]*)$`), this.Gs = new RegExp(`^firestore_mutations_${r}_(\\d+)(?:_(.*))?$`), this.zs = new RegExp(`^firestore_targets_${r}_(\\d+)$`), this.Hs = function(t3) {
      return `firestore_online_state_${t3}`;
    }(this.persistenceKey), this.Js = function(t3) {
      return `firestore_bundle_loaded_${t3}`;
    }(this.persistenceKey), this.window.addEventListener("storage", this.Bs);
  }
  static bt(t2) {
    return !(!t2 || !t2.localStorage);
  }
  async start() {
    const t2 = await this.syncEngine.pn();
    for (const e2 of t2) {
      if (e2 === this.Ls)
        continue;
      const t3 = this.getItem(Nr(this.persistenceKey, e2));
      if (t3) {
        const n = Fr.$s(e2, t3);
        n && (this.qs = this.qs.insert(n.clientId, n));
      }
    }
    this.Ys();
    const e = this.storage.getItem(this.Hs);
    if (e) {
      const t3 = this.Xs(e);
      t3 && this.Zs(t3);
    }
    for (const t3 of this.Ks)
      this.Us(t3);
    this.Ks = [], this.window.addEventListener("pagehide", () => this.shutdown()), this.started = true;
  }
  writeSequenceNumber(t2) {
    this.setItem(this.Qs, JSON.stringify(t2));
  }
  getAllActiveQueryTargets() {
    return this.ti(this.qs);
  }
  isActiveQueryTarget(t2) {
    let e = false;
    return this.qs.forEach((n, s) => {
      s.activeTargetIds.has(t2) && (e = true);
    }), e;
  }
  addPendingMutation(t2) {
    this.ei(t2, "pending");
  }
  updateMutationState(t2, e, n) {
    this.ei(t2, e, n), this.ni(t2);
  }
  addLocalQueryTarget(t2) {
    let e = "not-current";
    if (this.isActiveQueryTarget(t2)) {
      const n = this.storage.getItem(kr(this.persistenceKey, t2));
      if (n) {
        const s = Or.$s(t2, n);
        s && (e = s.state);
      }
    }
    return this.si.Fs(t2), this.Ys(), e;
  }
  removeLocalQueryTarget(t2) {
    this.si.Ms(t2), this.Ys();
  }
  isLocalQueryTarget(t2) {
    return this.si.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    this.removeItem(kr(this.persistenceKey, t2));
  }
  updateQueryState(t2, e, n) {
    this.ii(t2, e, n);
  }
  handleUserChange(t2, e, n) {
    e.forEach((t3) => {
      this.ni(t3);
    }), this.currentUser = t2, n.forEach((t3) => {
      this.addPendingMutation(t3);
    });
  }
  setOnlineState(t2) {
    this.ri(t2);
  }
  notifyBundleLoaded() {
    this.oi();
  }
  shutdown() {
    this.started && (this.window.removeEventListener("storage", this.Bs), this.removeItem(this.js), this.started = false);
  }
  getItem(t2) {
    const e = this.storage.getItem(t2);
    return x2("SharedClientState", "READ", t2, e), e;
  }
  setItem(t2, e) {
    x2("SharedClientState", "SET", t2, e), this.storage.setItem(t2, e);
  }
  removeItem(t2) {
    x2("SharedClientState", "REMOVE", t2), this.storage.removeItem(t2);
  }
  Us(t2) {
    const e = t2;
    if (e.storageArea === this.storage) {
      if (x2("SharedClientState", "EVENT", e.key, e.newValue), e.key === this.js)
        return void k2("Received WebStorage notification for local change. Another client might have garbage-collected our state");
      this.Oe.enqueueRetryable(async () => {
        if (this.started) {
          if (e.key !== null) {
            if (this.Ws.test(e.key)) {
              if (e.newValue == null) {
                const t3 = this.ai(e.key);
                return this.ci(t3, null);
              }
              {
                const t3 = this.ui(e.key, e.newValue);
                if (t3)
                  return this.ci(t3.clientId, t3);
              }
            } else if (this.Gs.test(e.key)) {
              if (e.newValue !== null) {
                const t3 = this.hi(e.key, e.newValue);
                if (t3)
                  return this.li(t3);
              }
            } else if (this.zs.test(e.key)) {
              if (e.newValue !== null) {
                const t3 = this.fi(e.key, e.newValue);
                if (t3)
                  return this.di(t3);
              }
            } else if (e.key === this.Hs) {
              if (e.newValue !== null) {
                const t3 = this.Xs(e.newValue);
                if (t3)
                  return this.Zs(t3);
              }
            } else if (e.key === this.Qs) {
              const t3 = function(t4) {
                let e2 = J2.T;
                if (t4 != null)
                  try {
                    const n = JSON.parse(t4);
                    M2(typeof n == "number"), e2 = n;
                  } catch (t5) {
                    k2("SharedClientState", "Failed to read sequence number from WebStorage", t5);
                  }
                return e2;
              }(e.newValue);
              t3 !== J2.T && this.sequenceNumberHandler(t3);
            } else if (e.key === this.Js)
              return this.syncEngine.wi();
          }
        } else
          this.Ks.push(e);
      });
    }
  }
  get si() {
    return this.qs.get(this.Ls);
  }
  Ys() {
    this.setItem(this.js, this.si.Os());
  }
  ei(t2, e, n) {
    const s = new $r(this.currentUser, t2, e, n), i = xr(this.persistenceKey, this.currentUser, t2);
    this.setItem(i, s.Os());
  }
  ni(t2) {
    const e = xr(this.persistenceKey, this.currentUser, t2);
    this.removeItem(e);
  }
  ri(t2) {
    const e = {
      clientId: this.Ls,
      onlineState: t2
    };
    this.storage.setItem(this.Hs, JSON.stringify(e));
  }
  ii(t2, e, n) {
    const s = kr(this.persistenceKey, t2), i = new Or(t2, e, n);
    this.setItem(s, i.Os());
  }
  oi() {
    this.setItem(this.Js, "value-not-used");
  }
  ai(t2) {
    const e = this.Ws.exec(t2);
    return e ? e[1] : null;
  }
  ui(t2, e) {
    const n = this.ai(t2);
    return Fr.$s(n, e);
  }
  hi(t2, e) {
    const n = this.Gs.exec(t2), s = Number(n[1]), i = n[2] !== void 0 ? n[2] : null;
    return $r.$s(new V2(i), s, e);
  }
  fi(t2, e) {
    const n = this.zs.exec(t2), s = Number(n[1]);
    return Or.$s(s, e);
  }
  Xs(t2) {
    return Mr.$s(t2);
  }
  async li(t2) {
    if (t2.user.uid === this.currentUser.uid)
      return this.syncEngine._i(t2.batchId, t2.state, t2.error);
    x2("SharedClientState", `Ignoring mutation for non-active user ${t2.user.uid}`);
  }
  di(t2) {
    return this.syncEngine.mi(t2.targetId, t2.state, t2.error);
  }
  ci(t2, e) {
    const n = e ? this.qs.insert(t2, e) : this.qs.remove(t2), s = this.ti(this.qs), i = this.ti(n), r = [], o = [];
    return i.forEach((t3) => {
      s.has(t3) || r.push(t3);
    }), s.forEach((t3) => {
      i.has(t3) || o.push(t3);
    }), this.syncEngine.gi(r, o).then(() => {
      this.qs = n;
    });
  }
  Zs(t2) {
    this.qs.get(t2.clientId) && this.onlineStateHandler(t2.onlineState);
  }
  ti(t2) {
    let e = Pn();
    return t2.forEach((t3, n) => {
      e = e.unionWith(n.activeTargetIds);
    }), e;
  }
};
var Ur = class {
  constructor() {
    this.yi = new Lr(), this.pi = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
  }
  addPendingMutation(t2) {
  }
  updateMutationState(t2, e, n) {
  }
  addLocalQueryTarget(t2) {
    return this.yi.Fs(t2), this.pi[t2] || "not-current";
  }
  updateQueryState(t2, e, n) {
    this.pi[t2] = e;
  }
  removeLocalQueryTarget(t2) {
    this.yi.Ms(t2);
  }
  isLocalQueryTarget(t2) {
    return this.yi.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    delete this.pi[t2];
  }
  getAllActiveQueryTargets() {
    return this.yi.activeTargetIds;
  }
  isActiveQueryTarget(t2) {
    return this.yi.activeTargetIds.has(t2);
  }
  start() {
    return this.yi = new Lr(), Promise.resolve();
  }
  handleUserChange(t2, e, n) {
  }
  setOnlineState(t2) {
  }
  shutdown() {
  }
  writeSequenceNumber(t2) {
  }
  notifyBundleLoaded() {
  }
};
var qr = class {
  Ei(t2) {
  }
  shutdown() {
  }
};
var Kr = class {
  constructor() {
    this.Ti = () => this.Ii(), this.Ai = () => this.Ri(), this.bi = [], this.Pi();
  }
  Ei(t2) {
    this.bi.push(t2);
  }
  shutdown() {
    window.removeEventListener("online", this.Ti), window.removeEventListener("offline", this.Ai);
  }
  Pi() {
    window.addEventListener("online", this.Ti), window.addEventListener("offline", this.Ai);
  }
  Ii() {
    x2("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
    for (const t2 of this.bi)
      t2(0);
  }
  Ri() {
    x2("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
    for (const t2 of this.bi)
      t2(1);
  }
  static bt() {
    return typeof window != "undefined" && window.addEventListener !== void 0 && window.removeEventListener !== void 0;
  }
};
var jr = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery"
};
var Qr = class {
  constructor(t2) {
    this.vi = t2.vi, this.Vi = t2.Vi;
  }
  Si(t2) {
    this.Di = t2;
  }
  Ci(t2) {
    this.Ni = t2;
  }
  onMessage(t2) {
    this.xi = t2;
  }
  close() {
    this.Vi();
  }
  send(t2) {
    this.vi(t2);
  }
  ki() {
    this.Di();
  }
  $i(t2) {
    this.Ni(t2);
  }
  Oi(t2) {
    this.xi(t2);
  }
};
var Wr = class extends class {
  constructor(t2) {
    this.databaseInfo = t2, this.databaseId = t2.databaseId;
    const e = t2.ssl ? "https" : "http";
    this.Fi = e + "://" + t2.host, this.Mi = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
  }
  Li(t2, e, n, s) {
    const i = this.Bi(t2, e);
    x2("RestConnection", "Sending: ", i, n);
    const r = {};
    return this.Ui(r, s), this.qi(t2, i, r, n).then((t3) => (x2("RestConnection", "Received: ", t3), t3), (e2) => {
      throw $("RestConnection", `${t2} failed with error: `, e2, "url: ", i, "request:", n), e2;
    });
  }
  Ki(t2, e, n, s) {
    return this.Li(t2, e, n, s);
  }
  Ui(t2, e) {
    if (t2["X-Goog-Api-Client"] = "gl-js/ fire/" + S2, t2["Content-Type"] = "text/plain", this.databaseInfo.appId && (t2["X-Firebase-GMPID"] = this.databaseInfo.appId), e)
      for (const n in e.authHeaders)
        e.authHeaders.hasOwnProperty(n) && (t2[n] = e.authHeaders[n]);
  }
  Bi(t2, e) {
    const n = jr[t2];
    return `${this.Fi}/v1/${e}:${n}`;
  }
} {
  constructor(t2) {
    super(t2), this.forceLongPolling = t2.forceLongPolling, this.autoDetectLongPolling = t2.autoDetectLongPolling, this.useFetchStreams = t2.useFetchStreams;
  }
  qi(t2, e, n, s) {
    return new Promise((i, r) => {
      const o = new XhrIo();
      o.listenOnce(EventType.COMPLETE, () => {
        try {
          switch (o.getLastErrorCode()) {
            case ErrorCode.NO_ERROR:
              const e2 = o.getResponseJson();
              x2("Connection", "XHR received:", JSON.stringify(e2)), i(e2);
              break;
            case ErrorCode.TIMEOUT:
              x2("Connection", 'RPC "' + t2 + '" timed out'), r(new q2(U2.DEADLINE_EXCEEDED, "Request time out"));
              break;
            case ErrorCode.HTTP_ERROR:
              const n2 = o.getStatus();
              if (x2("Connection", 'RPC "' + t2 + '" failed with status:', n2, "response text:", o.getResponseText()), n2 > 0) {
                const t3 = o.getResponseJson().error;
                if (t3 && t3.status && t3.message) {
                  const e3 = function(t4) {
                    const e4 = t4.toLowerCase().replace(/_/g, "-");
                    return Object.values(U2).indexOf(e4) >= 0 ? e4 : U2.UNKNOWN;
                  }(t3.status);
                  r(new q2(e3, t3.message));
                } else
                  r(new q2(U2.UNKNOWN, "Server responded with status " + o.getStatus()));
              } else
                r(new q2(U2.UNAVAILABLE, "Connection failed."));
              break;
            default:
              F2();
          }
        } finally {
          x2("Connection", 'RPC "' + t2 + '" completed.');
        }
      });
      const a = JSON.stringify(s);
      o.send(e, "POST", a, n, 15);
    });
  }
  ji(t2, e) {
    const n = [this.Fi, "/", "google.firestore.v1.Firestore", "/", t2, "/channel"], s = createWebChannelTransport(), i = getStatEventTarget(), r = {
      httpSessionIdParam: "gsessionid",
      initMessageHeaders: {},
      messageUrlParams: {
        database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
      },
      sendRawJson: true,
      supportsCrossDomainXhr: true,
      internalChannelParams: {
        forwardChannelRequestTimeoutMs: 6e5
      },
      forceLongPolling: this.forceLongPolling,
      detectBufferingProxy: this.autoDetectLongPolling
    };
    this.useFetchStreams && (r.xmlHttpFactory = new FetchXmlHttpFactory({})), this.Ui(r.initMessageHeaders, e), isMobileCordova() || isReactNative() || isElectron() || isIE() || isUWP() || isBrowserExtension() || (r.httpHeadersOverwriteParam = "$httpHeaders");
    const o = n.join("");
    x2("Connection", "Creating WebChannel: " + o, r);
    const a = s.createWebChannel(o, r);
    let c = false, u = false;
    const m = new Qr({
      vi: (t3) => {
        u ? x2("Connection", "Not sending because WebChannel is closed:", t3) : (c || (x2("Connection", "Opening WebChannel transport."), a.open(), c = true), x2("Connection", "WebChannel sending:", t3), a.send(t3));
      },
      Vi: () => a.close()
    }), g = (t3, e2, n2) => {
      t3.listen(e2, (t4) => {
        try {
          n2(t4);
        } catch (t5) {
          setTimeout(() => {
            throw t5;
          }, 0);
        }
      });
    };
    return g(a, WebChannel.EventType.OPEN, () => {
      u || x2("Connection", "WebChannel transport opened.");
    }), g(a, WebChannel.EventType.CLOSE, () => {
      u || (u = true, x2("Connection", "WebChannel transport closed"), m.$i());
    }), g(a, WebChannel.EventType.ERROR, (t3) => {
      u || (u = true, $("Connection", "WebChannel transport errored:", t3), m.$i(new q2(U2.UNAVAILABLE, "The operation could not be completed")));
    }), g(a, WebChannel.EventType.MESSAGE, (t3) => {
      var e2;
      if (!u) {
        const n2 = t3.data[0];
        M2(!!n2);
        const s2 = n2, i2 = s2.error || ((e2 = s2[0]) === null || e2 === void 0 ? void 0 : e2.error);
        if (i2) {
          x2("Connection", "WebChannel received error:", i2);
          const t4 = i2.status;
          let e3 = function(t5) {
            const e4 = cn[t5];
            if (e4 !== void 0)
              return ln(e4);
          }(t4), n3 = i2.message;
          e3 === void 0 && (e3 = U2.INTERNAL, n3 = "Unknown error status: " + t4 + " with message " + i2.message), u = true, m.$i(new q2(e3, n3)), a.close();
        } else
          x2("Connection", "WebChannel received:", n2), m.Oi(n2);
      }
    }), g(i, Event.STAT_EVENT, (t3) => {
      t3.stat === Stat.PROXY ? x2("Connection", "Detected buffering proxy") : t3.stat === Stat.NOPROXY && x2("Connection", "Detected no buffering proxy");
    }), setTimeout(() => {
      m.ki();
    }, 0), m;
  }
};
function Gr() {
  return typeof window != "undefined" ? window : null;
}
function zr() {
  return typeof document != "undefined" ? document : null;
}
function Hr(t2) {
  return new Mn(t2, true);
}
var Jr = class {
  constructor(t2, e, n = 1e3, s = 1.5, i = 6e4) {
    this.Oe = t2, this.timerId = e, this.Qi = n, this.Wi = s, this.Gi = i, this.zi = 0, this.Hi = null, this.Ji = Date.now(), this.reset();
  }
  reset() {
    this.zi = 0;
  }
  Yi() {
    this.zi = this.Gi;
  }
  Xi(t2) {
    this.cancel();
    const e = Math.floor(this.zi + this.Zi()), n = Math.max(0, Date.now() - this.Ji), s = Math.max(0, e - n);
    s > 0 && x2("ExponentialBackoff", `Backing off for ${s} ms (base delay: ${this.zi} ms, delay with jitter: ${e} ms, last attempt: ${n} ms ago)`), this.Hi = this.Oe.enqueueAfterDelay(this.timerId, s, () => (this.Ji = Date.now(), t2())), this.zi *= this.Wi, this.zi < this.Qi && (this.zi = this.Qi), this.zi > this.Gi && (this.zi = this.Gi);
  }
  tr() {
    this.Hi !== null && (this.Hi.skipDelay(), this.Hi = null);
  }
  cancel() {
    this.Hi !== null && (this.Hi.cancel(), this.Hi = null);
  }
  Zi() {
    return (Math.random() - 0.5) * this.zi;
  }
};
var Yr = class {
  constructor(t2, e, n, s, i, r) {
    this.Oe = t2, this.er = n, this.nr = s, this.credentialsProvider = i, this.listener = r, this.state = 0, this.sr = 0, this.ir = null, this.stream = null, this.rr = new Jr(t2, e);
  }
  ar() {
    return this.state === 1 || this.state === 2 || this.state === 4;
  }
  cr() {
    return this.state === 2;
  }
  start() {
    this.state !== 3 ? this.auth() : this.ur();
  }
  async stop() {
    this.ar() && await this.close(0);
  }
  hr() {
    this.state = 0, this.rr.reset();
  }
  lr() {
    this.cr() && this.ir === null && (this.ir = this.Oe.enqueueAfterDelay(this.er, 6e4, () => this.dr()));
  }
  wr(t2) {
    this._r(), this.stream.send(t2);
  }
  async dr() {
    if (this.cr())
      return this.close(0);
  }
  _r() {
    this.ir && (this.ir.cancel(), this.ir = null);
  }
  async close(t2, e) {
    this._r(), this.rr.cancel(), this.sr++, t2 !== 3 ? this.rr.reset() : e && e.code === U2.RESOURCE_EXHAUSTED ? (k2(e.toString()), k2("Using maximum backoff delay to prevent overloading the backend."), this.rr.Yi()) : e && e.code === U2.UNAUTHENTICATED && this.credentialsProvider.invalidateToken(), this.stream !== null && (this.mr(), this.stream.close(), this.stream = null), this.state = t2, await this.listener.Ci(e);
  }
  mr() {
  }
  auth() {
    this.state = 1;
    const t2 = this.gr(this.sr), e = this.sr;
    this.credentialsProvider.getToken().then((t3) => {
      this.sr === e && this.yr(t3);
    }, (e2) => {
      t2(() => {
        const t3 = new q2(U2.UNKNOWN, "Fetching auth token failed: " + e2.message);
        return this.pr(t3);
      });
    });
  }
  yr(t2) {
    const e = this.gr(this.sr);
    this.stream = this.Er(t2), this.stream.Si(() => {
      e(() => (this.state = 2, this.listener.Si()));
    }), this.stream.Ci((t3) => {
      e(() => this.pr(t3));
    }), this.stream.onMessage((t3) => {
      e(() => this.onMessage(t3));
    });
  }
  ur() {
    this.state = 4, this.rr.Xi(async () => {
      this.state = 0, this.start();
    });
  }
  pr(t2) {
    return x2("PersistentStream", `close with error: ${t2}`), this.stream = null, this.close(3, t2);
  }
  gr(t2) {
    return (e) => {
      this.Oe.enqueueAndForget(() => this.sr === t2 ? e() : (x2("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()));
    };
  }
};
var Xr = class extends Yr {
  constructor(t2, e, n, s, i) {
    super(t2, "listen_stream_connection_backoff", "listen_stream_idle", e, n, i), this.N = s;
  }
  Er(t2) {
    return this.nr.ji("Listen", t2);
  }
  onMessage(t2) {
    this.rr.reset();
    const e = ts(this.N, t2), n = function(t3) {
      if (!("targetChange" in t3))
        return st.min();
      const e2 = t3.targetChange;
      return e2.targetIds && e2.targetIds.length ? st.min() : e2.readTime ? qn(e2.readTime) : st.min();
    }(t2);
    return this.listener.Tr(e, n);
  }
  Ir(t2) {
    const e = {};
    e.database = Hn(this.N), e.addTarget = function(t3, e2) {
      let n2;
      const s = e2.target;
      return n2 = Gt(s) ? {
        documents: is(t3, s)
      } : {
        query: rs(t3, s)
      }, n2.targetId = e2.targetId, e2.resumeToken.approximateByteSize() > 0 ? n2.resumeToken = Bn(t3, e2.resumeToken) : e2.snapshotVersion.compareTo(st.min()) > 0 && (n2.readTime = Ln(t3, e2.snapshotVersion.toTimestamp())), n2;
    }(this.N, t2);
    const n = as(this.N, t2);
    n && (e.labels = n), this.wr(e);
  }
  Ar(t2) {
    const e = {};
    e.database = Hn(this.N), e.removeTarget = t2, this.wr(e);
  }
};
var Zr = class extends Yr {
  constructor(t2, e, n, s, i) {
    super(t2, "write_stream_connection_backoff", "write_stream_idle", e, n, i), this.N = s, this.Rr = false;
  }
  get br() {
    return this.Rr;
  }
  start() {
    this.Rr = false, this.lastStreamToken = void 0, super.start();
  }
  mr() {
    this.Rr && this.Pr([]);
  }
  Er(t2) {
    return this.nr.ji("Write", t2);
  }
  onMessage(t2) {
    if (M2(!!t2.streamToken), this.lastStreamToken = t2.streamToken, this.Rr) {
      this.rr.reset();
      const e = ss(t2.writeResults, t2.commitTime), n = qn(t2.commitTime);
      return this.listener.vr(n, e);
    }
    return M2(!t2.writeResults || t2.writeResults.length === 0), this.Rr = true, this.listener.Vr();
  }
  Sr() {
    const t2 = {};
    t2.database = Hn(this.N), this.wr(t2);
  }
  Pr(t2) {
    const e = {
      streamToken: this.lastStreamToken,
      writes: t2.map((t3) => es(this.N, t3))
    };
    this.wr(e);
  }
};
var to = class extends class {
} {
  constructor(t2, e, n) {
    super(), this.credentials = t2, this.nr = e, this.N = n, this.Dr = false;
  }
  Cr() {
    if (this.Dr)
      throw new q2(U2.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  Li(t2, e, n) {
    return this.Cr(), this.credentials.getToken().then((s) => this.nr.Li(t2, e, n, s)).catch((t3) => {
      throw t3.name === "FirebaseError" ? (t3.code === U2.UNAUTHENTICATED && this.credentials.invalidateToken(), t3) : new q2(U2.UNKNOWN, t3.toString());
    });
  }
  Ki(t2, e, n) {
    return this.Cr(), this.credentials.getToken().then((s) => this.nr.Ki(t2, e, n, s)).catch((t3) => {
      throw t3.name === "FirebaseError" ? (t3.code === U2.UNAUTHENTICATED && this.credentials.invalidateToken(), t3) : new q2(U2.UNKNOWN, t3.toString());
    });
  }
  terminate() {
    this.Dr = true;
  }
};
var eo = class {
  constructor(t2, e) {
    this.asyncQueue = t2, this.onlineStateHandler = e, this.state = "Unknown", this.Nr = 0, this.kr = null, this.$r = true;
  }
  Or() {
    this.Nr === 0 && (this.Fr("Unknown"), this.kr = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.kr = null, this.Mr("Backend didn't respond within 10 seconds."), this.Fr("Offline"), Promise.resolve())));
  }
  Lr(t2) {
    this.state === "Online" ? this.Fr("Unknown") : (this.Nr++, this.Nr >= 1 && (this.Br(), this.Mr(`Connection failed 1 times. Most recent error: ${t2.toString()}`), this.Fr("Offline")));
  }
  set(t2) {
    this.Br(), this.Nr = 0, t2 === "Online" && (this.$r = false), this.Fr(t2);
  }
  Fr(t2) {
    t2 !== this.state && (this.state = t2, this.onlineStateHandler(t2));
  }
  Mr(t2) {
    const e = `Could not reach Cloud Firestore backend. ${t2}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
    this.$r ? (k2(e), this.$r = false) : x2("OnlineStateTracker", e);
  }
  Br() {
    this.kr !== null && (this.kr.cancel(), this.kr = null);
  }
};
var no = class {
  constructor(t2, e, n, s, i) {
    this.localStore = t2, this.datastore = e, this.asyncQueue = n, this.remoteSyncer = {}, this.Ur = [], this.qr = new Map(), this.Kr = new Set(), this.jr = [], this.Qr = i, this.Qr.Ei((t3) => {
      n.enqueueAndForget(async () => {
        lo(this) && (x2("RemoteStore", "Restarting streams for network reachability change."), await async function(t4) {
          const e2 = B2(t4);
          e2.Kr.add(4), await io(e2), e2.Wr.set("Unknown"), e2.Kr.delete(4), await so(e2);
        }(this));
      });
    }), this.Wr = new eo(n, s);
  }
};
async function so(t2) {
  if (lo(t2))
    for (const e of t2.jr)
      await e(true);
}
async function io(t2) {
  for (const e of t2.jr)
    await e(false);
}
function ro(t2, e) {
  const n = B2(t2);
  n.qr.has(e.targetId) || (n.qr.set(e.targetId, e), ho(n) ? uo(n) : So(n).cr() && ao(n, e));
}
function oo(t2, e) {
  const n = B2(t2), s = So(n);
  n.qr.delete(e), s.cr() && co(n, e), n.qr.size === 0 && (s.cr() ? s.lr() : lo(n) && n.Wr.set("Unknown"));
}
function ao(t2, e) {
  t2.Gr.Y(e.targetId), So(t2).Ir(e);
}
function co(t2, e) {
  t2.Gr.Y(e), So(t2).Ar(e);
}
function uo(t2) {
  t2.Gr = new xn({
    getRemoteKeysForTarget: (e) => t2.remoteSyncer.getRemoteKeysForTarget(e),
    Et: (e) => t2.qr.get(e) || null
  }), So(t2).start(), t2.Wr.Or();
}
function ho(t2) {
  return lo(t2) && !So(t2).ar() && t2.qr.size > 0;
}
function lo(t2) {
  return B2(t2).Kr.size === 0;
}
function fo(t2) {
  t2.Gr = void 0;
}
async function wo(t2) {
  t2.qr.forEach((e, n) => {
    ao(t2, e);
  });
}
async function _o(t2, e) {
  fo(t2), ho(t2) ? (t2.Wr.Lr(e), uo(t2)) : t2.Wr.set("Unknown");
}
async function mo(t2, e, n) {
  if (t2.Wr.set("Online"), e instanceof Cn && e.state === 2 && e.cause)
    try {
      await async function(t3, e2) {
        const n2 = e2.cause;
        for (const s of e2.targetIds)
          t3.qr.has(s) && (await t3.remoteSyncer.rejectListen(s, n2), t3.qr.delete(s), t3.Gr.removeTarget(s));
      }(t2, e);
    } catch (n2) {
      x2("RemoteStore", "Failed to remove targets %s: %s ", e.targetIds.join(","), n2), await go(t2, n2);
    }
  else if (e instanceof Sn ? t2.Gr.rt(e) : e instanceof Dn ? t2.Gr.ft(e) : t2.Gr.ct(e), !n.isEqual(st.min()))
    try {
      const e2 = await hr(t2.localStore);
      n.compareTo(e2) >= 0 && await function(t3, e3) {
        const n2 = t3.Gr._t(e3);
        return n2.targetChanges.forEach((n3, s) => {
          if (n3.resumeToken.approximateByteSize() > 0) {
            const i = t3.qr.get(s);
            i && t3.qr.set(s, i.withResumeToken(n3.resumeToken, e3));
          }
        }), n2.targetMismatches.forEach((e4) => {
          const n3 = t3.qr.get(e4);
          if (!n3)
            return;
          t3.qr.set(e4, n3.withResumeToken(dt.EMPTY_BYTE_STRING, n3.snapshotVersion)), co(t3, e4);
          const s = new ni(n3.target, e4, 1, n3.sequenceNumber);
          ao(t3, s);
        }), t3.remoteSyncer.applyRemoteEvent(n2);
      }(t2, n);
    } catch (e2) {
      x2("RemoteStore", "Failed to raise snapshot:", e2), await go(t2, e2);
    }
}
async function go(t2, e, n) {
  if (!Gs(e))
    throw e;
  t2.Kr.add(1), await io(t2), t2.Wr.set("Offline"), n || (n = () => hr(t2.localStore)), t2.asyncQueue.enqueueRetryable(async () => {
    x2("RemoteStore", "Retrying IndexedDB access"), await n(), t2.Kr.delete(1), await so(t2);
  });
}
function yo(t2, e) {
  return e().catch((n) => go(t2, n, e));
}
async function po(t2) {
  const e = B2(t2), n = Do(e);
  let s = e.Ur.length > 0 ? e.Ur[e.Ur.length - 1].batchId : -1;
  for (; Eo(e); )
    try {
      const t3 = await dr(e.localStore, s);
      if (t3 === null) {
        e.Ur.length === 0 && n.lr();
        break;
      }
      s = t3.batchId, To(e, t3);
    } catch (t3) {
      await go(e, t3);
    }
  Io(e) && Ao(e);
}
function Eo(t2) {
  return lo(t2) && t2.Ur.length < 10;
}
function To(t2, e) {
  t2.Ur.push(e);
  const n = Do(t2);
  n.cr() && n.br && n.Pr(e.mutations);
}
function Io(t2) {
  return lo(t2) && !Do(t2).ar() && t2.Ur.length > 0;
}
function Ao(t2) {
  Do(t2).start();
}
async function Ro(t2) {
  Do(t2).Sr();
}
async function bo(t2) {
  const e = Do(t2);
  for (const n of t2.Ur)
    e.Pr(n.mutations);
}
async function Po(t2, e, n) {
  const s = t2.Ur.shift(), i = ei.from(s, e, n);
  await yo(t2, () => t2.remoteSyncer.applySuccessfulWrite(i)), await po(t2);
}
async function vo(t2, e) {
  e && Do(t2).br && await async function(t3, e2) {
    if (n = e2.code, hn(n) && n !== U2.ABORTED) {
      const n2 = t3.Ur.shift();
      Do(t3).hr(), await yo(t3, () => t3.remoteSyncer.rejectFailedWrite(n2.batchId, e2)), await po(t3);
    }
    var n;
  }(t2, e), Io(t2) && Ao(t2);
}
async function Vo(t2, e) {
  const n = B2(t2);
  e ? (n.Kr.delete(2), await so(n)) : e || (n.Kr.add(2), await io(n), n.Wr.set("Unknown"));
}
function So(t2) {
  return t2.zr || (t2.zr = function(t3, e, n) {
    const s = B2(t3);
    return s.Cr(), new Xr(e, s.nr, s.credentials, s.N, n);
  }(t2.datastore, t2.asyncQueue, {
    Si: wo.bind(null, t2),
    Ci: _o.bind(null, t2),
    Tr: mo.bind(null, t2)
  }), t2.jr.push(async (e) => {
    e ? (t2.zr.hr(), ho(t2) ? uo(t2) : t2.Wr.set("Unknown")) : (await t2.zr.stop(), fo(t2));
  })), t2.zr;
}
function Do(t2) {
  return t2.Hr || (t2.Hr = function(t3, e, n) {
    const s = B2(t3);
    return s.Cr(), new Zr(e, s.nr, s.credentials, s.N, n);
  }(t2.datastore, t2.asyncQueue, {
    Si: Ro.bind(null, t2),
    Ci: vo.bind(null, t2),
    Vr: bo.bind(null, t2),
    vr: Po.bind(null, t2)
  }), t2.jr.push(async (e) => {
    e ? (t2.Hr.hr(), await po(t2)) : (await t2.Hr.stop(), t2.Ur.length > 0 && (x2("RemoteStore", `Stopping write stream with ${t2.Ur.length} pending writes`), t2.Ur = []));
  })), t2.Hr;
}
var Co = class {
  constructor(t2, e, n, s, i) {
    this.asyncQueue = t2, this.timerId = e, this.targetTimeMs = n, this.op = s, this.removalCallback = i, this.deferred = new K2(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch((t3) => {
    });
  }
  static createAndSchedule(t2, e, n, s, i) {
    const r = Date.now() + n, o = new Co(t2, e, r, s, i);
    return o.start(n), o;
  }
  start(t2) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t2);
  }
  skipDelay() {
    return this.handleDelayElapsed();
  }
  cancel(t2) {
    this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new q2(U2.CANCELLED, "Operation cancelled" + (t2 ? ": " + t2 : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then((t2) => this.deferred.resolve(t2))) : Promise.resolve());
  }
  clearTimeout() {
    this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
};
function No(t2, e) {
  if (k2("AsyncQueue", `${e}: ${t2}`), Gs(t2))
    return new q2(U2.UNAVAILABLE, `${e}: ${t2}`);
  throw t2;
}
var xo = class {
  constructor(t2) {
    this.comparator = t2 ? (e, n) => t2(e, n) || Rt.comparator(e.key, n.key) : (t3, e) => Rt.comparator(t3.key, e.key), this.keyedMap = En(), this.sortedSet = new fn(this.comparator);
  }
  static emptySet(t2) {
    return new xo(t2.comparator);
  }
  has(t2) {
    return this.keyedMap.get(t2) != null;
  }
  get(t2) {
    return this.keyedMap.get(t2);
  }
  first() {
    return this.sortedSet.minKey();
  }
  last() {
    return this.sortedSet.maxKey();
  }
  isEmpty() {
    return this.sortedSet.isEmpty();
  }
  indexOf(t2) {
    const e = this.keyedMap.get(t2);
    return e ? this.sortedSet.indexOf(e) : -1;
  }
  get size() {
    return this.sortedSet.size;
  }
  forEach(t2) {
    this.sortedSet.inorderTraversal((e, n) => (t2(e), false));
  }
  add(t2) {
    const e = this.delete(t2.key);
    return e.copy(e.keyedMap.insert(t2.key, t2), e.sortedSet.insert(t2, null));
  }
  delete(t2) {
    const e = this.get(t2);
    return e ? this.copy(this.keyedMap.remove(t2), this.sortedSet.remove(e)) : this;
  }
  isEqual(t2) {
    if (!(t2 instanceof xo))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.sortedSet.getIterator(), n = t2.sortedSet.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (!t3.isEqual(s))
        return false;
    }
    return true;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e.toString());
    }), t2.length === 0 ? "DocumentSet ()" : "DocumentSet (\n  " + t2.join("  \n") + "\n)";
  }
  copy(t2, e) {
    const n = new xo();
    return n.comparator = this.comparator, n.keyedMap = t2, n.sortedSet = e, n;
  }
};
var ko = class {
  constructor() {
    this.Jr = new fn(Rt.comparator);
  }
  track(t2) {
    const e = t2.doc.key, n = this.Jr.get(e);
    n ? t2.type !== 0 && n.type === 3 ? this.Jr = this.Jr.insert(e, t2) : t2.type === 3 && n.type !== 1 ? this.Jr = this.Jr.insert(e, {
      type: n.type,
      doc: t2.doc
    }) : t2.type === 2 && n.type === 2 ? this.Jr = this.Jr.insert(e, {
      type: 2,
      doc: t2.doc
    }) : t2.type === 2 && n.type === 0 ? this.Jr = this.Jr.insert(e, {
      type: 0,
      doc: t2.doc
    }) : t2.type === 1 && n.type === 0 ? this.Jr = this.Jr.remove(e) : t2.type === 1 && n.type === 2 ? this.Jr = this.Jr.insert(e, {
      type: 1,
      doc: n.doc
    }) : t2.type === 0 && n.type === 1 ? this.Jr = this.Jr.insert(e, {
      type: 2,
      doc: t2.doc
    }) : F2() : this.Jr = this.Jr.insert(e, t2);
  }
  Yr() {
    const t2 = [];
    return this.Jr.inorderTraversal((e, n) => {
      t2.push(n);
    }), t2;
  }
};
var $o = class {
  constructor(t2, e, n, s, i, r, o, a) {
    this.query = t2, this.docs = e, this.oldDocs = n, this.docChanges = s, this.mutatedKeys = i, this.fromCache = r, this.syncStateChanged = o, this.excludesMetadataChanges = a;
  }
  static fromInitialDocuments(t2, e, n, s) {
    const i = [];
    return e.forEach((t3) => {
      i.push({
        type: 0,
        doc: t3
      });
    }), new $o(t2, e, xo.emptySet(e), i, n, s, true, false);
  }
  get hasPendingWrites() {
    return !this.mutatedKeys.isEmpty();
  }
  isEqual(t2) {
    if (!(this.fromCache === t2.fromCache && this.syncStateChanged === t2.syncStateChanged && this.mutatedKeys.isEqual(t2.mutatedKeys) && Te(this.query, t2.query) && this.docs.isEqual(t2.docs) && this.oldDocs.isEqual(t2.oldDocs)))
      return false;
    const e = this.docChanges, n = t2.docChanges;
    if (e.length !== n.length)
      return false;
    for (let t3 = 0; t3 < e.length; t3++)
      if (e[t3].type !== n[t3].type || !e[t3].doc.isEqual(n[t3].doc))
        return false;
    return true;
  }
};
var Oo = class {
  constructor() {
    this.Xr = void 0, this.listeners = [];
  }
};
var Fo = class {
  constructor() {
    this.queries = new qi((t2) => Ie(t2), Te), this.onlineState = "Unknown", this.Zr = new Set();
  }
};
async function Mo(t2, e) {
  const n = B2(t2), s = e.query;
  let i = false, r = n.queries.get(s);
  if (r || (i = true, r = new Oo()), i)
    try {
      r.Xr = await n.onListen(s);
    } catch (t3) {
      const n2 = No(t3, `Initialization of query '${Ae(e.query)}' failed`);
      return void e.onError(n2);
    }
  if (n.queries.set(s, r), r.listeners.push(e), e.eo(n.onlineState), r.Xr) {
    e.no(r.Xr) && qo(n);
  }
}
async function Lo(t2, e) {
  const n = B2(t2), s = e.query;
  let i = false;
  const r = n.queries.get(s);
  if (r) {
    const t3 = r.listeners.indexOf(e);
    t3 >= 0 && (r.listeners.splice(t3, 1), i = r.listeners.length === 0);
  }
  if (i)
    return n.queries.delete(s), n.onUnlisten(s);
}
function Bo(t2, e) {
  const n = B2(t2);
  let s = false;
  for (const t3 of e) {
    const e2 = t3.query, i = n.queries.get(e2);
    if (i) {
      for (const e3 of i.listeners)
        e3.no(t3) && (s = true);
      i.Xr = t3;
    }
  }
  s && qo(n);
}
function Uo(t2, e, n) {
  const s = B2(t2), i = s.queries.get(e);
  if (i)
    for (const t3 of i.listeners)
      t3.onError(n);
  s.queries.delete(e);
}
function qo(t2) {
  t2.Zr.forEach((t3) => {
    t3.next();
  });
}
var Ko = class {
  constructor(t2, e, n) {
    this.query = t2, this.so = e, this.io = false, this.ro = null, this.onlineState = "Unknown", this.options = n || {};
  }
  no(t2) {
    if (!this.options.includeMetadataChanges) {
      const e2 = [];
      for (const n of t2.docChanges)
        n.type !== 3 && e2.push(n);
      t2 = new $o(t2.query, t2.docs, t2.oldDocs, e2, t2.mutatedKeys, t2.fromCache, t2.syncStateChanged, true);
    }
    let e = false;
    return this.io ? this.oo(t2) && (this.so.next(t2), e = true) : this.ao(t2, this.onlineState) && (this.co(t2), e = true), this.ro = t2, e;
  }
  onError(t2) {
    this.so.error(t2);
  }
  eo(t2) {
    this.onlineState = t2;
    let e = false;
    return this.ro && !this.io && this.ao(this.ro, t2) && (this.co(this.ro), e = true), e;
  }
  ao(t2, e) {
    if (!t2.fromCache)
      return true;
    const n = e !== "Offline";
    return (!this.options.uo || !n) && (!t2.docs.isEmpty() || e === "Offline");
  }
  oo(t2) {
    if (t2.docChanges.length > 0)
      return true;
    const e = this.ro && this.ro.hasPendingWrites !== t2.hasPendingWrites;
    return !(!t2.syncStateChanged && !e) && this.options.includeMetadataChanges === true;
  }
  co(t2) {
    t2 = $o.fromInitialDocuments(t2.query, t2.docs, t2.mutatedKeys, t2.fromCache), this.io = true, this.so.next(t2);
  }
};
var jo = class {
  constructor(t2, e) {
    this.payload = t2, this.byteLength = e;
  }
  ho() {
    return "metadata" in this.payload;
  }
};
var Qo = class {
  constructor(t2) {
    this.N = t2;
  }
  zn(t2) {
    return Wn(this.N, t2);
  }
  Hn(t2) {
    return t2.metadata.exists ? Xn(this.N, t2.document, false) : Ut.newNoDocument(this.zn(t2.metadata.name), this.Jn(t2.metadata.readTime));
  }
  Jn(t2) {
    return qn(t2);
  }
};
var Wo = class {
  constructor(t2, e, n) {
    this.lo = t2, this.localStore = e, this.N = n, this.queries = [], this.documents = [], this.progress = Go(t2);
  }
  fo(t2) {
    this.progress.bytesLoaded += t2.byteLength;
    let e = this.progress.documentsLoaded;
    return t2.payload.namedQuery ? this.queries.push(t2.payload.namedQuery) : t2.payload.documentMetadata ? (this.documents.push({
      metadata: t2.payload.documentMetadata
    }), t2.payload.documentMetadata.exists || ++e) : t2.payload.document && (this.documents[this.documents.length - 1].document = t2.payload.document, ++e), e !== this.progress.documentsLoaded ? (this.progress.documentsLoaded = e, Object.assign({}, this.progress)) : null;
  }
  wo(t2) {
    const e = new Map(), n = new Qo(this.N);
    for (const s of t2)
      if (s.metadata.queries) {
        const t3 = n.zn(s.metadata.name);
        for (const n2 of s.metadata.queries) {
          const s2 = (e.get(n2) || Rn()).add(t3);
          e.set(n2, s2);
        }
      }
    return e;
  }
  async complete() {
    const t2 = await Er(this.localStore, new Qo(this.N), this.documents, this.lo.id), e = this.wo(this.documents);
    for (const t3 of this.queries)
      await Tr(this.localStore, t3, e.get(t3.name));
    return this.progress.taskState = "Success", new nr(Object.assign({}, this.progress), t2);
  }
};
function Go(t2) {
  return {
    taskState: "Running",
    documentsLoaded: 0,
    bytesLoaded: 0,
    totalDocuments: t2.totalDocuments,
    totalBytes: t2.totalBytes
  };
}
var zo = class {
  constructor(t2) {
    this.key = t2;
  }
};
var Ho = class {
  constructor(t2) {
    this.key = t2;
  }
};
var Jo = class {
  constructor(t2, e) {
    this.query = t2, this._o = e, this.mo = null, this.current = false, this.yo = Rn(), this.mutatedKeys = Rn(), this.po = be(t2), this.Eo = new xo(this.po);
  }
  get To() {
    return this._o;
  }
  Io(t2, e) {
    const n = e ? e.Ao : new ko(), s = e ? e.Eo : this.Eo;
    let i = e ? e.mutatedKeys : this.mutatedKeys, r = s, o = false;
    const a = de(this.query) && s.size === this.query.limit ? s.last() : null, c = we(this.query) && s.size === this.query.limit ? s.first() : null;
    if (t2.inorderTraversal((t3, e2) => {
      const u = s.get(t3), h = Re(this.query, e2) ? e2 : null, l2 = !!u && this.mutatedKeys.has(u.key), f = !!h && (h.hasLocalMutations || this.mutatedKeys.has(h.key) && h.hasCommittedMutations);
      let d = false;
      if (u && h) {
        u.data.isEqual(h.data) ? l2 !== f && (n.track({
          type: 3,
          doc: h
        }), d = true) : this.Ro(u, h) || (n.track({
          type: 2,
          doc: h
        }), d = true, (a && this.po(h, a) > 0 || c && this.po(h, c) < 0) && (o = true));
      } else
        !u && h ? (n.track({
          type: 0,
          doc: h
        }), d = true) : u && !h && (n.track({
          type: 1,
          doc: u
        }), d = true, (a || c) && (o = true));
      d && (h ? (r = r.add(h), i = f ? i.add(t3) : i.delete(t3)) : (r = r.delete(t3), i = i.delete(t3)));
    }), de(this.query) || we(this.query))
      for (; r.size > this.query.limit; ) {
        const t3 = de(this.query) ? r.last() : r.first();
        r = r.delete(t3.key), i = i.delete(t3.key), n.track({
          type: 1,
          doc: t3
        });
      }
    return {
      Eo: r,
      Ao: n,
      Ln: o,
      mutatedKeys: i
    };
  }
  Ro(t2, e) {
    return t2.hasLocalMutations && e.hasCommittedMutations && !e.hasLocalMutations;
  }
  applyChanges(t2, e, n) {
    const s = this.Eo;
    this.Eo = t2.Eo, this.mutatedKeys = t2.mutatedKeys;
    const i = t2.Ao.Yr();
    i.sort((t3, e2) => function(t4, e3) {
      const n2 = (t5) => {
        switch (t5) {
          case 0:
            return 1;
          case 2:
          case 3:
            return 2;
          case 1:
            return 0;
          default:
            return F2();
        }
      };
      return n2(t4) - n2(e3);
    }(t3.type, e2.type) || this.po(t3.doc, e2.doc)), this.bo(n);
    const r = e ? this.Po() : [], o = this.yo.size === 0 && this.current ? 1 : 0, a = o !== this.mo;
    if (this.mo = o, i.length !== 0 || a) {
      return {
        snapshot: new $o(this.query, t2.Eo, s, i, t2.mutatedKeys, o === 0, a, false),
        vo: r
      };
    }
    return {
      vo: r
    };
  }
  eo(t2) {
    return this.current && t2 === "Offline" ? (this.current = false, this.applyChanges({
      Eo: this.Eo,
      Ao: new ko(),
      mutatedKeys: this.mutatedKeys,
      Ln: false
    }, false)) : {
      vo: []
    };
  }
  Vo(t2) {
    return !this._o.has(t2) && (!!this.Eo.has(t2) && !this.Eo.get(t2).hasLocalMutations);
  }
  bo(t2) {
    t2 && (t2.addedDocuments.forEach((t3) => this._o = this._o.add(t3)), t2.modifiedDocuments.forEach((t3) => {
    }), t2.removedDocuments.forEach((t3) => this._o = this._o.delete(t3)), this.current = t2.current);
  }
  Po() {
    if (!this.current)
      return [];
    const t2 = this.yo;
    this.yo = Rn(), this.Eo.forEach((t3) => {
      this.Vo(t3.key) && (this.yo = this.yo.add(t3.key));
    });
    const e = [];
    return t2.forEach((t3) => {
      this.yo.has(t3) || e.push(new Ho(t3));
    }), this.yo.forEach((n) => {
      t2.has(n) || e.push(new zo(n));
    }), e;
  }
  So(t2) {
    this._o = t2.Gn, this.yo = Rn();
    const e = this.Io(t2.documents);
    return this.applyChanges(e, true);
  }
  Do() {
    return $o.fromInitialDocuments(this.query, this.Eo, this.mutatedKeys, this.mo === 0);
  }
};
var Yo = class {
  constructor(t2, e, n) {
    this.query = t2, this.targetId = e, this.view = n;
  }
};
var Xo = class {
  constructor(t2) {
    this.key = t2, this.Co = false;
  }
};
var Zo = class {
  constructor(t2, e, n, s, i, r) {
    this.localStore = t2, this.remoteStore = e, this.eventManager = n, this.sharedClientState = s, this.currentUser = i, this.maxConcurrentLimboResolutions = r, this.No = {}, this.xo = new qi((t3) => Ie(t3), Te), this.ko = new Map(), this.$o = new Set(), this.Oo = new fn(Rt.comparator), this.Fo = new Map(), this.Mo = new Ar(), this.Lo = {}, this.Bo = new Map(), this.Uo = Di.ie(), this.onlineState = "Unknown", this.qo = void 0;
  }
  get isPrimaryClient() {
    return this.qo === true;
  }
};
async function ta2(t2, e) {
  const n = Sa2(t2);
  let s, i;
  const r = n.xo.get(e);
  if (r)
    s = r.targetId, n.sharedClientState.addLocalQueryTarget(s), i = r.view.Do();
  else {
    const t3 = await wr(n.localStore, pe(e)), r2 = n.sharedClientState.addLocalQueryTarget(t3.targetId);
    s = t3.targetId, i = await ea2(n, e, s, r2 === "current"), n.isPrimaryClient && ro(n.remoteStore, t3);
  }
  return i;
}
async function ea2(t2, e, n, s) {
  t2.Ko = (e2, n2, s2) => async function(t3, e3, n3, s3) {
    let i2 = e3.view.Io(n3);
    i2.Ln && (i2 = await mr(t3.localStore, e3.query, false).then(({ documents: t4 }) => e3.view.Io(t4, i2)));
    const r2 = s3 && s3.targetChanges.get(e3.targetId), o2 = e3.view.applyChanges(i2, t3.isPrimaryClient, r2);
    return wa(t3, e3.targetId, o2.vo), o2.snapshot;
  }(t2, e2, n2, s2);
  const i = await mr(t2.localStore, e, true), r = new Jo(e, i.Gn), o = r.Io(i.documents), a = Vn.createSynthesizedTargetChangeForCurrentChange(n, s && t2.onlineState !== "Offline"), c = r.applyChanges(o, t2.isPrimaryClient, a);
  wa(t2, n, c.vo);
  const u = new Yo(e, n, r);
  return t2.xo.set(e, u), t2.ko.has(n) ? t2.ko.get(n).push(e) : t2.ko.set(n, [e]), c.snapshot;
}
async function na2(t2, e) {
  const n = B2(t2), s = n.xo.get(e), i = n.ko.get(s.targetId);
  if (i.length > 1)
    return n.ko.set(s.targetId, i.filter((t3) => !Te(t3, e))), void n.xo.delete(e);
  if (n.isPrimaryClient) {
    n.sharedClientState.removeLocalQueryTarget(s.targetId);
    n.sharedClientState.isActiveQueryTarget(s.targetId) || await _r(n.localStore, s.targetId, false).then(() => {
      n.sharedClientState.clearQueryState(s.targetId), oo(n.remoteStore, s.targetId), fa2(n, s.targetId);
    }).catch($i);
  } else
    fa2(n, s.targetId), await _r(n.localStore, s.targetId, true);
}
async function sa2(t2, e, n) {
  const s = Da(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = B2(t4), s2 = nt.now(), i = e2.reduce((t5, e3) => t5.add(e3.key), Rn());
      let r;
      return n2.persistence.runTransaction("Locally write mutations", "readwrite", (t5) => n2.Qn.Pn(t5, i).next((i2) => {
        r = i2;
        const o = [];
        for (const t6 of e2) {
          const e3 = Je(t6, r.get(t6.key));
          e3 != null && o.push(new tn(t6.key, e3, Bt(e3.value.mapValue), Qe.exists(true)));
        }
        return n2.In.addMutationBatch(t5, s2, o, e2);
      })).then((t5) => (t5.applyToLocalDocumentSet(r), {
        batchId: t5.batchId,
        changes: r
      }));
    }(s.localStore, e);
    s.sharedClientState.addPendingMutation(t3.batchId), function(t4, e2, n2) {
      let s2 = t4.Lo[t4.currentUser.toKey()];
      s2 || (s2 = new fn(Z2));
      s2 = s2.insert(e2, n2), t4.Lo[t4.currentUser.toKey()] = s2;
    }(s, t3.batchId, n), await ga(s, t3.changes), await po(s.remoteStore);
  } catch (t3) {
    const e2 = No(t3, "Failed to persist write");
    n.reject(e2);
  }
}
async function ia2(t2, e) {
  const n = B2(t2);
  try {
    const t3 = await lr(n.localStore, e);
    e.targetChanges.forEach((t4, e2) => {
      const s = n.Fo.get(e2);
      s && (M2(t4.addedDocuments.size + t4.modifiedDocuments.size + t4.removedDocuments.size <= 1), t4.addedDocuments.size > 0 ? s.Co = true : t4.modifiedDocuments.size > 0 ? M2(s.Co) : t4.removedDocuments.size > 0 && (M2(s.Co), s.Co = false));
    }), await ga(n, t3, e);
  } catch (t3) {
    await $i(t3);
  }
}
function ra2(t2, e, n) {
  const s = B2(t2);
  if (s.isPrimaryClient && n === 0 || !s.isPrimaryClient && n === 1) {
    const t3 = [];
    s.xo.forEach((n2, s2) => {
      const i = s2.view.eo(e);
      i.snapshot && t3.push(i.snapshot);
    }), function(t4, e2) {
      const n2 = B2(t4);
      n2.onlineState = e2;
      let s2 = false;
      n2.queries.forEach((t5, n3) => {
        for (const t6 of n3.listeners)
          t6.eo(e2) && (s2 = true);
      }), s2 && qo(n2);
    }(s.eventManager, e), t3.length && s.No.Tr(t3), s.onlineState = e, s.isPrimaryClient && s.sharedClientState.setOnlineState(e);
  }
}
async function oa2(t2, e, n) {
  const s = B2(t2);
  s.sharedClientState.updateQueryState(e, "rejected", n);
  const i = s.Fo.get(e), r = i && i.key;
  if (r) {
    let t3 = new fn(Rt.comparator);
    t3 = t3.insert(r, Ut.newNoDocument(r, st.min()));
    const n2 = Rn().add(r), i2 = new vn(st.min(), new Map(), new _n(Z2), t3, n2);
    await ia2(s, i2), s.Oo = s.Oo.remove(r), s.Fo.delete(e), ma2(s);
  } else
    await _r(s.localStore, e, false).then(() => fa2(s, e, n)).catch($i);
}
async function aa2(t2, e) {
  const n = B2(t2), s = e.batch.batchId;
  try {
    const t3 = await ur(n.localStore, e);
    la2(n, s, null), ha2(n, s), n.sharedClientState.updateMutationState(s, "acknowledged"), await ga(n, t3);
  } catch (t3) {
    await $i(t3);
  }
}
async function ca(t2, e, n) {
  const s = B2(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = B2(t4);
      return n2.persistence.runTransaction("Reject batch", "readwrite-primary", (t5) => {
        let s2;
        return n2.In.lookupMutationBatch(t5, e2).next((e3) => (M2(e3 !== null), s2 = e3.keys(), n2.In.removeMutationBatch(t5, e3))).next(() => n2.In.performConsistencyCheck(t5)).next(() => n2.Qn.Pn(t5, s2));
      });
    }(s.localStore, e);
    la2(s, e, n), ha2(s, e), s.sharedClientState.updateMutationState(e, "rejected", n), await ga(s, t3);
  } catch (n2) {
    await $i(n2);
  }
}
async function ua2(t2, e) {
  const n = B2(t2);
  lo(n.remoteStore) || x2("SyncEngine", "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled.");
  try {
    const t3 = await function(t4) {
      const e2 = B2(t4);
      return e2.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", (t5) => e2.In.getHighestUnacknowledgedBatchId(t5));
    }(n.localStore);
    if (t3 === -1)
      return void e.resolve();
    const s = n.Bo.get(t3) || [];
    s.push(e), n.Bo.set(t3, s);
  } catch (t3) {
    const n2 = No(t3, "Initialization of waitForPendingWrites() operation failed");
    e.reject(n2);
  }
}
function ha2(t2, e) {
  (t2.Bo.get(e) || []).forEach((t3) => {
    t3.resolve();
  }), t2.Bo.delete(e);
}
function la2(t2, e, n) {
  const s = B2(t2);
  let i = s.Lo[s.currentUser.toKey()];
  if (i) {
    const t3 = i.get(e);
    t3 && (n ? t3.reject(n) : t3.resolve(), i = i.remove(e)), s.Lo[s.currentUser.toKey()] = i;
  }
}
function fa2(t2, e, n = null) {
  t2.sharedClientState.removeLocalQueryTarget(e);
  for (const s of t2.ko.get(e))
    t2.xo.delete(s), n && t2.No.jo(s, n);
  if (t2.ko.delete(e), t2.isPrimaryClient) {
    t2.Mo.cs(e).forEach((e2) => {
      t2.Mo.containsKey(e2) || da2(t2, e2);
    });
  }
}
function da2(t2, e) {
  t2.$o.delete(e.path.canonicalString());
  const n = t2.Oo.get(e);
  n !== null && (oo(t2.remoteStore, n), t2.Oo = t2.Oo.remove(e), t2.Fo.delete(n), ma2(t2));
}
function wa(t2, e, n) {
  for (const s of n)
    if (s instanceof zo)
      t2.Mo.addReference(s.key, e), _a(t2, s);
    else if (s instanceof Ho) {
      x2("SyncEngine", "Document no longer in limbo: " + s.key), t2.Mo.removeReference(s.key, e);
      t2.Mo.containsKey(s.key) || da2(t2, s.key);
    } else
      F2();
}
function _a(t2, e) {
  const n = e.key, s = n.path.canonicalString();
  t2.Oo.get(n) || t2.$o.has(s) || (x2("SyncEngine", "New document in limbo: " + n), t2.$o.add(s), ma2(t2));
}
function ma2(t2) {
  for (; t2.$o.size > 0 && t2.Oo.size < t2.maxConcurrentLimboResolutions; ) {
    const e = t2.$o.values().next().value;
    t2.$o.delete(e);
    const n = new Rt(ct.fromString(e)), s = t2.Uo.next();
    t2.Fo.set(s, new Xo(n)), t2.Oo = t2.Oo.insert(n, s), ro(t2.remoteStore, new ni(pe(fe(n.path)), s, 2, J2.T));
  }
}
async function ga(t2, e, n) {
  const s = B2(t2), i = [], r = [], o = [];
  s.xo.isEmpty() || (s.xo.forEach((t3, a) => {
    o.push(s.Ko(a, e, n).then((t4) => {
      if (t4) {
        s.isPrimaryClient && s.sharedClientState.updateQueryState(a.targetId, t4.fromCache ? "not-current" : "current"), i.push(t4);
        const e2 = ir.kn(a.targetId, t4);
        r.push(e2);
      }
    }));
  }), await Promise.all(o), s.No.Tr(i), await async function(t3, e2) {
    const n2 = B2(t3);
    try {
      await n2.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (t4) => qs.forEach(e2, (e3) => qs.forEach(e3.Nn, (s2) => n2.persistence.referenceDelegate.addReference(t4, e3.targetId, s2)).next(() => qs.forEach(e3.xn, (s2) => n2.persistence.referenceDelegate.removeReference(t4, e3.targetId, s2)))));
    } catch (t4) {
      if (!Gs(t4))
        throw t4;
      x2("LocalStore", "Failed to update sequence numbers: " + t4);
    }
    for (const t4 of e2) {
      const e3 = t4.targetId;
      if (!t4.fromCache) {
        const t5 = n2.Un.get(e3), s2 = t5.snapshotVersion, i2 = t5.withLastLimboFreeSnapshotVersion(s2);
        n2.Un = n2.Un.insert(e3, i2);
      }
    }
  }(s.localStore, r));
}
async function ya2(t2, e) {
  const n = B2(t2);
  if (!n.currentUser.isEqual(e)) {
    x2("SyncEngine", "User change. New user:", e.toKey());
    const t3 = await cr(n.localStore, e);
    n.currentUser = e, function(t4, e2) {
      t4.Bo.forEach((t5) => {
        t5.forEach((t6) => {
          t6.reject(new q2(U2.CANCELLED, e2));
        });
      }), t4.Bo.clear();
    }(n, "'waitForPendingWrites' promise is rejected due to a user change."), n.sharedClientState.handleUserChange(e, t3.removedBatchIds, t3.addedBatchIds), await ga(n, t3.Wn);
  }
}
function pa2(t2, e) {
  const n = B2(t2), s = n.Fo.get(e);
  if (s && s.Co)
    return Rn().add(s.key);
  {
    let t3 = Rn();
    const s2 = n.ko.get(e);
    if (!s2)
      return t3;
    for (const e2 of s2) {
      const s3 = n.xo.get(e2);
      t3 = t3.unionWith(s3.view.To);
    }
    return t3;
  }
}
async function Ea(t2, e) {
  const n = B2(t2), s = await mr(n.localStore, e.query, true), i = e.view.So(s);
  return n.isPrimaryClient && wa(n, e.targetId, i.vo), i;
}
async function Ta(t2) {
  const e = B2(t2);
  return yr(e.localStore).then((t3) => ga(e, t3));
}
async function Ia2(t2, e, n, s) {
  const i = B2(t2), r = await function(t3, e2) {
    const n2 = B2(t3), s2 = B2(n2.In);
    return n2.persistence.runTransaction("Lookup mutation documents", "readonly", (t4) => s2.Xt(t4, e2).next((e3) => e3 ? n2.Qn.Pn(t4, e3) : qs.resolve(null)));
  }(i.localStore, e);
  r !== null ? (n === "pending" ? await po(i.remoteStore) : n === "acknowledged" || n === "rejected" ? (la2(i, e, s || null), ha2(i, e), function(t3, e2) {
    B2(B2(t3).In).te(e2);
  }(i.localStore, e)) : F2(), await ga(i, r)) : x2("SyncEngine", "Cannot apply mutation batch with id: " + e);
}
async function Aa2(t2, e) {
  const n = B2(t2);
  if (Sa2(n), Da(n), e === true && n.qo !== true) {
    const t3 = n.sharedClientState.getAllActiveQueryTargets(), e2 = await Ra2(n, t3.toArray());
    n.qo = true, await Vo(n.remoteStore, true);
    for (const t4 of e2)
      ro(n.remoteStore, t4);
  } else if (e === false && n.qo !== false) {
    const t3 = [];
    let e2 = Promise.resolve();
    n.ko.forEach((s, i) => {
      n.sharedClientState.isLocalQueryTarget(i) ? t3.push(i) : e2 = e2.then(() => (fa2(n, i), _r(n.localStore, i, true))), oo(n.remoteStore, i);
    }), await e2, await Ra2(n, t3), function(t4) {
      const e3 = B2(t4);
      e3.Fo.forEach((t5, n2) => {
        oo(e3.remoteStore, n2);
      }), e3.Mo.us(), e3.Fo = new Map(), e3.Oo = new fn(Rt.comparator);
    }(n), n.qo = false, await Vo(n.remoteStore, false);
  }
}
async function Ra2(t2, e, n) {
  const s = B2(t2), i = [], r = [];
  for (const t3 of e) {
    let e2;
    const n2 = s.ko.get(t3);
    if (n2 && n2.length !== 0) {
      e2 = await wr(s.localStore, pe(n2[0]));
      for (const t4 of n2) {
        const e3 = s.xo.get(t4), n3 = await Ea(s, e3);
        n3.snapshot && r.push(n3.snapshot);
      }
    } else {
      const n3 = await gr(s.localStore, t3);
      e2 = await wr(s.localStore, n3), await ea2(s, ba2(n3), t3, false);
    }
    i.push(e2);
  }
  return s.No.Tr(r), i;
}
function ba2(t2) {
  return le(t2.path, t2.collectionGroup, t2.orderBy, t2.filters, t2.limit, "F", t2.startAt, t2.endAt);
}
function Pa(t2) {
  const e = B2(t2);
  return B2(B2(e.localStore).persistence).pn();
}
async function va(t2, e, n, s) {
  const i = B2(t2);
  if (i.qo)
    x2("SyncEngine", "Ignoring unexpected query state notification.");
  else if (i.ko.has(e))
    switch (n) {
      case "current":
      case "not-current": {
        const t3 = await yr(i.localStore), s2 = vn.createSynthesizedRemoteEventForCurrentChange(e, n === "current");
        await ga(i, t3, s2);
        break;
      }
      case "rejected":
        await _r(i.localStore, e, true), fa2(i, e, s);
        break;
      default:
        F2();
    }
}
async function Va2(t2, e, n) {
  const s = Sa2(t2);
  if (s.qo) {
    for (const t3 of e) {
      if (s.ko.has(t3)) {
        x2("SyncEngine", "Adding an already active target " + t3);
        continue;
      }
      const e2 = await gr(s.localStore, t3), n2 = await wr(s.localStore, e2);
      await ea2(s, ba2(e2), n2.targetId, false), ro(s.remoteStore, n2);
    }
    for (const t3 of n)
      s.ko.has(t3) && await _r(s.localStore, t3, false).then(() => {
        oo(s.remoteStore, t3), fa2(s, t3);
      }).catch($i);
  }
}
function Sa2(t2) {
  const e = B2(t2);
  return e.remoteStore.remoteSyncer.applyRemoteEvent = ia2.bind(null, e), e.remoteStore.remoteSyncer.getRemoteKeysForTarget = pa2.bind(null, e), e.remoteStore.remoteSyncer.rejectListen = oa2.bind(null, e), e.No.Tr = Bo.bind(null, e.eventManager), e.No.jo = Uo.bind(null, e.eventManager), e;
}
function Da(t2) {
  const e = B2(t2);
  return e.remoteStore.remoteSyncer.applySuccessfulWrite = aa2.bind(null, e), e.remoteStore.remoteSyncer.rejectFailedWrite = ca.bind(null, e), e;
}
function Ca2(t2, e, n) {
  const s = B2(t2);
  (async function(t3, e2, n2) {
    try {
      const s2 = await e2.getMetadata();
      if (await function(t4, e3) {
        const n3 = B2(t4), s3 = qn(e3.createTime);
        return n3.persistence.runTransaction("hasNewerBundle", "readonly", (t5) => n3.Je.getBundleMetadata(t5, e3.id)).then((t5) => !!t5 && t5.createTime.compareTo(s3) >= 0);
      }(t3.localStore, s2))
        return await e2.close(), void n2._completeWith(function(t4) {
          return {
            taskState: "Success",
            documentsLoaded: t4.totalDocuments,
            bytesLoaded: t4.totalBytes,
            totalDocuments: t4.totalDocuments,
            totalBytes: t4.totalBytes
          };
        }(s2));
      n2._updateProgress(Go(s2));
      const i = new Wo(s2, t3.localStore, e2.N);
      let r = await e2.Qo();
      for (; r; ) {
        const t4 = await i.fo(r);
        t4 && n2._updateProgress(t4), r = await e2.Qo();
      }
      const o = await i.complete();
      await ga(t3, o.Tn, void 0), await function(t4, e3) {
        const n3 = B2(t4);
        return n3.persistence.runTransaction("Save bundle", "readwrite", (t5) => n3.Je.saveBundleMetadata(t5, e3));
      }(t3.localStore, s2), n2._completeWith(o.progress);
    } catch (t4) {
      $("SyncEngine", `Loading bundle failed with ${t4}`), n2._failWith(t4);
    }
  })(s, e, n).then(() => {
    s.sharedClientState.notifyBundleLoaded();
  });
}
var Na2 = class {
  constructor() {
    this.synchronizeTabs = false;
  }
  async initialize(t2) {
    this.N = Hr(t2.databaseInfo.databaseId), this.sharedClientState = this.Wo(t2), this.persistence = this.Go(t2), await this.persistence.start(), this.gcScheduler = this.zo(t2), this.localStore = this.Ho(t2);
  }
  zo(t2) {
    return null;
  }
  Ho(t2) {
    return ar(this.persistence, new rr(), t2.initialUser, this.N);
  }
  Go(t2) {
    return new Sr(Cr.Ns, this.N);
  }
  Wo(t2) {
    return new Ur();
  }
  async terminate() {
    this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown();
  }
};
var xa2 = class extends Na2 {
  constructor(t2, e, n) {
    super(), this.Jo = t2, this.cacheSizeBytes = e, this.forceOwnership = n, this.synchronizeTabs = false;
  }
  async initialize(t2) {
    await super.initialize(t2), await pr(this.localStore), await this.Jo.initialize(this, t2), await Da(this.Jo.syncEngine), await po(this.Jo.remoteStore), await this.persistence.nn(() => (this.gcScheduler && !this.gcScheduler.started && this.gcScheduler.start(this.localStore), Promise.resolve()));
  }
  Ho(t2) {
    return ar(this.persistence, new rr(), t2.initialUser, this.N);
  }
  zo(t2) {
    const e = this.persistence.referenceDelegate.garbageCollector;
    return new Mi(e, t2.asyncQueue);
  }
  Go(t2) {
    const e = er(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey), n = this.cacheSizeBytes !== void 0 ? Ii.withCacheSize(this.cacheSizeBytes) : Ii.DEFAULT;
    return new Xi(this.synchronizeTabs, e, t2.clientId, n, t2.asyncQueue, Gr(), zr(), this.N, this.sharedClientState, !!this.forceOwnership);
  }
  Wo(t2) {
    return new Ur();
  }
};
var ka2 = class extends xa2 {
  constructor(t2, e) {
    super(t2, e, false), this.Jo = t2, this.cacheSizeBytes = e, this.synchronizeTabs = true;
  }
  async initialize(t2) {
    await super.initialize(t2);
    const e = this.Jo.syncEngine;
    this.sharedClientState instanceof Br && (this.sharedClientState.syncEngine = {
      _i: Ia2.bind(null, e),
      mi: va.bind(null, e),
      gi: Va2.bind(null, e),
      pn: Pa.bind(null, e),
      wi: Ta.bind(null, e)
    }, await this.sharedClientState.start()), await this.persistence.nn(async (t3) => {
      await Aa2(this.Jo.syncEngine, t3), this.gcScheduler && (t3 && !this.gcScheduler.started ? this.gcScheduler.start(this.localStore) : t3 || this.gcScheduler.stop());
    });
  }
  Wo(t2) {
    const e = Gr();
    if (!Br.bt(e))
      throw new q2(U2.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage.");
    const n = er(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey);
    return new Br(e, t2.asyncQueue, n, t2.clientId, t2.initialUser);
  }
};
var $a2 = class {
  async initialize(t2, e) {
    this.localStore || (this.localStore = t2.localStore, this.sharedClientState = t2.sharedClientState, this.datastore = this.createDatastore(e), this.remoteStore = this.createRemoteStore(e), this.eventManager = this.createEventManager(e), this.syncEngine = this.createSyncEngine(e, !t2.synchronizeTabs), this.sharedClientState.onlineStateHandler = (t3) => ra2(this.syncEngine, t3, 1), this.remoteStore.remoteSyncer.handleCredentialChange = ya2.bind(null, this.syncEngine), await Vo(this.remoteStore, this.syncEngine.isPrimaryClient));
  }
  createEventManager(t2) {
    return new Fo();
  }
  createDatastore(t2) {
    const e = Hr(t2.databaseInfo.databaseId), n = (s = t2.databaseInfo, new Wr(s));
    var s;
    return function(t3, e2, n2) {
      return new to(t3, e2, n2);
    }(t2.credentials, n, e);
  }
  createRemoteStore(t2) {
    return e = this.localStore, n = this.datastore, s = t2.asyncQueue, i = (t3) => ra2(this.syncEngine, t3, 0), r = Kr.bt() ? new Kr() : new qr(), new no(e, n, s, i, r);
    var e, n, s, i, r;
  }
  createSyncEngine(t2, e) {
    return function(t3, e2, n, s, i, r, o) {
      const a = new Zo(t3, e2, n, s, i, r);
      return o && (a.qo = true), a;
    }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, t2.initialUser, t2.maxConcurrentLimboResolutions, e);
  }
  terminate() {
    return async function(t2) {
      const e = B2(t2);
      x2("RemoteStore", "RemoteStore shutting down."), e.Kr.add(5), await io(e), e.Qr.shutdown(), e.Wr.set("Unknown");
    }(this.remoteStore);
  }
};
function Oa(t2, e = 10240) {
  let n = 0;
  return {
    async read() {
      if (n < t2.byteLength) {
        const s = {
          value: t2.slice(n, n + e),
          done: false
        };
        return n += e, s;
      }
      return {
        done: true
      };
    },
    async cancel() {
    },
    releaseLock() {
    },
    closed: Promise.reject("unimplemented")
  };
}
var Fa2 = class {
  constructor(t2) {
    this.observer = t2, this.muted = false;
  }
  next(t2) {
    this.observer.next && this.Yo(this.observer.next, t2);
  }
  error(t2) {
    this.observer.error ? this.Yo(this.observer.error, t2) : console.error("Uncaught Error in snapshot listener:", t2);
  }
  Xo() {
    this.muted = true;
  }
  Yo(t2, e) {
    this.muted || setTimeout(() => {
      this.muted || t2(e);
    }, 0);
  }
};
var Ma2 = class {
  constructor(t2, e) {
    this.Zo = t2, this.N = e, this.metadata = new K2(), this.buffer = new Uint8Array(), this.ta = new TextDecoder("utf-8"), this.ea().then((t3) => {
      t3 && t3.ho() ? this.metadata.resolve(t3.payload.metadata) : this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is
             ${JSON.stringify(t3 == null ? void 0 : t3.payload)}`));
    }, (t3) => this.metadata.reject(t3));
  }
  close() {
    return this.Zo.cancel();
  }
  async getMetadata() {
    return this.metadata.promise;
  }
  async Qo() {
    return await this.getMetadata(), this.ea();
  }
  async ea() {
    const t2 = await this.na();
    if (t2 === null)
      return null;
    const e = this.ta.decode(t2), n = Number(e);
    isNaN(n) && this.sa(`length string (${e}) is not valid number`);
    const s = await this.ia(n);
    return new jo(JSON.parse(s), t2.length + n);
  }
  ra() {
    return this.buffer.findIndex((t2) => t2 === "{".charCodeAt(0));
  }
  async na() {
    for (; this.ra() < 0; ) {
      if (await this.oa())
        break;
    }
    if (this.buffer.length === 0)
      return null;
    const t2 = this.ra();
    t2 < 0 && this.sa("Reached the end of bundle when a length string is expected.");
    const e = this.buffer.slice(0, t2);
    return this.buffer = this.buffer.slice(t2), e;
  }
  async ia(t2) {
    for (; this.buffer.length < t2; ) {
      await this.oa() && this.sa("Reached the end of bundle when more is expected.");
    }
    const e = this.ta.decode(this.buffer.slice(0, t2));
    return this.buffer = this.buffer.slice(t2), e;
  }
  sa(t2) {
    throw this.Zo.cancel(), new Error(`Invalid bundle format: ${t2}`);
  }
  async oa() {
    const t2 = await this.Zo.read();
    if (!t2.done) {
      const e = new Uint8Array(this.buffer.length + t2.value.length);
      e.set(this.buffer), e.set(t2.value, this.buffer.length), this.buffer = e;
    }
    return t2.done;
  }
};
var La2 = class {
  constructor(t2) {
    this.datastore = t2, this.readVersions = new Map(), this.mutations = [], this.committed = false, this.lastWriteError = null, this.writtenDocs = new Set();
  }
  async lookup(t2) {
    if (this.ensureCommitNotCalled(), this.mutations.length > 0)
      throw new q2(U2.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes.");
    const e = await async function(t3, e2) {
      const n = B2(t3), s = Hn(n.N) + "/documents", i = {
        documents: e2.map((t4) => Qn(n.N, t4))
      }, r = await n.Ki("BatchGetDocuments", s, i), o = new Map();
      r.forEach((t4) => {
        const e3 = Zn(n.N, t4);
        o.set(e3.key.toString(), e3);
      });
      const a = [];
      return e2.forEach((t4) => {
        const e3 = o.get(t4.toString());
        M2(!!e3), a.push(e3);
      }), a;
    }(this.datastore, t2);
    return e.forEach((t3) => this.recordVersion(t3)), e;
  }
  set(t2, e) {
    this.write(e.toMutation(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  update(t2, e) {
    try {
      this.write(e.toMutation(t2, this.preconditionForUpdate(t2)));
    } catch (t3) {
      this.lastWriteError = t3;
    }
    this.writtenDocs.add(t2.toString());
  }
  delete(t2) {
    this.write(new rn(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  async commit() {
    if (this.ensureCommitNotCalled(), this.lastWriteError)
      throw this.lastWriteError;
    const t2 = this.readVersions;
    this.mutations.forEach((e) => {
      t2.delete(e.key.toString());
    }), t2.forEach((t3, e) => {
      const n = Rt.fromPath(e);
      this.mutations.push(new on(n, this.precondition(n)));
    }), await async function(t3, e) {
      const n = B2(t3), s = Hn(n.N) + "/documents", i = {
        writes: e.map((t4) => es(n.N, t4))
      };
      await n.Li("Commit", s, i);
    }(this.datastore, this.mutations), this.committed = true;
  }
  recordVersion(t2) {
    let e;
    if (t2.isFoundDocument())
      e = t2.version;
    else {
      if (!t2.isNoDocument())
        throw F2();
      e = st.min();
    }
    const n = this.readVersions.get(t2.key.toString());
    if (n) {
      if (!e.isEqual(n))
        throw new q2(U2.ABORTED, "Document version changed between two reads.");
    } else
      this.readVersions.set(t2.key.toString(), e);
  }
  precondition(t2) {
    const e = this.readVersions.get(t2.toString());
    return !this.writtenDocs.has(t2.toString()) && e ? Qe.updateTime(e) : Qe.none();
  }
  preconditionForUpdate(t2) {
    const e = this.readVersions.get(t2.toString());
    if (!this.writtenDocs.has(t2.toString()) && e) {
      if (e.isEqual(st.min()))
        throw new q2(U2.INVALID_ARGUMENT, "Can't update a document that doesn't exist.");
      return Qe.updateTime(e);
    }
    return Qe.exists(true);
  }
  write(t2) {
    this.ensureCommitNotCalled(), this.mutations.push(t2);
  }
  ensureCommitNotCalled() {
  }
};
var Ba = class {
  constructor(t2, e, n, s) {
    this.asyncQueue = t2, this.datastore = e, this.updateFunction = n, this.deferred = s, this.aa = 5, this.rr = new Jr(this.asyncQueue, "transaction_retry");
  }
  run() {
    this.aa -= 1, this.ca();
  }
  ca() {
    this.rr.Xi(async () => {
      const t2 = new La2(this.datastore), e = this.ua(t2);
      e && e.then((e2) => {
        this.asyncQueue.enqueueAndForget(() => t2.commit().then(() => {
          this.deferred.resolve(e2);
        }).catch((t3) => {
          this.ha(t3);
        }));
      }).catch((t3) => {
        this.ha(t3);
      });
    });
  }
  ua(t2) {
    try {
      const e = this.updateFunction(t2);
      return !Tt(e) && e.catch && e.then ? e : (this.deferred.reject(Error("Transaction callback must return a Promise")), null);
    } catch (t3) {
      return this.deferred.reject(t3), null;
    }
  }
  ha(t2) {
    this.aa > 0 && this.la(t2) ? (this.aa -= 1, this.asyncQueue.enqueueAndForget(() => (this.ca(), Promise.resolve()))) : this.deferred.reject(t2);
  }
  la(t2) {
    if (t2.name === "FirebaseError") {
      const e = t2.code;
      return e === "aborted" || e === "failed-precondition" || !hn(e);
    }
    return false;
  }
};
var Ua2 = class {
  constructor(t2, e, n) {
    this.credentials = t2, this.asyncQueue = e, this.databaseInfo = n, this.user = V2.UNAUTHENTICATED, this.clientId = X2.I(), this.credentialListener = () => Promise.resolve(), this.credentials.start(e, async (t3) => {
      x2("FirestoreClient", "Received user=", t3.uid), await this.credentialListener(t3), this.user = t3;
    });
  }
  async getConfiguration() {
    return {
      asyncQueue: this.asyncQueue,
      databaseInfo: this.databaseInfo,
      clientId: this.clientId,
      credentials: this.credentials,
      initialUser: this.user,
      maxConcurrentLimboResolutions: 100
    };
  }
  setCredentialChangeListener(t2) {
    this.credentialListener = t2;
  }
  verifyNotTerminated() {
    if (this.asyncQueue.isShuttingDown)
      throw new q2(U2.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  terminate() {
    this.asyncQueue.enterRestrictedMode();
    const t2 = new K2();
    return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
      try {
        this.onlineComponents && await this.onlineComponents.terminate(), this.offlineComponents && await this.offlineComponents.terminate(), this.credentials.shutdown(), t2.resolve();
      } catch (e) {
        const n = No(e, "Failed to shutdown persistence");
        t2.reject(n);
      }
    }), t2.promise;
  }
};
async function qa2(t2, e) {
  t2.asyncQueue.verifyOperationInProgress(), x2("FirestoreClient", "Initializing OfflineComponentProvider");
  const n = await t2.getConfiguration();
  await e.initialize(n);
  let s = n.initialUser;
  t2.setCredentialChangeListener(async (t3) => {
    s.isEqual(t3) || (await cr(e.localStore, t3), s = t3);
  }), e.persistence.setDatabaseDeletedListener(() => t2.terminate()), t2.offlineComponents = e;
}
async function Ka2(t2, e) {
  t2.asyncQueue.verifyOperationInProgress();
  const n = await ja2(t2);
  x2("FirestoreClient", "Initializing OnlineComponentProvider");
  const s = await t2.getConfiguration();
  await e.initialize(n, s), t2.setCredentialChangeListener((t3) => async function(t4, e2) {
    const n2 = B2(t4);
    n2.asyncQueue.verifyOperationInProgress(), x2("RemoteStore", "RemoteStore received new credentials");
    const s2 = lo(n2);
    n2.Kr.add(3), await io(n2), s2 && n2.Wr.set("Unknown"), await n2.remoteSyncer.handleCredentialChange(e2), n2.Kr.delete(3), await so(n2);
  }(e.remoteStore, t3)), t2.onlineComponents = e;
}
async function ja2(t2) {
  return t2.offlineComponents || (x2("FirestoreClient", "Using default OfflineComponentProvider"), await qa2(t2, new Na2())), t2.offlineComponents;
}
async function Qa(t2) {
  return t2.onlineComponents || (x2("FirestoreClient", "Using default OnlineComponentProvider"), await Ka2(t2, new $a2())), t2.onlineComponents;
}
function Wa2(t2) {
  return ja2(t2).then((t3) => t3.persistence);
}
function Ga2(t2) {
  return ja2(t2).then((t3) => t3.localStore);
}
function za2(t2) {
  return Qa(t2).then((t3) => t3.remoteStore);
}
function Ha2(t2) {
  return Qa(t2).then((t3) => t3.syncEngine);
}
async function Ja2(t2) {
  const e = await Qa(t2), n = e.eventManager;
  return n.onListen = ta2.bind(null, e.syncEngine), n.onUnlisten = na2.bind(null, e.syncEngine), n;
}
function Ya2(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await Wa2(t2), n = await za2(t2);
    return e.setNetworkEnabled(true), function(t3) {
      const e2 = B2(t3);
      return e2.Kr.delete(0), so(e2);
    }(n);
  });
}
function Xa2(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await Wa2(t2), n = await za2(t2);
    return e.setNetworkEnabled(false), async function(t3) {
      const e2 = B2(t3);
      e2.Kr.add(0), await io(e2), e2.Wr.set("Offline");
    }(n);
  });
}
function Za2(t2, e) {
  const n = new K2();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await function(t4, e3) {
        const n3 = B2(t4);
        return n3.persistence.runTransaction("read document", "readonly", (t5) => n3.Qn.An(t5, e3));
      }(t3, e2);
      s.isFoundDocument() ? n2.resolve(s) : s.isNoDocument() ? n2.resolve(null) : n2.reject(new q2(U2.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)"));
    } catch (t4) {
      const s = No(t4, `Failed to get document '${e2} from cache`);
      n2.reject(s);
    }
  }(await Ga2(t2), e, n)), n.promise;
}
function tc2(t2, e, n = {}) {
  const s = new K2();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new Fa2({
      next: (r2) => {
        e2.enqueueAndForget(() => Lo(t3, o));
        const a = r2.docs.has(n2);
        !a && r2.fromCache ? i.reject(new q2(U2.UNAVAILABLE, "Failed to get document because the client is offline.")) : a && r2.fromCache && s2 && s2.source === "server" ? i.reject(new q2(U2.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : i.resolve(r2);
      },
      error: (t4) => i.reject(t4)
    }), o = new Ko(fe(n2.path), r, {
      includeMetadataChanges: true,
      uo: true
    });
    return Mo(t3, o);
  }(await Ja2(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function ec2(t2, e) {
  const n = new K2();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await mr(t3, e2, true), i = new Jo(e2, s.Gn), r = i.Io(s.documents), o = i.applyChanges(r, false);
      n2.resolve(o.snapshot);
    } catch (t4) {
      const s = No(t4, `Failed to execute query '${e2} against cache`);
      n2.reject(s);
    }
  }(await Ga2(t2), e, n)), n.promise;
}
function nc2(t2, e, n = {}) {
  const s = new K2();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new Fa2({
      next: (n3) => {
        e2.enqueueAndForget(() => Lo(t3, o)), n3.fromCache && s2.source === "server" ? i.reject(new q2(U2.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : i.resolve(n3);
      },
      error: (t4) => i.reject(t4)
    }), o = new Ko(n2, r, {
      includeMetadataChanges: true,
      uo: true
    });
    return Mo(t3, o);
  }(await Ja2(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function sc2(t2, e) {
  const n = new Fa2(e);
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
    B2(t3).Zr.add(e2), e2.next();
  }(await Ja2(t2), n)), () => {
    n.Xo(), t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
      B2(t3).Zr.delete(e2);
    }(await Ja2(t2), n));
  };
}
function ic2(t2, e) {
  const n = new K2();
  return t2.asyncQueue.enqueueAndForget(async () => {
    const s = await function(t3) {
      return Qa(t3).then((t4) => t4.datastore);
    }(t2);
    new Ba(t2.asyncQueue, s, e, n).run();
  }), n.promise;
}
function rc2(t2, e, n, s) {
  const i = function(t3, e2) {
    let n2;
    n2 = typeof t3 == "string" ? new TextEncoder().encode(t3) : t3;
    return function(t4, e3) {
      return new Ma2(t4, e3);
    }(function(t4, e3) {
      if (t4 instanceof Uint8Array)
        return Oa(t4, e3);
      if (t4 instanceof ArrayBuffer)
        return Oa(new Uint8Array(t4), e3);
      if (t4 instanceof ReadableStream)
        return t4.getReader();
      throw new Error("Source of `toByteStreamReader` has to be a ArrayBuffer or ReadableStream");
    }(n2), e2);
  }(n, Hr(e));
  t2.asyncQueue.enqueueAndForget(async () => {
    Ca2(await Ha2(t2), i, s);
  });
}
function oc2(t2, e) {
  return t2.asyncQueue.enqueue(async () => function(t3, e2) {
    const n = B2(t3);
    return n.persistence.runTransaction("Get named query", "readonly", (t4) => n.Je.getNamedQuery(t4, e2));
  }(await Ga2(t2), e));
}
var ac2 = class {
  constructor(t2, e, n, s, i, r, o, a) {
    this.databaseId = t2, this.appId = e, this.persistenceKey = n, this.host = s, this.ssl = i, this.forceLongPolling = r, this.autoDetectLongPolling = o, this.useFetchStreams = a;
  }
};
var cc2 = class {
  constructor(t2, e) {
    this.projectId = t2, this.database = e || "(default)";
  }
  get isDefaultDatabase() {
    return this.database === "(default)";
  }
  isEqual(t2) {
    return t2 instanceof cc2 && t2.projectId === this.projectId && t2.database === this.database;
  }
};
var uc2 = new Map();
function hc2(t2, e, n) {
  if (!n)
    throw new q2(U2.INVALID_ARGUMENT, `Function ${t2}() cannot be called with an empty ${e}.`);
}
function lc2(t2, e, n, s) {
  if (e === true && s === true)
    throw new q2(U2.INVALID_ARGUMENT, `${t2} and ${n} cannot be used together.`);
}
function fc2(t2) {
  if (!Rt.isDocumentKey(t2))
    throw new q2(U2.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${t2} has ${t2.length}.`);
}
function dc2(t2) {
  if (Rt.isDocumentKey(t2))
    throw new q2(U2.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${t2} has ${t2.length}.`);
}
function wc2(t2) {
  if (t2 === void 0)
    return "undefined";
  if (t2 === null)
    return "null";
  if (typeof t2 == "string")
    return t2.length > 20 && (t2 = `${t2.substring(0, 20)}...`), JSON.stringify(t2);
  if (typeof t2 == "number" || typeof t2 == "boolean")
    return "" + t2;
  if (typeof t2 == "object") {
    if (t2 instanceof Array)
      return "an array";
    {
      const e = function(t3) {
        if (t3.constructor) {
          const e2 = /function\s+([^\s(]+)\s*\(/.exec(t3.constructor.toString());
          if (e2 && e2.length > 1)
            return e2[1];
        }
        return null;
      }(t2);
      return e ? `a custom ${e} object` : "an object";
    }
  }
  return typeof t2 == "function" ? "a function" : F2();
}
function _c(t2, e) {
  if ("_delegate" in t2 && (t2 = t2._delegate), !(t2 instanceof e)) {
    if (e.name === t2.constructor.name)
      throw new q2(U2.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const n = wc2(t2);
      throw new q2(U2.INVALID_ARGUMENT, `Expected type '${e.name}', but it was: ${n}`);
    }
  }
  return t2;
}
function mc2(t2, e) {
  if (e <= 0)
    throw new q2(U2.INVALID_ARGUMENT, `Function ${t2}() requires a positive number, but it was: ${e}.`);
}
var gc2 = class {
  constructor(t2) {
    var e;
    if (t2.host === void 0) {
      if (t2.ssl !== void 0)
        throw new q2(U2.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = true;
    } else
      this.host = t2.host, this.ssl = (e = t2.ssl) === null || e === void 0 || e;
    if (this.credentials = t2.credentials, this.ignoreUndefinedProperties = !!t2.ignoreUndefinedProperties, t2.cacheSizeBytes === void 0)
      this.cacheSizeBytes = 41943040;
    else {
      if (t2.cacheSizeBytes !== -1 && t2.cacheSizeBytes < 1048576)
        throw new q2(U2.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = t2.cacheSizeBytes;
    }
    this.experimentalForceLongPolling = !!t2.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!t2.experimentalAutoDetectLongPolling, this.useFetchStreams = !!t2.useFetchStreams, lc2("experimentalForceLongPolling", t2.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t2.experimentalAutoDetectLongPolling);
  }
  isEqual(t2) {
    return this.host === t2.host && this.ssl === t2.ssl && this.credentials === t2.credentials && this.cacheSizeBytes === t2.cacheSizeBytes && this.experimentalForceLongPolling === t2.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t2.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === t2.ignoreUndefinedProperties && this.useFetchStreams === t2.useFetchStreams;
  }
};
var yc2 = class {
  constructor(t2, e) {
    this._credentials = e, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new gc2({}), this._settingsFrozen = false, t2 instanceof cc2 ? this._databaseId = t2 : (this._app = t2, this._databaseId = function(t3) {
      if (!Object.prototype.hasOwnProperty.apply(t3.options, ["projectId"]))
        throw new q2(U2.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
      return new cc2(t3.options.projectId);
    }(t2));
  }
  get app() {
    if (!this._app)
      throw new q2(U2.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return this._terminateTask !== void 0;
  }
  _setSettings(t2) {
    if (this._settingsFrozen)
      throw new q2(U2.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new gc2(t2), t2.credentials !== void 0 && (this._credentials = function(t3) {
      if (!t3)
        return new Q2();
      switch (t3.type) {
        case "gapi":
          const e = t3.client;
          return M2(!(typeof e != "object" || e === null || !e.auth || !e.auth.getAuthHeaderValueForFirstParty)), new H2(e, t3.sessionIndex || "0", t3.iamToken || null);
        case "provider":
          return t3.client;
        default:
          throw new q2(U2.INVALID_ARGUMENT, "makeCredentialsProvider failed due to invalid credential type");
      }
    }(t2.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = true, this._settings;
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
  }
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  _terminate() {
    return function(t2) {
      const e = uc2.get(t2);
      e && (x2("ComponentProvider", "Removing Datastore"), uc2.delete(t2), e.terminate());
    }(this), Promise.resolve();
  }
};
function pc2(t2, e, n, s = {}) {
  var i;
  const r = (t2 = _c(t2, yc2))._getSettings();
  if (r.host !== "firestore.googleapis.com" && r.host !== e && $("Host has been set in both settings() and useEmulator(), emulator host will be used"), t2._setSettings(Object.assign(Object.assign({}, r), {
    host: `${e}:${n}`,
    ssl: false
  })), s.mockUserToken) {
    let e2, n2;
    if (typeof s.mockUserToken == "string")
      e2 = s.mockUserToken, n2 = V2.MOCK_USER;
    else {
      e2 = createMockUserToken(s.mockUserToken, (i = t2._app) === null || i === void 0 ? void 0 : i.options.projectId);
      const r2 = s.mockUserToken.sub || s.mockUserToken.user_id;
      if (!r2)
        throw new q2(U2.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
      n2 = new V2(r2);
    }
    t2._credentials = new W2(new j(e2, n2));
  }
}
var Ec2 = class {
  constructor(t2, e, n) {
    this.converter = e, this._key = n, this.type = "document", this.firestore = t2;
  }
  get _path() {
    return this._key.path;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get path() {
    return this._key.path.canonicalString();
  }
  get parent() {
    return new Ic2(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(t2) {
    return new Ec2(this.firestore, t2, this._key);
  }
};
var Tc2 = class {
  constructor(t2, e, n) {
    this.converter = e, this._query = n, this.type = "query", this.firestore = t2;
  }
  withConverter(t2) {
    return new Tc2(this.firestore, t2, this._query);
  }
};
var Ic2 = class extends Tc2 {
  constructor(t2, e, n) {
    super(t2, e, fe(n)), this._path = n, this.type = "collection";
  }
  get id() {
    return this._query.path.lastSegment();
  }
  get path() {
    return this._query.path.canonicalString();
  }
  get parent() {
    const t2 = this._path.popLast();
    return t2.isEmpty() ? null : new Ec2(this.firestore, null, new Rt(t2));
  }
  withConverter(t2) {
    return new Ic2(this.firestore, t2, this._path);
  }
};
function Ac2(t2, e, ...n) {
  if (t2 = getModularInstance(t2), hc2("collection", "path", e), t2 instanceof yc2) {
    const s = ct.fromString(e, ...n);
    return dc2(s), new Ic2(t2, null, s);
  }
  {
    if (!(t2 instanceof Ec2 || t2 instanceof Ic2))
      throw new q2(U2.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(ct.fromString(e, ...n));
    return dc2(s), new Ic2(t2.firestore, null, s);
  }
}
function Rc2(t2, e) {
  if (t2 = _c(t2, yc2), hc2("collectionGroup", "collection id", e), e.indexOf("/") >= 0)
    throw new q2(U2.INVALID_ARGUMENT, `Invalid collection ID '${e}' passed to function collectionGroup(). Collection IDs must not contain '/'.`);
  return new Tc2(t2, null, function(t3) {
    return new he(ct.emptyPath(), t3);
  }(e));
}
function bc2(t2, e, ...n) {
  if (t2 = getModularInstance(t2), arguments.length === 1 && (e = X2.I()), hc2("doc", "path", e), t2 instanceof yc2) {
    const s = ct.fromString(e, ...n);
    return fc2(s), new Ec2(t2, null, new Rt(s));
  }
  {
    if (!(t2 instanceof Ec2 || t2 instanceof Ic2))
      throw new q2(U2.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(ct.fromString(e, ...n));
    return fc2(s), new Ec2(t2.firestore, t2 instanceof Ic2 ? t2.converter : null, new Rt(s));
  }
}
function Pc2(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), (t2 instanceof Ec2 || t2 instanceof Ic2) && (e instanceof Ec2 || e instanceof Ic2) && (t2.firestore === e.firestore && t2.path === e.path && t2.converter === e.converter);
}
function vc2(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), t2 instanceof Tc2 && e instanceof Tc2 && (t2.firestore === e.firestore && Te(t2._query, e._query) && t2.converter === e.converter);
}
var Vc2 = class {
  constructor() {
    this.fa = Promise.resolve(), this.da = [], this.wa = false, this._a = [], this.ma = null, this.ga = false, this.ya = false, this.pa = [], this.rr = new Jr(this, "async_queue_retry"), this.Ea = () => {
      const t3 = zr();
      t3 && x2("AsyncQueue", "Visibility state changed to " + t3.visibilityState), this.rr.tr();
    };
    const t2 = zr();
    t2 && typeof t2.addEventListener == "function" && t2.addEventListener("visibilitychange", this.Ea);
  }
  get isShuttingDown() {
    return this.wa;
  }
  enqueueAndForget(t2) {
    this.enqueue(t2);
  }
  enqueueAndForgetEvenWhileRestricted(t2) {
    this.Ta(), this.Ia(t2);
  }
  enterRestrictedMode(t2) {
    if (!this.wa) {
      this.wa = true, this.ya = t2 || false;
      const e = zr();
      e && typeof e.removeEventListener == "function" && e.removeEventListener("visibilitychange", this.Ea);
    }
  }
  enqueue(t2) {
    if (this.Ta(), this.wa)
      return new Promise(() => {
      });
    const e = new K2();
    return this.Ia(() => this.wa && this.ya ? Promise.resolve() : (t2().then(e.resolve, e.reject), e.promise)).then(() => e.promise);
  }
  enqueueRetryable(t2) {
    this.enqueueAndForget(() => (this.da.push(t2), this.Aa()));
  }
  async Aa() {
    if (this.da.length !== 0) {
      try {
        await this.da[0](), this.da.shift(), this.rr.reset();
      } catch (t2) {
        if (!Gs(t2))
          throw t2;
        x2("AsyncQueue", "Operation failed with retryable error: " + t2);
      }
      this.da.length > 0 && this.rr.Xi(() => this.Aa());
    }
  }
  Ia(t2) {
    const e = this.fa.then(() => (this.ga = true, t2().catch((t3) => {
      this.ma = t3, this.ga = false;
      throw k2("INTERNAL UNHANDLED ERROR: ", function(t4) {
        let e2 = t4.message || "";
        t4.stack && (e2 = t4.stack.includes(t4.message) ? t4.stack : t4.message + "\n" + t4.stack);
        return e2;
      }(t3)), t3;
    }).then((t3) => (this.ga = false, t3))));
    return this.fa = e, e;
  }
  enqueueAfterDelay(t2, e, n) {
    this.Ta(), this.pa.indexOf(t2) > -1 && (e = 0);
    const s = Co.createAndSchedule(this, t2, e, n, (t3) => this.Ra(t3));
    return this._a.push(s), s;
  }
  Ta() {
    this.ma && F2();
  }
  verifyOperationInProgress() {
  }
  async ba() {
    let t2;
    do {
      t2 = this.fa, await t2;
    } while (t2 !== this.fa);
  }
  Pa(t2) {
    for (const e of this._a)
      if (e.timerId === t2)
        return true;
    return false;
  }
  va(t2) {
    return this.ba().then(() => {
      this._a.sort((t3, e) => t3.targetTimeMs - e.targetTimeMs);
      for (const e of this._a)
        if (e.skipDelay(), t2 !== "all" && e.timerId === t2)
          break;
      return this.ba();
    });
  }
  Va(t2) {
    this.pa.push(t2);
  }
  Ra(t2) {
    const e = this._a.indexOf(t2);
    this._a.splice(e, 1);
  }
};
function Sc2(t2) {
  return function(t3, e) {
    if (typeof t3 != "object" || t3 === null)
      return false;
    const n = t3;
    for (const t4 of e)
      if (t4 in n && typeof n[t4] == "function")
        return true;
    return false;
  }(t2, ["next", "error", "complete"]);
}
var Dc2 = class {
  constructor() {
    this._progressObserver = {}, this._taskCompletionResolver = new K2(), this._lastProgress = {
      taskState: "Running",
      totalBytes: 0,
      totalDocuments: 0,
      bytesLoaded: 0,
      documentsLoaded: 0
    };
  }
  onProgress(t2, e, n) {
    this._progressObserver = {
      next: t2,
      error: e,
      complete: n
    };
  }
  catch(t2) {
    return this._taskCompletionResolver.promise.catch(t2);
  }
  then(t2, e) {
    return this._taskCompletionResolver.promise.then(t2, e);
  }
  _completeWith(t2) {
    this._updateProgress(t2), this._progressObserver.complete && this._progressObserver.complete(), this._taskCompletionResolver.resolve(t2);
  }
  _failWith(t2) {
    this._lastProgress.taskState = "Error", this._progressObserver.next && this._progressObserver.next(this._lastProgress), this._progressObserver.error && this._progressObserver.error(t2), this._taskCompletionResolver.reject(t2);
  }
  _updateProgress(t2) {
    this._lastProgress = t2, this._progressObserver.next && this._progressObserver.next(t2);
  }
};
var Cc2 = -1;
var Nc2 = class extends yc2 {
  constructor(t2, e) {
    super(t2, e), this.type = "firestore", this._queue = new Vc2(), this._persistenceKey = "name" in t2 ? t2.name : "[DEFAULT]";
  }
  _terminate() {
    return this._firestoreClient || Oc2(this), this._firestoreClient.terminate();
  }
};
function xc2(t2, e) {
  const n = _getProvider(t2, "firestore");
  if (n.isInitialized()) {
    const t3 = n.getImmediate(), s = n.getOptions();
    if (deepEqual(s, e))
      return t3;
    throw new q2(U2.FAILED_PRECONDITION, "initializeFirestore() has already been called with different options. To avoid this error, call initializeFirestore() with the same options as when it was originally called, or call getFirestore() to return the already initialized instance.");
  }
  if (e.cacheSizeBytes !== void 0 && e.cacheSizeBytes !== -1 && e.cacheSizeBytes < 1048576)
    throw new q2(U2.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
  return n.initialize({
    options: e
  });
}
function kc2(e = getApp()) {
  return _getProvider(e, "firestore").getImmediate();
}
function $c2(t2) {
  return t2._firestoreClient || Oc2(t2), t2._firestoreClient.verifyNotTerminated(), t2._firestoreClient;
}
function Oc2(t2) {
  var e;
  const n = t2._freezeSettings(), s = function(t3, e2, n2, s2) {
    return new ac2(t3, e2, n2, s2.host, s2.ssl, s2.experimentalForceLongPolling, s2.experimentalAutoDetectLongPolling, s2.useFetchStreams);
  }(t2._databaseId, ((e = t2._app) === null || e === void 0 ? void 0 : e.options.appId) || "", t2._persistenceKey, n);
  t2._firestoreClient = new Ua2(t2._credentials, t2._queue, s);
}
function Fc2(t2, e) {
  Gc2(t2 = _c(t2, Nc2));
  const n = $c2(t2), s = t2._freezeSettings(), i = new $a2();
  return Lc2(n, i, new xa2(i, s.cacheSizeBytes, e == null ? void 0 : e.forceOwnership));
}
function Mc2(t2) {
  Gc2(t2 = _c(t2, Nc2));
  const e = $c2(t2), n = t2._freezeSettings(), s = new $a2();
  return Lc2(e, s, new ka2(s, n.cacheSizeBytes));
}
function Lc2(t2, e, n) {
  const s = new K2();
  return t2.asyncQueue.enqueue(async () => {
    try {
      await qa2(t2, n), await Ka2(t2, e), s.resolve();
    } catch (t3) {
      if (!function(t4) {
        if (t4.name === "FirebaseError")
          return t4.code === U2.FAILED_PRECONDITION || t4.code === U2.UNIMPLEMENTED;
        if (typeof DOMException != "undefined" && t4 instanceof DOMException)
          return t4.code === 22 || t4.code === 20 || t4.code === 11;
        return true;
      }(t3))
        throw t3;
      console.warn("Error enabling offline persistence. Falling back to persistence disabled: " + t3), s.reject(t3);
    }
  }).then(() => s.promise);
}
function Bc2(t2) {
  if (t2._initialized && !t2._terminated)
    throw new q2(U2.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated.");
  const e = new K2();
  return t2._queue.enqueueAndForgetEvenWhileRestricted(async () => {
    try {
      await async function(t3) {
        if (!js.bt())
          return Promise.resolve();
        const e2 = t3 + "main";
        await js.delete(e2);
      }(er(t2._databaseId, t2._persistenceKey)), e.resolve();
    } catch (t3) {
      e.reject(t3);
    }
  }), e.promise;
}
function Uc2(t2) {
  return function(t3) {
    const e = new K2();
    return t3.asyncQueue.enqueueAndForget(async () => ua2(await Ha2(t3), e)), e.promise;
  }($c2(t2 = _c(t2, Nc2)));
}
function qc2(t2) {
  return Ya2($c2(t2 = _c(t2, Nc2)));
}
function Kc2(t2) {
  return Xa2($c2(t2 = _c(t2, Nc2)));
}
function jc2(t2) {
  return _removeServiceInstance(t2.app, "firestore"), t2._delete();
}
function Qc2(t2, e) {
  const n = $c2(t2 = _c(t2, Nc2)), s = new Dc2();
  return rc2(n, t2._databaseId, e, s), s;
}
function Wc2(t2, e) {
  return oc2($c2(t2 = _c(t2, Nc2)), e).then((e2) => e2 ? new Tc2(t2, null, e2.query) : null);
}
function Gc2(t2) {
  if (t2._initialized || t2._terminated)
    throw new q2(U2.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.");
}
var zc2 = class {
  constructor(...t2) {
    for (let e = 0; e < t2.length; ++e)
      if (t2[e].length === 0)
        throw new q2(U2.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new ht(t2);
  }
  isEqual(t2) {
    return this._internalPath.isEqual(t2._internalPath);
  }
};
function Hc2() {
  return new zc2("__name__");
}
var Jc2 = class {
  constructor(t2) {
    this._byteString = t2;
  }
  static fromBase64String(t2) {
    try {
      return new Jc2(dt.fromBase64String(t2));
    } catch (t3) {
      throw new q2(U2.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + t3);
    }
  }
  static fromUint8Array(t2) {
    return new Jc2(dt.fromUint8Array(t2));
  }
  toBase64() {
    return this._byteString.toBase64();
  }
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  isEqual(t2) {
    return this._byteString.isEqual(t2._byteString);
  }
};
var Yc2 = class {
  constructor(t2) {
    this._methodName = t2;
  }
};
var Xc2 = class {
  constructor(t2, e) {
    if (!isFinite(t2) || t2 < -90 || t2 > 90)
      throw new q2(U2.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t2);
    if (!isFinite(e) || e < -180 || e > 180)
      throw new q2(U2.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + e);
    this._lat = t2, this._long = e;
  }
  get latitude() {
    return this._lat;
  }
  get longitude() {
    return this._long;
  }
  isEqual(t2) {
    return this._lat === t2._lat && this._long === t2._long;
  }
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long
    };
  }
  _compareTo(t2) {
    return Z2(this._lat, t2._lat) || Z2(this._long, t2._long);
  }
};
var Zc2 = /^__.*__$/;
var tu = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return this.fieldMask !== null ? new tn(t2, this.data, this.fieldMask, e, this.fieldTransforms) : new Ze(t2, this.data, e, this.fieldTransforms);
  }
};
var eu = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return new tn(t2, this.data, this.fieldMask, e, this.fieldTransforms);
  }
};
function nu(t2) {
  switch (t2) {
    case 0:
    case 2:
    case 1:
      return true;
    case 3:
    case 4:
      return false;
    default:
      throw F2();
  }
}
var su = class {
  constructor(t2, e, n, s, i, r) {
    this.settings = t2, this.databaseId = e, this.N = n, this.ignoreUndefinedProperties = s, i === void 0 && this.Sa(), this.fieldTransforms = i || [], this.fieldMask = r || [];
  }
  get path() {
    return this.settings.path;
  }
  get Da() {
    return this.settings.Da;
  }
  Ca(t2) {
    return new su(Object.assign(Object.assign({}, this.settings), t2), this.databaseId, this.N, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  Na(t2) {
    var e;
    const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s = this.Ca({
      path: n,
      xa: false
    });
    return s.ka(t2), s;
  }
  $a(t2) {
    var e;
    const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s = this.Ca({
      path: n,
      xa: false
    });
    return s.Sa(), s;
  }
  Oa(t2) {
    return this.Ca({
      path: void 0,
      xa: true
    });
  }
  Fa(t2) {
    return Au(t2, this.settings.methodName, this.settings.Ma || false, this.path, this.settings.La);
  }
  contains(t2) {
    return this.fieldMask.find((e) => t2.isPrefixOf(e)) !== void 0 || this.fieldTransforms.find((e) => t2.isPrefixOf(e.field)) !== void 0;
  }
  Sa() {
    if (this.path)
      for (let t2 = 0; t2 < this.path.length; t2++)
        this.ka(this.path.get(t2));
  }
  ka(t2) {
    if (t2.length === 0)
      throw this.Fa("Document fields must not be empty");
    if (nu(this.Da) && Zc2.test(t2))
      throw this.Fa('Document fields cannot begin and end with "__"');
  }
};
var iu = class {
  constructor(t2, e, n) {
    this.databaseId = t2, this.ignoreUndefinedProperties = e, this.N = n || Hr(t2);
  }
  Ba(t2, e, n, s = false) {
    return new su({
      Da: t2,
      methodName: e,
      La: n,
      path: ht.emptyPath(),
      xa: false,
      Ma: s
    }, this.databaseId, this.N, this.ignoreUndefinedProperties);
  }
};
function ru(t2) {
  const e = t2._freezeSettings(), n = Hr(t2._databaseId);
  return new iu(t2._databaseId, !!e.ignoreUndefinedProperties, n);
}
function ou(t2, e, n, s, i, r = {}) {
  const o = t2.Ba(r.merge || r.mergeFields ? 2 : 0, e, n, i);
  pu("Data must be an object, but it was:", o, s);
  const a = gu(s, o);
  let c, u;
  if (r.merge)
    c = new lt(o.fieldMask), u = o.fieldTransforms;
  else if (r.mergeFields) {
    const t3 = [];
    for (const s2 of r.mergeFields) {
      const i2 = Eu(e, s2, n);
      if (!o.contains(i2))
        throw new q2(U2.INVALID_ARGUMENT, `Field '${i2}' is specified in your field mask but missing from your input data.`);
      Ru(t3, i2) || t3.push(i2);
    }
    c = new lt(t3), u = o.fieldTransforms.filter((t4) => c.covers(t4.field));
  } else
    c = null, u = o.fieldTransforms;
  return new tu(new Lt(a), c, u);
}
var au = class extends Yc2 {
  _toFieldTransform(t2) {
    if (t2.Da !== 2)
      throw t2.Da === 1 ? t2.Fa(`${this._methodName}() can only appear at the top level of your update data`) : t2.Fa(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    return t2.fieldMask.push(t2.path), null;
  }
  isEqual(t2) {
    return t2 instanceof au;
  }
};
function cu(t2, e, n) {
  return new su({
    Da: 3,
    La: e.settings.La,
    methodName: t2._methodName,
    xa: n
  }, e.databaseId, e.N, e.ignoreUndefinedProperties);
}
var uu = class extends Yc2 {
  _toFieldTransform(t2) {
    return new qe(t2.path, new ke());
  }
  isEqual(t2) {
    return t2 instanceof uu;
  }
};
var hu = class extends Yc2 {
  constructor(t2, e) {
    super(t2), this.Ua = e;
  }
  _toFieldTransform(t2) {
    const e = cu(this, t2, true), n = this.Ua.map((t3) => mu(t3, e)), s = new $e(n);
    return new qe(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var lu = class extends Yc2 {
  constructor(t2, e) {
    super(t2), this.Ua = e;
  }
  _toFieldTransform(t2) {
    const e = cu(this, t2, true), n = this.Ua.map((t3) => mu(t3, e)), s = new Fe(n);
    return new qe(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var fu = class extends Yc2 {
  constructor(t2, e) {
    super(t2), this.qa = e;
  }
  _toFieldTransform(t2) {
    const e = new Le(t2.N, Se(t2.N, this.qa));
    return new qe(t2.path, e);
  }
  isEqual(t2) {
    return this === t2;
  }
};
function du(t2, e, n, s) {
  const i = t2.Ba(1, e, n);
  pu("Data must be an object, but it was:", i, s);
  const r = [], o = Lt.empty();
  rt(s, (t3, s2) => {
    const a2 = Iu(e, t3, n);
    s2 = getModularInstance(s2);
    const c = i.$a(a2);
    if (s2 instanceof au)
      r.push(a2);
    else {
      const t4 = mu(s2, c);
      t4 != null && (r.push(a2), o.set(a2, t4));
    }
  });
  const a = new lt(r);
  return new eu(o, a, i.fieldTransforms);
}
function wu(t2, e, n, s, i, r) {
  const o = t2.Ba(1, e, n), a = [Eu(e, s, n)], c = [i];
  if (r.length % 2 != 0)
    throw new q2(U2.INVALID_ARGUMENT, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let t3 = 0; t3 < r.length; t3 += 2)
    a.push(Eu(e, r[t3])), c.push(r[t3 + 1]);
  const u = [], h = Lt.empty();
  for (let t3 = a.length - 1; t3 >= 0; --t3)
    if (!Ru(u, a[t3])) {
      const e2 = a[t3];
      let n2 = c[t3];
      n2 = getModularInstance(n2);
      const s2 = o.$a(e2);
      if (n2 instanceof au)
        u.push(e2);
      else {
        const t4 = mu(n2, s2);
        t4 != null && (u.push(e2), h.set(e2, t4));
      }
    }
  const l2 = new lt(u);
  return new eu(h, l2, o.fieldTransforms);
}
function _u(t2, e, n, s = false) {
  return mu(n, t2.Ba(s ? 4 : 3, e));
}
function mu(t2, e) {
  if (yu(t2 = getModularInstance(t2)))
    return pu("Unsupported field value:", e, t2), gu(t2, e);
  if (t2 instanceof Yc2)
    return function(t3, e2) {
      if (!nu(e2.Da))
        throw e2.Fa(`${t3._methodName}() can only be used with update() and set()`);
      if (!e2.path)
        throw e2.Fa(`${t3._methodName}() is not currently supported inside arrays`);
      const n = t3._toFieldTransform(e2);
      n && e2.fieldTransforms.push(n);
    }(t2, e), null;
  if (t2 === void 0 && e.ignoreUndefinedProperties)
    return null;
  if (e.path && e.fieldMask.push(e.path), t2 instanceof Array) {
    if (e.settings.xa && e.Da !== 4)
      throw e.Fa("Nested arrays are not supported");
    return function(t3, e2) {
      const n = [];
      let s = 0;
      for (const i of t3) {
        let t4 = mu(i, e2.Oa(s));
        t4 == null && (t4 = {
          nullValue: "NULL_VALUE"
        }), n.push(t4), s++;
      }
      return {
        arrayValue: {
          values: n
        }
      };
    }(t2, e);
  }
  return function(t3, e2) {
    if ((t3 = getModularInstance(t3)) === null)
      return {
        nullValue: "NULL_VALUE"
      };
    if (typeof t3 == "number")
      return Se(e2.N, t3);
    if (typeof t3 == "boolean")
      return {
        booleanValue: t3
      };
    if (typeof t3 == "string")
      return {
        stringValue: t3
      };
    if (t3 instanceof Date) {
      const n = nt.fromDate(t3);
      return {
        timestampValue: Ln(e2.N, n)
      };
    }
    if (t3 instanceof nt) {
      const n = new nt(t3.seconds, 1e3 * Math.floor(t3.nanoseconds / 1e3));
      return {
        timestampValue: Ln(e2.N, n)
      };
    }
    if (t3 instanceof Xc2)
      return {
        geoPointValue: {
          latitude: t3.latitude,
          longitude: t3.longitude
        }
      };
    if (t3 instanceof Jc2)
      return {
        bytesValue: Bn(e2.N, t3._byteString)
      };
    if (t3 instanceof Ec2) {
      const n = e2.databaseId, s = t3.firestore._databaseId;
      if (!s.isEqual(n))
        throw e2.Fa(`Document reference is for database ${s.projectId}/${s.database} but should be for database ${n.projectId}/${n.database}`);
      return {
        referenceValue: Kn(t3.firestore._databaseId || e2.databaseId, t3._key.path)
      };
    }
    throw e2.Fa(`Unsupported field value: ${wc2(t3)}`);
  }(t2, e);
}
function gu(t2, e) {
  const n = {};
  return ot(t2) ? e.path && e.path.length > 0 && e.fieldMask.push(e.path) : rt(t2, (t3, s) => {
    const i = mu(s, e.Na(t3));
    i != null && (n[t3] = i);
  }), {
    mapValue: {
      fields: n
    }
  };
}
function yu(t2) {
  return !(typeof t2 != "object" || t2 === null || t2 instanceof Array || t2 instanceof Date || t2 instanceof nt || t2 instanceof Xc2 || t2 instanceof Jc2 || t2 instanceof Ec2 || t2 instanceof Yc2);
}
function pu(t2, e, n) {
  if (!yu(n) || !function(t3) {
    return typeof t3 == "object" && t3 !== null && (Object.getPrototypeOf(t3) === Object.prototype || Object.getPrototypeOf(t3) === null);
  }(n)) {
    const s = wc2(n);
    throw s === "an object" ? e.Fa(t2 + " a custom object") : e.Fa(t2 + " " + s);
  }
}
function Eu(t2, e, n) {
  if ((e = getModularInstance(e)) instanceof zc2)
    return e._internalPath;
  if (typeof e == "string")
    return Iu(t2, e);
  throw Au("Field path arguments must be of type string or FieldPath.", t2, false, void 0, n);
}
var Tu = new RegExp("[~\\*/\\[\\]]");
function Iu(t2, e, n) {
  if (e.search(Tu) >= 0)
    throw Au(`Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`, t2, false, void 0, n);
  try {
    return new zc2(...e.split("."))._internalPath;
  } catch (s) {
    throw Au(`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, t2, false, void 0, n);
  }
}
function Au(t2, e, n, s, i) {
  const r = s && !s.isEmpty(), o = i !== void 0;
  let a = `Function ${e}() called with invalid data`;
  n && (a += " (via `toFirestore()`)"), a += ". ";
  let c = "";
  return (r || o) && (c += " (found", r && (c += ` in field ${s}`), o && (c += ` in document ${i}`), c += ")"), new q2(U2.INVALID_ARGUMENT, a + t2 + c);
}
function Ru(t2, e) {
  return t2.some((t3) => t3.isEqual(e));
}
var bu = class {
  constructor(t2, e, n, s, i) {
    this._firestore = t2, this._userDataWriter = e, this._key = n, this._document = s, this._converter = i;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get ref() {
    return new Ec2(this._firestore, this._converter, this._key);
  }
  exists() {
    return this._document !== null;
  }
  data() {
    if (this._document) {
      if (this._converter) {
        const t2 = new Pu(this._firestore, this._userDataWriter, this._key, this._document, null);
        return this._converter.fromFirestore(t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  get(t2) {
    if (this._document) {
      const e = this._document.data.field(vu("DocumentSnapshot.get", t2));
      if (e !== null)
        return this._userDataWriter.convertValue(e);
    }
  }
};
var Pu = class extends bu {
  data() {
    return super.data();
  }
};
function vu(t2, e) {
  return typeof e == "string" ? Iu(t2, e) : e instanceof zc2 ? e._internalPath : e._delegate._internalPath;
}
var Vu = class {
  constructor(t2, e) {
    this.hasPendingWrites = t2, this.fromCache = e;
  }
  isEqual(t2) {
    return this.hasPendingWrites === t2.hasPendingWrites && this.fromCache === t2.fromCache;
  }
};
var Su = class extends bu {
  constructor(t2, e, n, s, i, r) {
    super(t2, e, n, s, r), this._firestore = t2, this._firestoreImpl = t2, this.metadata = i;
  }
  exists() {
    return super.exists();
  }
  data(t2 = {}) {
    if (this._document) {
      if (this._converter) {
        const e = new Du(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
        return this._converter.fromFirestore(e, t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value, t2.serverTimestamps);
    }
  }
  get(t2, e = {}) {
    if (this._document) {
      const n = this._document.data.field(vu("DocumentSnapshot.get", t2));
      if (n !== null)
        return this._userDataWriter.convertValue(n, e.serverTimestamps);
    }
  }
};
var Du = class extends Su {
  data(t2 = {}) {
    return super.data(t2);
  }
};
var Cu = class {
  constructor(t2, e, n, s) {
    this._firestore = t2, this._userDataWriter = e, this._snapshot = s, this.metadata = new Vu(s.hasPendingWrites, s.fromCache), this.query = n;
  }
  get docs() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), t2;
  }
  get size() {
    return this._snapshot.docs.size;
  }
  get empty() {
    return this.size === 0;
  }
  forEach(t2, e) {
    this._snapshot.docs.forEach((n) => {
      t2.call(e, new Du(this._firestore, this._userDataWriter, n.key, n, new Vu(this._snapshot.mutatedKeys.has(n.key), this._snapshot.fromCache), this.query.converter));
    });
  }
  docChanges(t2 = {}) {
    const e = !!t2.includeMetadataChanges;
    if (e && this._snapshot.excludesMetadataChanges)
      throw new q2(U2.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
    return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e || (this._cachedChanges = function(t3, e2) {
      if (t3._snapshot.oldDocs.isEmpty()) {
        let e3 = 0;
        return t3._snapshot.docChanges.map((n) => ({
          type: "added",
          doc: new Du(t3._firestore, t3._userDataWriter, n.doc.key, n.doc, new Vu(t3._snapshot.mutatedKeys.has(n.doc.key), t3._snapshot.fromCache), t3.query.converter),
          oldIndex: -1,
          newIndex: e3++
        }));
      }
      {
        let n = t3._snapshot.oldDocs;
        return t3._snapshot.docChanges.filter((t4) => e2 || t4.type !== 3).map((e3) => {
          const s = new Du(t3._firestore, t3._userDataWriter, e3.doc.key, e3.doc, new Vu(t3._snapshot.mutatedKeys.has(e3.doc.key), t3._snapshot.fromCache), t3.query.converter);
          let i = -1, r = -1;
          return e3.type !== 0 && (i = n.indexOf(e3.doc.key), n = n.delete(e3.doc.key)), e3.type !== 1 && (n = n.add(e3.doc), r = n.indexOf(e3.doc.key)), {
            type: Nu(e3.type),
            doc: s,
            oldIndex: i,
            newIndex: r
          };
        });
      }
    }(this, e), this._cachedChangesIncludeMetadataChanges = e), this._cachedChanges;
  }
};
function Nu(t2) {
  switch (t2) {
    case 0:
      return "added";
    case 2:
    case 3:
      return "modified";
    case 1:
      return "removed";
    default:
      return F2();
  }
}
function xu(t2, e) {
  return t2 instanceof Su && e instanceof Su ? t2._firestore === e._firestore && t2._key.isEqual(e._key) && (t2._document === null ? e._document === null : t2._document.isEqual(e._document)) && t2._converter === e._converter : t2 instanceof Cu && e instanceof Cu && (t2._firestore === e._firestore && vc2(t2.query, e.query) && t2.metadata.isEqual(e.metadata) && t2._snapshot.isEqual(e._snapshot));
}
function ku(t2) {
  if (we(t2) && t2.explicitOrderBy.length === 0)
    throw new q2(U2.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
}
var $u = class {
};
function Ou(t2, ...e) {
  for (const n of e)
    t2 = n._apply(t2);
  return t2;
}
var Fu = class extends $u {
  constructor(t2, e, n) {
    super(), this.Ka = t2, this.ja = e, this.Qa = n, this.type = "where";
  }
  _apply(t2) {
    const e = ru(t2.firestore), n = function(t3, e2, n2, s, i, r, o) {
      let a;
      if (i.isKeyField()) {
        if (r === "array-contains" || r === "array-contains-any")
          throw new q2(U2.INVALID_ARGUMENT, `Invalid Query. You can't perform '${r}' queries on FieldPath.documentId().`);
        if (r === "in" || r === "not-in") {
          Xu(o, r);
          const e3 = [];
          for (const n3 of o)
            e3.push(Yu(s, t3, n3));
          a = {
            arrayValue: {
              values: e3
            }
          };
        } else
          a = Yu(s, t3, o);
      } else
        r !== "in" && r !== "not-in" && r !== "array-contains-any" || Xu(o, r), a = _u(n2, e2, o, r === "in" || r === "not-in");
      const c = zt.create(i, r, a);
      return function(t4, e3) {
        if (e3.v()) {
          const n4 = me(t4);
          if (n4 !== null && !n4.isEqual(e3.field))
            throw new q2(U2.INVALID_ARGUMENT, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${n4.toString()}' and '${e3.field.toString()}'`);
          const s2 = _e(t4);
          s2 !== null && Zu(t4, e3.field, s2);
        }
        const n3 = function(t5, e4) {
          for (const n4 of t5.filters)
            if (e4.indexOf(n4.op) >= 0)
              return n4.op;
          return null;
        }(t4, function(t5) {
          switch (t5) {
            case "!=":
              return ["!=", "not-in"];
            case "array-contains":
              return ["array-contains", "array-contains-any", "not-in"];
            case "in":
              return ["array-contains-any", "in", "not-in"];
            case "array-contains-any":
              return ["array-contains", "array-contains-any", "in", "not-in"];
            case "not-in":
              return ["array-contains", "array-contains-any", "in", "not-in", "!="];
            default:
              return [];
          }
        }(e3.op));
        if (n3 !== null)
          throw n3 === e3.op ? new q2(U2.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${e3.op.toString()}' filter.`) : new q2(U2.INVALID_ARGUMENT, `Invalid query. You cannot use '${e3.op.toString()}' filters with '${n3.toString()}' filters.`);
      }(t3, c), c;
    }(t2._query, "where", e, t2.firestore._databaseId, this.Ka, this.ja, this.Qa);
    return new Tc2(t2.firestore, t2.converter, function(t3, e2) {
      const n2 = t3.filters.concat([e2]);
      return new he(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), n2, t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, n));
  }
};
function Mu(t2, e, n) {
  const s = e, i = vu("where", t2);
  return new Fu(i, s, n);
}
var Lu = class extends $u {
  constructor(t2, e) {
    super(), this.Ka = t2, this.Wa = e, this.type = "orderBy";
  }
  _apply(t2) {
    const e = function(t3, e2, n) {
      if (t3.startAt !== null)
        throw new q2(U2.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      if (t3.endAt !== null)
        throw new q2(U2.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      const s = new oe(e2, n);
      return function(t4, e3) {
        if (_e(t4) === null) {
          const n2 = me(t4);
          n2 !== null && Zu(t4, n2, e3.field);
        }
      }(t3, s), s;
    }(t2._query, this.Ka, this.Wa);
    return new Tc2(t2.firestore, t2.converter, function(t3, e2) {
      const n = t3.explicitOrderBy.concat([e2]);
      return new he(t3.path, t3.collectionGroup, n, t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, e));
  }
};
function Bu(t2, e = "asc") {
  const n = e, s = vu("orderBy", t2);
  return new Lu(s, n);
}
var Uu = class extends $u {
  constructor(t2, e, n) {
    super(), this.type = t2, this.Ga = e, this.za = n;
  }
  _apply(t2) {
    return new Tc2(t2.firestore, t2.converter, Ee(t2._query, this.Ga, this.za));
  }
};
function qu(t2) {
  return mc2("limit", t2), new Uu("limit", t2, "F");
}
function Ku(t2) {
  return mc2("limitToLast", t2), new Uu("limitToLast", t2, "L");
}
var ju = class extends $u {
  constructor(t2, e, n) {
    super(), this.type = t2, this.Ha = e, this.Ja = n;
  }
  _apply(t2) {
    const e = Ju(t2, this.type, this.Ha, this.Ja);
    return new Tc2(t2.firestore, t2.converter, function(t3, e2) {
      return new he(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, e2, t3.endAt);
    }(t2._query, e));
  }
};
function Qu(...t2) {
  return new ju("startAt", t2, true);
}
function Wu(...t2) {
  return new ju("startAfter", t2, false);
}
var Gu = class extends $u {
  constructor(t2, e, n) {
    super(), this.type = t2, this.Ha = e, this.Ja = n;
  }
  _apply(t2) {
    const e = Ju(t2, this.type, this.Ha, this.Ja);
    return new Tc2(t2.firestore, t2.converter, function(t3, e2) {
      return new he(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, e2);
    }(t2._query, e));
  }
};
function zu(...t2) {
  return new Gu("endBefore", t2, true);
}
function Hu(...t2) {
  return new Gu("endAt", t2, false);
}
function Ju(t2, e, n, s) {
  if (n[0] = getModularInstance(n[0]), n[0] instanceof bu)
    return function(t3, e2, n2, s2, i) {
      if (!s2)
        throw new q2(U2.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ${n2}().`);
      const r = [];
      for (const n3 of ye(t3))
        if (n3.field.isKeyField())
          r.push(Nt(e2, s2.key));
        else {
          const t4 = s2.data.field(n3.field);
          if (yt(t4))
            throw new q2(U2.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + n3.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
          if (t4 === null) {
            const t5 = n3.field.canonicalString();
            throw new q2(U2.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a document for which the field '${t5}' (used as the orderBy) does not exist.`);
          }
          r.push(t4);
        }
      return new ie(r, i);
    }(t2._query, t2.firestore._databaseId, e, n[0]._document, s);
  {
    const i = ru(t2.firestore);
    return function(t3, e2, n2, s2, i2, r) {
      const o = t3.explicitOrderBy;
      if (i2.length > o.length)
        throw new q2(U2.INVALID_ARGUMENT, `Too many arguments provided to ${s2}(). The number of arguments must be less than or equal to the number of orderBy() clauses`);
      const a = [];
      for (let r2 = 0; r2 < i2.length; r2++) {
        const c = i2[r2];
        if (o[r2].field.isKeyField()) {
          if (typeof c != "string")
            throw new q2(U2.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ${s2}(), but got a ${typeof c}`);
          if (!ge(t3) && c.indexOf("/") !== -1)
            throw new q2(U2.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by FieldPath.documentId(), the value passed to ${s2}() must be a plain document ID, but '${c}' contains a slash.`);
          const n3 = t3.path.child(ct.fromString(c));
          if (!Rt.isDocumentKey(n3))
            throw new q2(U2.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by FieldPath.documentId(), the value passed to ${s2}() must result in a valid document path, but '${n3}' is not because it contains an odd number of segments.`);
          const i3 = new Rt(n3);
          a.push(Nt(e2, i3));
        } else {
          const t4 = _u(n2, s2, c);
          a.push(t4);
        }
      }
      return new ie(a, r);
    }(t2._query, t2.firestore._databaseId, i, e, n, s);
  }
}
function Yu(t2, e, n) {
  if (typeof (n = getModularInstance(n)) == "string") {
    if (n === "")
      throw new q2(U2.INVALID_ARGUMENT, "Invalid query. When querying with FieldPath.documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!ge(e) && n.indexOf("/") !== -1)
      throw new q2(U2.INVALID_ARGUMENT, `Invalid query. When querying a collection by FieldPath.documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`);
    const s = e.path.child(ct.fromString(n));
    if (!Rt.isDocumentKey(s))
      throw new q2(U2.INVALID_ARGUMENT, `Invalid query. When querying a collection group by FieldPath.documentId(), the value provided must result in a valid document path, but '${s}' is not because it has an odd number of segments (${s.length}).`);
    return Nt(t2, new Rt(s));
  }
  if (n instanceof Ec2)
    return Nt(t2, n._key);
  throw new q2(U2.INVALID_ARGUMENT, `Invalid query. When querying with FieldPath.documentId(), you must provide a valid string or a DocumentReference, but it was: ${wc2(n)}.`);
}
function Xu(t2, e) {
  if (!Array.isArray(t2) || t2.length === 0)
    throw new q2(U2.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`);
  if (t2.length > 10)
    throw new q2(U2.INVALID_ARGUMENT, `Invalid Query. '${e.toString()}' filters support a maximum of 10 elements in the value array.`);
}
function Zu(t2, e, n) {
  if (!n.isEqual(e))
    throw new q2(U2.INVALID_ARGUMENT, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${n.toString()}' instead.`);
}
var th = class {
  convertValue(t2, e = "none") {
    switch (bt(t2)) {
      case 0:
        return null;
      case 1:
        return t2.booleanValue;
      case 2:
        return mt(t2.integerValue || t2.doubleValue);
      case 3:
        return this.convertTimestamp(t2.timestampValue);
      case 4:
        return this.convertServerTimestamp(t2, e);
      case 5:
        return t2.stringValue;
      case 6:
        return this.convertBytes(gt(t2.bytesValue));
      case 7:
        return this.convertReference(t2.referenceValue);
      case 8:
        return this.convertGeoPoint(t2.geoPointValue);
      case 9:
        return this.convertArray(t2.arrayValue, e);
      case 10:
        return this.convertObject(t2.mapValue, e);
      default:
        throw F2();
    }
  }
  convertObject(t2, e) {
    const n = {};
    return rt(t2.fields, (t3, s) => {
      n[t3] = this.convertValue(s, e);
    }), n;
  }
  convertGeoPoint(t2) {
    return new Xc2(mt(t2.latitude), mt(t2.longitude));
  }
  convertArray(t2, e) {
    return (t2.values || []).map((t3) => this.convertValue(t3, e));
  }
  convertServerTimestamp(t2, e) {
    switch (e) {
      case "previous":
        const n = pt(t2);
        return n == null ? null : this.convertValue(n, e);
      case "estimate":
        return this.convertTimestamp(Et(t2));
      default:
        return null;
    }
  }
  convertTimestamp(t2) {
    const e = _t(t2);
    return new nt(e.seconds, e.nanos);
  }
  convertDocumentKey(t2, e) {
    const n = ct.fromString(t2);
    M2(ys(n));
    const s = new cc2(n.get(1), n.get(3)), i = new Rt(n.popFirst(5));
    return s.isEqual(e) || k2(`Document ${i} contains a document reference within a different database (${s.projectId}/${s.database}) which is not supported. It will be treated as a reference in the current database (${e.projectId}/${e.database}) instead.`), i;
  }
};
function eh(t2, e, n) {
  let s;
  return s = t2 ? n && (n.merge || n.mergeFields) ? t2.toFirestore(e, n) : t2.toFirestore(e) : e, s;
}
var nh = class extends th {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new Jc2(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new Ec2(this.firestore, null, e);
  }
};
var sh = class {
  constructor(t2, e) {
    this._firestore = t2, this._commitHandler = e, this._mutations = [], this._committed = false, this._dataReader = ru(t2);
  }
  set(t2, e, n) {
    this._verifyNotCommitted();
    const s = ih(t2, this._firestore), i = eh(s.converter, e, n), r = ou(this._dataReader, "WriteBatch.set", s._key, i, s.converter !== null, n);
    return this._mutations.push(r.toMutation(s._key, Qe.none())), this;
  }
  update(t2, e, n, ...s) {
    this._verifyNotCommitted();
    const i = ih(t2, this._firestore);
    let r;
    return r = typeof (e = getModularInstance(e)) == "string" || e instanceof zc2 ? wu(this._dataReader, "WriteBatch.update", i._key, e, n, s) : du(this._dataReader, "WriteBatch.update", i._key, e), this._mutations.push(r.toMutation(i._key, Qe.exists(true))), this;
  }
  delete(t2) {
    this._verifyNotCommitted();
    const e = ih(t2, this._firestore);
    return this._mutations = this._mutations.concat(new rn(e._key, Qe.none())), this;
  }
  commit() {
    return this._verifyNotCommitted(), this._committed = true, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();
  }
  _verifyNotCommitted() {
    if (this._committed)
      throw new q2(U2.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.");
  }
};
function ih(t2, e) {
  if ((t2 = getModularInstance(t2)).firestore !== e)
    throw new q2(U2.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
  return t2;
}
function rh(t2) {
  t2 = _c(t2, Ec2);
  const e = _c(t2.firestore, Nc2);
  return tc2($c2(e), t2._key).then((n) => ph(e, t2, n));
}
var oh = class extends th {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new Jc2(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new Ec2(this.firestore, null, e);
  }
};
function ah(t2) {
  t2 = _c(t2, Ec2);
  const e = _c(t2.firestore, Nc2), n = $c2(e), s = new oh(e);
  return Za2(n, t2._key).then((n2) => new Su(e, s, t2._key, n2, new Vu(n2 !== null && n2.hasLocalMutations, true), t2.converter));
}
function ch(t2) {
  t2 = _c(t2, Ec2);
  const e = _c(t2.firestore, Nc2);
  return tc2($c2(e), t2._key, {
    source: "server"
  }).then((n) => ph(e, t2, n));
}
function uh(t2) {
  t2 = _c(t2, Tc2);
  const e = _c(t2.firestore, Nc2), n = $c2(e), s = new oh(e);
  return ku(t2._query), nc2(n, t2._query).then((n2) => new Cu(e, s, t2, n2));
}
function hh(t2) {
  t2 = _c(t2, Tc2);
  const e = _c(t2.firestore, Nc2), n = $c2(e), s = new oh(e);
  return ec2(n, t2._query).then((n2) => new Cu(e, s, t2, n2));
}
function lh(t2) {
  t2 = _c(t2, Tc2);
  const e = _c(t2.firestore, Nc2), n = $c2(e), s = new oh(e);
  return nc2(n, t2._query, {
    source: "server"
  }).then((n2) => new Cu(e, s, t2, n2));
}
function fh(t2, e, n) {
  t2 = _c(t2, Ec2);
  const s = _c(t2.firestore, Nc2), i = eh(t2.converter, e, n);
  return yh(s, [ou(ru(s), "setDoc", t2._key, i, t2.converter !== null, n).toMutation(t2._key, Qe.none())]);
}
function dh(t2, e, n, ...s) {
  t2 = _c(t2, Ec2);
  const i = _c(t2.firestore, Nc2), r = ru(i);
  let o;
  o = typeof (e = getModularInstance(e)) == "string" || e instanceof zc2 ? wu(r, "updateDoc", t2._key, e, n, s) : du(r, "updateDoc", t2._key, e);
  return yh(i, [o.toMutation(t2._key, Qe.exists(true))]);
}
function wh(t2) {
  return yh(_c(t2.firestore, Nc2), [new rn(t2._key, Qe.none())]);
}
function _h(t2, e) {
  const n = _c(t2.firestore, Nc2), s = bc2(t2), i = eh(t2.converter, e);
  return yh(n, [ou(ru(t2.firestore), "addDoc", s._key, i, t2.converter !== null, {}).toMutation(s._key, Qe.exists(false))]).then(() => s);
}
function mh(t2, ...e) {
  var n, s, i;
  t2 = getModularInstance(t2);
  let r = {
    includeMetadataChanges: false
  }, o = 0;
  typeof e[o] != "object" || Sc2(e[o]) || (r = e[o], o++);
  const a = {
    includeMetadataChanges: r.includeMetadataChanges
  };
  if (Sc2(e[o])) {
    const t3 = e[o];
    e[o] = (n = t3.next) === null || n === void 0 ? void 0 : n.bind(t3), e[o + 1] = (s = t3.error) === null || s === void 0 ? void 0 : s.bind(t3), e[o + 2] = (i = t3.complete) === null || i === void 0 ? void 0 : i.bind(t3);
  }
  let c, u, h;
  if (t2 instanceof Ec2)
    u = _c(t2.firestore, Nc2), h = fe(t2._key.path), c = {
      next: (n2) => {
        e[o] && e[o](ph(u, t2, n2));
      },
      error: e[o + 1],
      complete: e[o + 2]
    };
  else {
    const n2 = _c(t2, Tc2);
    u = _c(n2.firestore, Nc2), h = n2._query;
    const s2 = new oh(u);
    c = {
      next: (t3) => {
        e[o] && e[o](new Cu(u, s2, n2, t3));
      },
      error: e[o + 1],
      complete: e[o + 2]
    }, ku(t2._query);
  }
  return function(t3, e2, n2, s2) {
    const i2 = new Fa2(s2), r2 = new Ko(e2, i2, n2);
    return t3.asyncQueue.enqueueAndForget(async () => Mo(await Ja2(t3), r2)), () => {
      i2.Xo(), t3.asyncQueue.enqueueAndForget(async () => Lo(await Ja2(t3), r2));
    };
  }($c2(u), h, a, c);
}
function gh(t2, e) {
  return sc2($c2(t2 = _c(t2, Nc2)), Sc2(e) ? e : {
    next: e
  });
}
function yh(t2, e) {
  return function(t3, e2) {
    const n = new K2();
    return t3.asyncQueue.enqueueAndForget(async () => sa2(await Ha2(t3), e2, n)), n.promise;
  }($c2(t2), e);
}
function ph(t2, e, n) {
  const s = n.docs.get(e._key), i = new oh(t2);
  return new Su(t2, i, e._key, s, new Vu(n.hasPendingWrites, n.fromCache), e.converter);
}
var Eh = class extends class {
  constructor(t2, e) {
    this._firestore = t2, this._transaction = e, this._dataReader = ru(t2);
  }
  get(t2) {
    const e = ih(t2, this._firestore), n = new nh(this._firestore);
    return this._transaction.lookup([e._key]).then((t3) => {
      if (!t3 || t3.length !== 1)
        return F2();
      const s = t3[0];
      if (s.isFoundDocument())
        return new bu(this._firestore, n, s.key, s, e.converter);
      if (s.isNoDocument())
        return new bu(this._firestore, n, e._key, null, e.converter);
      throw F2();
    });
  }
  set(t2, e, n) {
    const s = ih(t2, this._firestore), i = eh(s.converter, e, n), r = ou(this._dataReader, "Transaction.set", s._key, i, s.converter !== null, n);
    return this._transaction.set(s._key, r), this;
  }
  update(t2, e, n, ...s) {
    const i = ih(t2, this._firestore);
    let r;
    return r = typeof (e = getModularInstance(e)) == "string" || e instanceof zc2 ? wu(this._dataReader, "Transaction.update", i._key, e, n, s) : du(this._dataReader, "Transaction.update", i._key, e), this._transaction.update(i._key, r), this;
  }
  delete(t2) {
    const e = ih(t2, this._firestore);
    return this._transaction.delete(e._key), this;
  }
} {
  constructor(t2, e) {
    super(t2, e), this._firestore = t2;
  }
  get(t2) {
    const e = ih(t2, this._firestore), n = new oh(this._firestore);
    return super.get(t2).then((t3) => new Su(this._firestore, n, e._key, t3._document, new Vu(false, false), e.converter));
  }
};
function Th(t2, e) {
  return ic2($c2(t2), (n) => e(new Eh(t2, n)));
}
function Ih() {
  return new au("deleteField");
}
function Ah() {
  return new uu("serverTimestamp");
}
function Rh(...t2) {
  return new hu("arrayUnion", t2);
}
function bh(...t2) {
  return new lu("arrayRemove", t2);
}
function Ph(t2) {
  return new fu("increment", t2);
}
function vh(t2) {
  return $c2(t2 = _c(t2, Nc2)), new sh(t2, (e) => yh(t2, e));
}
var Vh;
!function(t2) {
  S2 = t2;
}(SDK_VERSION), _registerComponent(new Component("firestore", (t2, { options: e }) => {
  const n = t2.getProvider("app").getImmediate(), s = new Nc2(n, new G(t2.getProvider("auth-internal")));
  return e = Object.assign({
    useFetchStreams: true
  }, e), s._setSettings(e), s;
}, "PUBLIC")), registerVersion("@firebase/firestore", "3.0.2", Vh);

export {
  N2 as N,
  $,
  L2 as L,
  q2 as q,
  Q2 as Q,
  nt,
  ht,
  ft,
  Rt,
  cc2 as cc,
  lc2 as lc,
  _c,
  pc2 as pc,
  Ec2 as Ec,
  Tc2 as Tc,
  Ic2 as Ic,
  Ac2 as Ac,
  Rc2 as Rc,
  bc2 as bc,
  Pc2 as Pc,
  vc2 as vc,
  Dc2 as Dc,
  Cc2 as Cc,
  Nc2 as Nc,
  xc2 as xc,
  kc2 as kc,
  $c2 as $c,
  Fc2 as Fc,
  Mc2 as Mc,
  Bc2 as Bc,
  Uc2 as Uc,
  qc2 as qc,
  Kc2 as Kc,
  jc2 as jc,
  Qc2 as Qc,
  Wc2 as Wc,
  zc2 as zc,
  Hc2 as Hc,
  Jc2 as Jc,
  Yc2 as Yc,
  Xc2 as Xc,
  Vu,
  Su,
  Du,
  Cu,
  xu,
  $u,
  Ou,
  Mu,
  Bu,
  qu,
  Ku,
  Qu,
  Wu,
  zu,
  Hu,
  th,
  sh,
  rh,
  ah,
  ch,
  uh,
  hh,
  lh,
  fh,
  dh,
  wh,
  _h,
  mh,
  gh,
  yh,
  Eh,
  Th,
  Ih,
  Ah,
  Rh,
  bh,
  Ph,
  vh
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
* @license
* Copyright 2020 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
//# sourceMappingURL=chunk-TGYERWRH.js.map
